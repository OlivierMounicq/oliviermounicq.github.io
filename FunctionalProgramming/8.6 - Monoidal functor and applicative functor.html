<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<div class="mainDiv">

<h1>Category Theory via C# (6) Monoidal Functor and Applicative Functor</h1>

<h1>Monoidal functor</h1>
<p>Given monoidal categories (C, ⊗, I<sub>C</sub>) and (D, ⊛, I<sub>D</sub>), a strong lax monoidal functor is a functor F: C → D equipped with:</p>
<ul>
<li>Monoid binary multiplication operation, which is a natural transformation φ: F(X) ⊛ F(Y) ⇒ F(X ⊗ Y)</li>
<li>Monoid unit, which is a morphism ι: I<sub>D</sub> → F(I<sub>C</sub>)</li>
</ul>
<p>F preserves the monoid laws in D:</p>
<ul>
<li>Associativity law is preserved with D’s associator α<sub>D</sub>:<br><a href="https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/8aeb52ea4130_CA43/Untitled-4.fw_thumb1_4.png"><img title="Untitled-4.fw_thumb1" style="border: 0px currentcolor; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" alt="Untitled-4.fw_thumb1" src="https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/8aeb52ea4130_CA43/Untitled-4.fw_thumb1_thumb_1.png" width="640" height="346" border="0"></a></li>
<li>Left unit law is preserved with D’s left unitor λ<sub>D</sub>:<br><a href="https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/8aeb52ea4130_CA43/image_thumb_2.png"><img title="image_thumb" style="margin: 0px; border: 0px currentcolor; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" alt="image_thumb" src="https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/8aeb52ea4130_CA43/image_thumb_thumb.png" width="640" height="248" border="0"></a>&nbsp; <br>and right unit law is preserved with D’s right unitor ρ<sub>D</sub>:<br><a href="https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/8aeb52ea4130_CA43/Untitled-3..fw_thumb_2.png"><img title="Untitled-3..fw_thumb" style="margin: 0px; border: 0px currentcolor; padding-top: 0px; padding-right: 0px; padding-left: 0px; display: inline; background-image: none;" alt="Untitled-3..fw_thumb" src="https://aspblogs.blob.core.windows.net/media/dixin/Windows-Live-Writer/8aeb52ea4130_CA43/Untitled-3..fw_thumb_thumb.png" width="640" height="267" border="0"></a>&nbsp;</li>
</ul>
<p>In this tutorial, strong lax monoidal functor is called monoidal functor for short. In DotNet category, monoidal functors are monoidal endofunctors. In the definition, (C, ⊗, I<sub>C</sub>) and (D, ⊛, I<sub>D</sub>) are both (DotNet, ValueTuple&lt;,&gt;, Unit), so monoidal functor can be IEnumerable&lt;T1&gt;, IEnumerable&lt;T2&gt;defined as:</p>
<pre class="code"><span style="color: blue;">public interface </span><span style="color: #2b91af;">IMonoidalFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TMonoidalFunctor<span style="color: #2b91af;"></span><span style="color: black;">&lt;&gt;</span></span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TMonoidalFunctor<span style="color: #2b91af;"></span><span style="color: black;">&lt;&gt;</span></span><span style="color: black;">&gt;
    </span><span style="color: blue;">where </span><span style="color: #2b91af;">TMonoidalFunctor </span><span style="color: black;">: </span><span style="color: #2b91af;">IMonoidalFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TMonoidalFunctor</span><span style="color: black;">&lt;&gt;&gt;
{
    <span style="color: black;"></span><span style="color: green;">// From IFunctor&lt;TMonoidalFunctor&lt;&gt;&gt;:
    </span></span><span style="color: green;">// </span><span style="color: green;">Select: (TSource -&gt; TResult) -&gt; (TMonoidalFunctor&lt;TSource&gt; -&gt; TMonoidalFunctor&lt;TResult&gt;)
    // Func&lt;TMonoidalFunctor&lt;TSource&gt;, TMonoidalFunctor&lt;TResult&gt;&gt; Select&lt;TSource, TResult&gt;(Func&lt;TSource, TResult&gt; selector);

    // Multiply: TMonoidalFunctor&lt;T1&gt; x TMonoidalFunctor&lt;T2&gt; -&gt; TMonoidalFunctor&lt;T1 x T2&gt;
    // Multiply: ValueTuple&lt;TMonoidalFunctor&lt;T1&gt;, TMonoidalFunctor&lt;T2&gt;&gt; -&gt; TMonoidalFunctor&lt;ValueTuple&lt;T1, T2&gt;&gt;
    <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(
        <span style="color: black;"></span><span style="color: #2b91af;">ValueTuple</span></span><span style="color: #2b91af;"></span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span>&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt;, <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span>&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;&gt; bifunctor);

    </span><span style="color: green;">// Unit: Unit -&gt; TMonoidalFunctor&lt;Unit&gt;
    <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit);
}</span></pre>
<p>Multiply accepts a ValueTuple&lt;IEnumerable&lt;T1&gt;, IEnumerable&lt;T2&gt;&gt; bifunctor, which is literally a 2-tuple (IEnumerable&lt;T1&gt;, IEnumerable&lt;T2&gt;). For convenience, the explicit ValueTuple&lt;,&gt; parameter can be represented by an implicit tuple, a pair of parameters. So the monoidal functor definition is equivalent to:</p>
<pre class="code"><span style="color: blue;">public interface </span><span style="color: #2b91af;">IMonoidalFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TMonoidalFunctor<span style="color: #2b91af;"></span><span style="color: black;">&lt;&gt;</span></span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TMonoidalFunctor<span style="color: #2b91af;"></span><span style="color: black;">&lt;&gt;</span></span><span style="color: black;">&gt;
    </span><span style="color: blue;">where </span><span style="color: #2b91af;">TMonoidalFunctor </span><span style="color: black;">: </span><span style="color: #2b91af;">IMonoidalFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TMonoidalFunctor</span><span style="color: black;">&lt;&gt;&gt;
{</span><span style="color: green;">
    // Multiply: TMonoidalFunctor&lt;T1&gt; x TMonoidalFunctor&lt;T2&gt; -&gt; TMonoidalFunctor&lt;T1 x T2&gt;
    // Multiply: (TMonoidalFunctor&lt;T1&gt;, TMonoidalFunctor&lt;T2&gt;) -&gt; TMonoidalFunctor&lt;(T1, T2)&gt;
    <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;(</span><span style="color: #2b91af;"></span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2)</span><span style="color: black;">&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(
        </span><span style="color: black;"><span style="color: #2b91af;">TMonoidalFunctor</span>&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span>&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;&gt; source2); <span style="color: black;"></span><span style="color: green;">// Unit: Unit</span>

    </span><span style="color: green;">// Unit: Unit -&gt; TMonoidalFunctor&lt;Unit&gt;
    <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit);
}</span></pre>
<h2>IEnumerable&lt;&gt; monoidal functor</h2>
<p>IEnumerable&lt;&gt; functor is a monoidal functor. Its Multiply method can be implemented as its extension method:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">EnumerableExtensions </span><span style="color: green;">// IEnumerable&lt;T&gt; : IMonoidalFunctor&lt;IEnumerable&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: IEnumerable&lt;T1&gt; x IEnumerable&lt;T2&gt; -&gt; IEnumerable&lt;T1 x T2&gt;
    // Multiply: ValueTuple&lt;IEnumerable&lt;T1&gt;, IEnumerable&lt;T2&gt;&gt; -&gt; IEnumerable&lt;ValueTuple&lt;T1, T2&gt;&gt;
    // Multiply: (IEnumerable&lt;T1&gt;, IEnumerable&lt;T2&gt;) -&gt; IEnumerable&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) </span><span style="color: green;">// Implicit tuple.
    </span><span style="color: black;">{
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">T1 </span><span style="color: black;">value1 </span><span style="color: blue;">in </span><span style="color: black;">source1)
        {
            </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">T2 </span><span style="color: black;">value2 </span><span style="color: blue;">in </span><span style="color: black;">source2)
            {
                </span><span style="color: blue;">yield return </span><span style="color: black;">(value1, value2);
            }
        }
    }

    </span><span style="color: green;">// Unit: Unit -&gt; IEnumerable&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">unit;
    }
}</span></pre>
<p>Now extension method Multiply can be used as a infix operator. It can be verified that the above Multiply and Unit implementations preserve the monoid laws by working with associator, left unitor and right unitor of DotNet monoidal category:</p>
<pre class="code"><span style="color: green;">// using static Dixin.Linq.CategoryTheory.DotNetCategory;
</span><span style="color: blue;">internal static void </span><span style="color: black;">MonoidalFunctorLaws()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; unit = Unit();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source1 = </span><span style="color: blue;">new int</span><span style="color: black;">[] { 0, 1 };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">char</span><span style="color: black;">&gt; source2 = </span><span style="color: blue;">new char</span><span style="color: black;">[] { </span><span style="color: #a31515;">'@'</span><span style="color: black;">, </span><span style="color: #a31515;">'#' </span><span style="color: black;">};
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">bool</span><span style="color: black;">&gt; source3 = </span><span style="color: blue;">new bool</span><span style="color: black;">[] { </span><span style="color: blue;">true</span><span style="color: black;">, </span><span style="color: blue;">false </span><span style="color: black;">};
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new int</span><span style="color: black;">[] { 0, 1, 2, 3, 4 };

    </span><span style="color: green;">// Associativity preservation: source1.Multiply(source2).Multiply(source3).Select(Associator) == source1.Multiply(source2.Multiply(source3)).
    </span><span style="color: black;">source1.Multiply(source2).Multiply(source3).Select(Associator).WriteLines();
        </span><span style="color: green;">// (0, (@, True)) (0, (@, False)) (0, (#, True)) (0, (#, False))
        // (1, (@, True)) (1, (@, False)) (1, (#, True)) (1, (#, False))
    </span><span style="color: black;">source1.Multiply(source2.Multiply(source3)).WriteLines();
        </span><span style="color: green;">// (0, (@, True)) (0, (@, False)) (0, (#, True)) (0, (#, False))
        // (1, (@, True)) (1, (@, False)) (1, (#, True)) (1, (#, False))
    // Left unit preservation: unit.Multiply(source).Select(LeftUnitor) == source.
    </span><span style="color: black;">unit.Multiply(source).Select(LeftUnitor).WriteLines(); </span><span style="color: green;">// 0 1 2 3 4
    // Right unit preservation: source == source.Multiply(unit).Select(RightUnitor).
    </span><span style="color: black;">source.Multiply(unit).Select(RightUnitor).WriteLines(); </span><span style="color: green;">// 0 1 2 3 4
</span><span style="color: black;">}</span></pre>
<p>How could these methods be useful? Remember functor’s Select method enables selector working with value(s) wrapped by functor:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Selector1Arity(</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; xs)
{
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; selector = x =&gt; x &gt; 0;
    </span><span style="color: green;">// Apply selector with xs.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">bool</span><span style="color: black;">&gt; applyWithXs = xs.Select(selector);
}</span></pre>
<p>So Select can be viewed as applying 1 arity selector (a TSource –&gt; TResult function) with TFunctor&lt;TSource&gt;. For a N arity selector, to have it work with value(s) wrapped by functor, first curry it, so that it can be viewed as 1 arity function. In the following example, the (T1, T2, T3) –&gt; TResult selector is curried to T1 –&gt; (T2 –&gt; T3 –&gt; TResult) function, so that it can be viewed as only have 1 parameter, and can work with TFunctor&lt;T1&gt;:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SelectorNArity(</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; xs, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">&gt; ys, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">&gt; zs)
{
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">long</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; selector = (x, y, z) =&gt; x + y + z &gt; 0;

    </span><span style="color: green;">// Curry selector.
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;&gt;&gt; curriedSelector =
        selector.Curry(); </span><span style="color: green;">// 1 arity: x =&gt; (y =&gt; z =&gt; x + y + z &gt; 0)
    // Partially apply selector with xs.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;&gt;&gt; applyWithXs = xs.Select(curriedSelector);</span></pre>
<p>So partially applying the T1 –&gt; (T2 –&gt; T3 –&gt; TResult) selector with TFunctor&lt;T1&gt; returns TFunctor&lt;T2 –&gt; T3 –&gt; TResult&gt;, where the T2 –&gt; T3 –&gt; TResult function is wrapped by the TFunctor&lt;&gt; functor. To further apply TFunctor&lt;T2 –&gt; T3 –&gt; TResult&gt; with TFunctor&lt;T2&gt;, Multiply can be called:</p>
<pre class="code"><span style="color: green;">    // Partially apply selector with ys.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;(</span><span style="color: black;"></span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;&gt;, </span><span style="color: blue;">long</span><span style="color: black;">)&gt; multiplyWithYs = applyWithXs.Multiply(ys);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;&gt; applyWithYs = multiplyWithYs.Select(product =&gt;
    {
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;&gt; partialAppliedSelector = product.Item1;
        </span><span style="color: blue;">long </span><span style="color: black;">y = product.Item2;
        </span><span style="color: blue;">return </span><span style="color: black;">partialAppliedSelector(y);
    });</span></pre>
<p>The result of Multiply is TFunctor&lt;(T2 –&gt; T3 –&gt; TResult, T2)&gt;, where each T2 –&gt; T3 –&gt; TResult function is paired with each T2 value, so that each function can be applied with each value, And TFunctor&lt;(T2 –&gt; T3 –&gt; TResult, T2)&gt; is mapped to TFunctor&lt;(T3 –&gt; TResult)&gt;, which can be applied with TFunctor&lt;T3&gt; in the same way:</p>
<pre class="code">    <span style="color: green;">// Partially apply selector with zs.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;(</span><span style="color: black;"></span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;, </span><span style="color: blue;">double</span><span style="color: black;">)&gt; multiplyWithZs = applyWithYs.Multiply(zs);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">bool</span><span style="color: black;">&gt; applyWithZs = multiplyWithZs.Select(product =&gt;
    {
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; partialAppliedSelector = product.Item1;
        </span><span style="color: blue;">double </span><span style="color: black;">z = product.Item2;
        </span><span style="color: blue;">return </span><span style="color: black;">partialAppliedSelector(z);
    });
}</span></pre>
<p>So Multiply enables applying functor-wrapped functions (TFunctor&lt;T –&gt; TResult&gt;) with functor-wrapped values (TFunctor&lt;TSource&gt;), which returns functor-wrapped results (TFunctor&lt;TResult&gt;). Generally, the Multiply and Select calls can be encapsulated as the following Apply method:</p>
<pre class="code"><span style="color: green;">// Apply: (IEnumerable&lt;TSource -&gt; TResult&gt;, IEnumerable&lt;TSource&gt;) -&gt; IEnumerable&lt;TResult&gt;
</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
        selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2));</span></pre>
<p>So that the above N arity selector application becomes:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Apply(</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; xs, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">&gt; ys, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">&gt; zs)
{
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">long</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; selector = (x, y, z) =&gt; x + y + z &gt; 0;
    </span><span style="color: green;">// Partially apply selector with xs.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;&gt;&gt; applyWithXs = xs.Select(selector.Curry());
    </span><span style="color: green;">// Partially apply selector with ys.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt;&gt; applyWithYs = applyWithXs.Apply(ys);
    </span><span style="color: green;">// Partially apply selector with zs.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">bool</span><span style="color: black;">&gt; applyWithZs = applyWithYs.Apply(zs);
}</span></pre>
<h1>Applicative functor</h1>
<p>A functor, with the above ability to apply functor-wrapped functions with functor-wrapped values, is also called applicative functor. The following is the definition of applicative functor:</p>
<pre class="code"><span style="color: green;">// Cannot be compiled.
</span><span style="color: blue;">public interface </span><span style="color: #2b91af;">IApplicativeFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TApplicativeFunctor</span><span style="color: black;">&lt;&gt;&gt; : </span><span style="color: #2b91af;">IFunctor</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TApplicativeFunctor</span><span style="color: black;">&lt;&gt;&gt;
    <span style="color: blue;">where</span> <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span>&lt;&gt; : </span><span style="color: #2b91af;">IApplicativeFunctor</span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span>&lt;&gt;&gt;
{
    </span><span style="color: green;">// From: IFunctor&lt;TApplicativeFunctor&lt;&gt;&gt;:
    // Select: (TSource -&gt; TResult) -&gt; (TApplicativeFunctor&lt;TSource&gt; -&gt; TApplicativeFunctor&lt;TResult&gt;)
    // Func&lt;TApplicativeFunctor&lt;TSource&gt;, TApplicativeFunctor&lt;TResult&gt;&gt; Select&lt;TSource, TResult&gt;(Func&lt;TSource, TResult&gt; selector);

    // Apply: (TApplicativeFunctor&lt;TSource -&gt; TResult&gt;, TApplicativeFunctor&lt;TSource&gt; -&gt; TApplicativeFunctor&lt;TResult&gt;
    <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span>&lt;<span style="color: black;"></span><span style="color: #2b91af;">Func</span>&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span>&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

    </span><span style="color: green;">// Wrap: TSource -&gt; TApplicativeFunctor&lt;TSource&gt;
    <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Wrap&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value);
}</span></pre>
<p>And applicative functor must satisfy the applicative laws:</p>
<ul>
<li>Functor preservation: applying function is equivalent to applying functor-wrapped function</li>
<li>Identity preservation: applying functor-wrapped identity function, is equivalent to doing nothing.</li>
<li>Composition preservation: functor-wrapped functions can be composed by applying.</li>
<li>Homomorphism: applying functor-wrapped function with functor-wrapped value, is equivalent to functor-wrapping the result of applying that function with that value.</li>
<li>Interchange: when applying functor-wrapped functions with a functor-wrapped value, the functor-wrapped functions and the functor-wrapped value can interchange position.</li>
</ul>
<h2>IEnumerable&lt;&gt; applicative functor</h2>
<p>IEnumerable&lt;&gt; functor is a applicative functor. Again, these methods are implemented as extension methods. And for IEnumerable&lt;&gt;, the Wrap method is called Enumerable to be intuitive:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">EnumerableExtensions </span><span style="color: green;">// IEnumerable&lt;T&gt; : IApplicativeFunctor&lt;IEnumerable&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (IEnumerable&lt;TSource -&gt; TResult&gt;, IEnumerable&lt;TSource&gt;) -&gt; IEnumerable&lt;TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
    {
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector </span><span style="color: blue;">in </span><span style="color: black;">selectorWrapper)
        {
            </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
            {
                </span><span style="color: blue;">yield return </span><span style="color: black;">selector(value);
            }
        }
    }

    </span><span style="color: green;">// Wrap: TSource -&gt; IEnumerable&lt;TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Enumerable&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">value;
    }
}</span></pre>
<p>It can be verified that the above Apply and Wrap (Enumerable) implementations satisfy the applicative laws:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ApplicativeLaws()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new int</span><span style="color: black;">[] { 0, 1, 2, 3, 4 };
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt; selector = int32 =&gt; </span><span style="color: #2b91af;">Math</span><span style="color: black;">.Sqrt(int32);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;&gt; selectorWrapper1 =
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;[] { int32 =&gt; int32 / 2D, int32 =&gt; </span><span style="color: #2b91af;">Math</span><span style="color: black;">.Sqrt(int32) };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt; selectorWrapper2 =
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;[] { @double =&gt; @double.ToString(</span><span style="color: #a31515;">"0.0"</span><span style="color: black;">), @double =&gt; @double.ToString(</span><span style="color: #a31515;">"0.00"</span><span style="color: black;">) };
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt;&gt; o =
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt;(Linq.</span><span style="color: #2b91af;">FuncExtensions</span><span style="color: black;">.o).Curry();
    </span><span style="color: blue;">int </span><span style="color: black;">value = 5;

    </span><span style="color: green;">// Functor preservation: source.Select(selector) == selector.Wrap().Apply(source).
    </span><span style="color: black;">source.Select(selector).WriteLines(); </span><span style="color: green;">// 0 1 1.4142135623731 1.73205080756888 2
    </span><span style="color: black;">selector.Enumerable().Apply(source).WriteLines(); </span><span style="color: green;">// 0 1 1.4142135623731 1.73205080756888 2
    // Identity preservation: Id.Wrap().Apply(source) == source.
    </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">Functions</span><span style="color: black;">.Id).Enumerable().Apply(source).WriteLines(); </span><span style="color: green;">// 0 1 2 3 4
    // Composition preservation: o.Wrap().Apply(selectorWrapper2).Apply(selectorWrapper1).Apply(source) == selectorWrapper2.Apply(selectorWrapper1.Apply(source)).
    </span><span style="color: black;">o.Enumerable().Apply(selectorWrapper2).Apply(selectorWrapper1).Apply(source).WriteLines();
        </span><span style="color: green;">// 0.0  0.5  1.0  1.5  2.0
        // 0.0  1.0  1.4  1.7  2.0
        // 0.00 0.50 1.00 1.50 2.00
        // 0.00 1.00 1.41 1.73 2.00
    </span><span style="color: black;">selectorWrapper2.Apply(selectorWrapper1.Apply(source)).WriteLines();
        </span><span style="color: green;">// 0.0  0.5  1.0  1.5  2.0
        // 0.0  1.0  1.4  1.7  2.0
        // 0.00 0.50 1.00 1.50 2.00
        // 0.00 1.00 1.41 1.73 2.00
    // Homomorphism: selector.Wrap().Apply(value.Wrap()) == selector(value).Wrap().
    </span><span style="color: black;">selector.Enumerable().Apply(value.Enumerable()).WriteLines(); </span><span style="color: green;">// 2.23606797749979
    </span><span style="color: black;">selector(value).Enumerable().WriteLines(); </span><span style="color: green;">// 2.23606797749979
    // Interchange: selectorWrapper.Apply(value.Wrap()) == (selector =&gt; selector(value)).Wrap().Apply(selectorWrapper).
    </span><span style="color: black;">selectorWrapper1.Apply(value.Enumerable()).WriteLines(); </span><span style="color: green;">// 2.5 2.23606797749979
    </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: blue;">double</span><span style="color: black;">&gt;(function =&gt; function(value)).Enumerable().Apply(selectorWrapper1)
        .WriteLines(); </span><span style="color: green;">// 2.5 2.23606797749979
</span><span style="color: black;">}</span></pre>
<h1>Monoidal functor vs. applicative functor</h1>
<p>The applicative functor definition is actually equivalent to above monoidal functor definition. First, applicative functor’s Apply and Wrap methods can be implemented by monoidal functor’s Multiply and Unit methods:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">EnumerableExtensions </span><span style="color: green;">// IEnumerable&lt;T&gt; : IApplicativeFunctor&lt;IEnumerable&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (IEnumerable&lt;TSource -&gt; TResult&gt;, IEnumerable&lt;TSource&gt;) -&gt; IEnumerable&lt;TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2));

    </span><span style="color: green;">// Wrap: TSource -&gt; IEnumerable&lt;TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Enumerable&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value) =&gt; Unit().Select(unit =&gt; value);
}</span></pre>
<p>On the other hand, monoidal functor’s Multiply and Unit methods can be implemented by applicative functor’s Apply and Wrap methods:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">EnumerableExtensions </span><span style="color: green;">// IEnumerable&lt;T&gt; : IMonoidalFunctor&lt;IEnumerable&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: IEnumerable&lt;T1&gt; x IEnumerable&lt;T2&gt; -&gt; IEnumerable&lt;T1 x T2&gt;
    // Multiply: (IEnumerable&lt;T1&gt;, IEnumerable&lt;T2&gt;) -&gt; IEnumerable&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;(</span><span style="color: black;"></span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) =&gt;
            </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">, (</span><span style="color: #2b91af;"></span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt;(</span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">.Create).Curry().Enumerable().Apply(source1).Apply(source2);

    </span><span style="color: green;">// Unit: Unit -&gt; IEnumerable&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt; unit.Enumerable();
}</span></pre>
<p>Generally, for any applicative functor, its (Apply, Wrap) method pair can implement the (Multiply, Unit) method pair required as monoidal functor, and vice versa. This can be virtually demonstrated as:</p>
<pre class="code"><span style="color: green;">// Cannot be compiled.
</span><span style="color: blue;">public static class </span><span style="color: #2b91af;">MonoidalFunctorExtensions </span><span style="color: green;">// (Multiply, Unit) implements (Apply, Wrap).
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (TMonoidalFunctor&lt;TSource -&gt; TResult&gt;, TMonoidalFunctor&lt;TSource&gt;) -&gt; TMonoidalFunctor&lt;TResult&gt;
    </span><span style="color: blue;">public static <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TMonoidalFunctor</span><span style="color: black;">&lt;&gt;, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">Func</span>&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span>&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
        </span><span style="color: blue;">where </span><span style="color: #2b91af;">TMonoidalFunctor</span><span style="color: black;">&lt;&gt; : </span><span style="color: #2b91af;">IMonoidalFunctor</span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: red;"></span><span style="color: black;">&lt;&gt;&gt; =&gt;
            selectorWrapper</span><span style="color: red;"></span><span style="color: black;">.Multiply(source</span><span style="color: red;"></span><span style="color: black;">).Select(product </span><span style="color: red;"></span><span style="color: black;">=&gt; product.Item1(product.Item2));

    </span><span style="color: green;">// Wrap: TSource -&gt; TMonoidalFunctor&lt;TSource&gt;
    </span><span style="color: blue;">public static <span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Wrap&lt;</span><span style="color: #2b91af;">TMonoidalFunctor</span><span style="color: black;">&lt;&gt;, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value)
        </span><span style="color: blue;">where </span><span style="color: #2b91af;">TMonoidalFunctor</span><span style="color: black;">&lt;&gt; : </span><span style="color: #2b91af;">IMonoidalFunctor</span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: red;"></span><span style="color: black;">&lt;&gt;&gt; =&gt;<span style="color: blue;"><span style="color: black;"></span><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;</span><span style="color: green;">
            </span><span style="color: blue;"><span style="color: #2b91af;">TMonoidalFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;.U</span>nit().Select(unit </span><span style="color: red;"></span><span style="color: black;">=&gt; value);
}

</span><span style="color: green;">// Cannot be compiled.
</span><span style="color: blue;">public static class </span><span style="color: #2b91af;">ApplicativeFunctorExtensions </span><span style="color: green;">// (Apply, Wrap) implements (Multiply, Unit).
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: TApplicativeFunctor&lt;T1&gt; x TApplicativeFunctor&lt;T2&gt; -&gt; TApplicativeFunctor&lt;T1 x T2&gt;
    // Multiply: (TApplicativeFunctor&lt;T1&gt;, TApplicativeFunctor&lt;T2&gt;) -&gt; TApplicativeFunctor&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span></span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">TApplicativeFunctor</span><span style="color: black;">&lt;&gt;, </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span>&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2)
        </span><span style="color: blue;">where </span><span style="color: #2b91af;">TApplicativeFunctor</span><span style="color: black;">&lt;&gt; : </span><span style="color: #2b91af;">IApplicativeFunctor</span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span></span><span style="color: red;"></span><span style="color: black;">&lt;&gt;&gt; =&gt;
            </span><span style="color: blue;">new <span style="color: black;"></span><span style="color: #2b91af;">Func</span></span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span></span><span style="color: red;"></span><span style="color: black;">, (<span style="color: black;"></span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span></span><span style="color: black;">)&gt;(<span style="color: #2b91af;">ValueTuple</span>.Create</span><span style="color: black;">).Curry().Wrap().Apply(source1</span><span style="color: red;"></span><span style="color: black;">).Apply(source2</span><span style="color: red;"></span><span style="color: black;">);

    </span><span style="color: green;">// Unit: Unit -&gt; TApplicativeFunctor&lt;Unit&gt;
    </span><span style="color: blue;">public static <span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span></span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">Unit</span>&gt; Unit&lt;</span><span style="color: #2b91af;">TApplicativeFunctor</span><span style="color: black;">&lt;&gt;&gt;(Unit unit = </span><span style="color: blue;">default</span><span style="color: black;">)
        </span><span style="color: blue;">where </span><span style="color: #2b91af;">TApplicativeFunctor</span><span style="color: black;">&lt;&gt; : </span><span style="color: #2b91af;">IApplicativeFunctor</span><span style="color: black;">&lt;<span style="color: black;"></span><span style="color: #2b91af;">TApplicativeFunctor</span></span><span style="color: red;"></span><span style="color: black;">&lt;&gt;&gt; =&gt; unit</span><span style="color: black;">.Wrap();
}</span></pre>
<h1>More Monoidal functors and applicative functors</h1>
<p>The Lazy&lt;&gt;, Func&lt;&gt;, Func&lt;T,&gt; functors are also monoidal/applicative functors:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">LazyExtensions </span><span style="color: green;">// Lazy&lt;T&gt; : IMonoidalFunctor&lt;Lazy&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: Lazy&lt;T1&gt; x Lazy&lt;T2&gt; -&gt; Lazy&lt;T1 x T2&gt;
    // Multiply: (Lazy&lt;T1&gt;, Lazy&lt;T2&gt;) -&gt; Lazy&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) =&gt;
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt;(() =&gt; (source1.Value, source2.Value));

    </span><span style="color: green;">// Unit: Unit -&gt; Lazy&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt; </span><span style="color: blue;">new </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt;(() =&gt; unit);
}

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">LazyExtensions </span><span style="color: green;">// Lazy&lt;T&gt; : IApplicativeFunctor&lt;Lazy&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (Lazy&lt;TSource -&gt; TResult&gt;, Lazy&lt;TSource&gt;) -&gt; Lazy&lt;TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2));

    </span><span style="color: green;">// Wrap: TSource -&gt; Lazy&lt;TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Lazy</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; Lazy&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">T </span><span style="color: black;">value) =&gt; Unit().Select(unit =&gt; value);
}</span><span style="color: black;">

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">FuncExtensions </span><span style="color: green;">// Func&lt;T&gt; : IMonoidalFunctor&lt;Func&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: Func&lt;T1&gt; x Func&lt;T2&gt; -&gt; Func&lt;T1 x T2&gt;
    // Multiply: (Func&lt;T1&gt;, Func&lt;T2&gt;) -&gt; Func&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) =&gt;
        () =&gt; (source1(), source2());

    </span><span style="color: green;">// Unit: Unit -&gt; Func&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt; () =&gt; unit;
}

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">FuncExtensions </span><span style="color: green;">// Func&lt;T&gt; : IApplicativeFunctor&lt;Func&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (Func&lt;TSource -&gt; TResult&gt;, Func&lt;TSource&gt;) -&gt; Func&lt;TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2));

    </span><span style="color: green;">// Wrap: TSource -&gt; Func&lt;TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; Func&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">T </span><span style="color: black;">value) =&gt; Unit().Select(unit =&gt; value);
}</span><span style="color: black;">

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">FuncExtensions </span><span style="color: green;">// Func&lt;T, TResult&gt; : IMonoidalFunctor&lt;Func&lt;T,&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: Func&lt;T, T1&gt; x Func&lt;T, T2&gt; -&gt; Func&lt;T, T1 x T2&gt;
    // Multiply: (Func&lt;T, T1&gt;, Func&lt;T, T2&gt;) -&gt; Func&lt;T, (T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, (</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) =&gt;
        value =&gt; (source1(value), source2(value));

    </span><span style="color: green;">// Unit: Unit -&gt; Func&lt;T, Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt; _ =&gt; unit;
}

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">FuncExtensions </span><span style="color: green;">// Func&lt;T, TResult&gt; : IApplicativeFunctor&lt;Func&lt;T,&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (Func&lt;T, TSource -&gt; TResult&gt;, Func&lt;T, TSource&gt;) -&gt; Func&lt;T, TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2));

    </span><span style="color: green;">// Wrap: TSource -&gt; Func&lt;T, TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Func&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value) =&gt; Unit&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;().Select(unit =&gt; value);
}</span><span style="color: black;">

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">OptionalExtensions </span><span style="color: green;">// Optional&lt;T&gt; : IMonoidalFunctor&lt;Optional&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: Optional&lt;T1&gt; x Optional&lt;T2&gt; -&gt; Optional&lt;T1 x T2&gt;
    // Multiply: (Optional&lt;T1&gt;, Optional&lt;T2&gt;) -&gt; Optional&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) =&gt;
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt;(() =&gt; source1.HasValue &amp;&amp; source2.HasValue
            ? (</span><span style="color: blue;">true</span><span style="color: black;">, (source1.Value, source2.Value))
            : (</span><span style="color: blue;">false</span><span style="color: black;">, (</span><span style="color: blue;">default</span><span style="color: black;">, </span><span style="color: blue;">default</span><span style="color: black;">)));

    </span><span style="color: green;">// Unit: Unit -&gt; Optional&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt;
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt;(() =&gt; (</span><span style="color: blue;">true</span><span style="color: black;">, unit));
}

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">OptionalExtensions </span><span style="color: green;">// Optional&lt;T&gt; : IApplicativeFunctor&lt;Optional&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (Optional&lt;TSource -&gt; TResult&gt;, Optional&lt;TSource&gt;) -&gt; Optional&lt;TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2));

    </span><span style="color: green;">// Wrap: TSource -&gt; Optional&lt;TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Optional</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; Optional&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">T </span><span style="color: black;">value) =&gt; Unit().Select(unit =&gt; value);
}</span></pre>
<p>The ValueTuple&lt;&gt; and Task&lt;&gt; functors are monoidal/applicative functors too. Notice their Multiply/Apply methods cannot defer the execution, and Task&lt;&gt;’s Multiply/Apply methods are impure.</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">ValueTupleExtensions </span><span style="color: green;">// ValueTuple&lt;T&gt; : IMonoidalFunctor&lt;ValueTuple&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: ValueTuple&lt;T1&gt; x ValueTuple&lt;T2&gt; -&gt; ValueTuple&lt;T1 x T2&gt;
    // Multiply: (ValueTuple&lt;T1&gt;, ValueTuple&lt;T2&gt;) -&gt; ValueTuple&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) =&gt;
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt;((source1.Item1, source2.Item1)); </span><span style="color: green;">// Immediate execution.

    // Unit: Unit -&gt; ValueTuple&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt; </span><span style="color: blue;">new </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt;(unit);
}

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">ValueTupleExtensions </span><span style="color: green;">// ValueTuple&lt;T&gt; : IApplicativeFunctor&lt;ValueTuple&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (ValueTuple&lt;TSource -&gt; TResult&gt;, ValueTuple&lt;TSource&gt;) -&gt; ValueTuple&lt;TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2)); </span><span style="color: green;">// Immediate execution.

    // Wrap: TSource -&gt; ValueTuple&lt;TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">ValueTuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; ValueTuple&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">T </span><span style="color: black;">value) =&gt; Unit().Select(unit =&gt; value);
}
</span><span style="color: black;">
</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">TaskExtensions </span><span style="color: green;">// Task&lt;T&gt; : IMonoidalFunctor&lt;Task&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: Task&lt;T1&gt; x Task&lt;T2&gt; -&gt; Task&lt;T1 x T2&gt;
    // Multiply: (Task&lt;T1&gt;, Task&lt;T2&gt;) -&gt; Task&lt;(T1, T2)&gt;
    </span><span style="color: blue;">public static async </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;(</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)&gt; Multiply&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; source1, </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; source2) =&gt;
        ((</span><span style="color: blue;">await </span><span style="color: black;">source1), (</span><span style="color: blue;">await </span><span style="color: black;">source2)); </span><span style="color: green;">// Immediate execution, impure.

    // Unit: Unit -&gt; Task&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Unit</span><span style="color: black;">&gt; Unit(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt; System.Threading.Tasks.</span><span style="color: #2b91af;">Task</span><span style="color: black;">.FromResult(unit);
}

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">TaskExtensions </span><span style="color: green;">// Task&lt;T&gt; : IApplicativeFunctor&lt;Task&lt;&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (Task&lt;TSource -&gt; TResult&gt;, Task&lt;TSource&gt;) -&gt; Task&lt;TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Apply&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selectorWrapper, </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2)); </span><span style="color: green;">// Immediate execution, impure.

    // Wrap: TSource -&gt; Task&lt;TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">Task</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; Task&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">T </span><span style="color: black;">value) =&gt; Unit().Select(unit =&gt; value);
}</span></pre>
<p>It is easy to verify all the above (Multiply, Unit) method pairs preserve the monoid laws, and all the above (Apply, Wrap) method pairs satisfy the applicative laws. However, not any (Multiply, Unit) or any (Apply, Wrap) can automatically satisfy the laws. Take the ValueTuple&lt;T,&gt; functor as example:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">ValueTupleExtensions </span><span style="color: green;">// ValueTuple&lt;T1, T2 : IMonoidalFunctor&lt;ValueTuple&lt;T,&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Multiply: ValueTuple&lt;T, T1&gt; x ValueTuple&lt;T, T2&gt; -&gt; ValueTuple&lt;T, T1 x T2&gt;
    // Multiply: (ValueTuple&lt;T, T1&gt;, ValueTuple&lt;T, T2&gt;) -&gt; ValueTuple&lt;T, (T1, T2)&gt;
    </span><span style="color: blue;">public static </span><span style="color: black;">(</span><span style="color: #2b91af;">T</span><span style="color: black;">, (</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">)) Multiply&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: black;">(</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T1</span><span style="color: black;">) source1, (</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">) source2) =&gt;
        (source1.Item1, (source1.Item2, source2.Item2)); </span><span style="color: green;">// Immediate execution.

    // Unit: Unit -&gt; ValueTuple&lt;Unit&gt;
    </span><span style="color: blue;">public static </span><span style="color: black;">(</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">Unit</span><span style="color: black;">) Unit&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">Unit </span><span style="color: black;">unit = </span><span style="color: blue;">default</span><span style="color: black;">) =&gt; (</span><span style="color: blue;">default</span><span style="color: black;">, unit);
}

</span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">ValueTupleExtensions </span><span style="color: green;">// ValueTuple&lt;T, TResult&gt; : IApplicativeFunctor&lt;ValueTuple&lt;T,&gt;&gt;
</span><span style="color: black;">{
    </span><span style="color: green;">// Apply: (ValueTuple&lt;T, TSource -&gt; TResult&gt;, ValueTuple&lt;T, TSource&gt;) -&gt; ValueTuple&lt;T, TResult&gt;
    </span><span style="color: blue;">public static </span><span style="color: black;">(</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">) Apply&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: black;">(</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;) selectorWrapper, (</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">) source) =&gt;
            selectorWrapper.Multiply(source).Select(product =&gt; product.Item1(product.Item2)); </span><span style="color: green;">// Immediate execution.

    // Wrap: TSource -&gt; ValueTuple&lt;T, TSource&gt;
    </span><span style="color: blue;">public static </span><span style="color: black;">(</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">) ValueTuple&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value) =&gt; Unit&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;().Select(unit =&gt; value);
}</span></pre>
<p>The above (Multiply, Unit) implementations cannot preserve the left unit law:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">MonoidalFunctorLaws()
{
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">) source = (</span><span style="color: #a31515;">"a"</span><span style="color: black;">, 1);
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Unit</span><span style="color: black;">) unit = Unit&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;();
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">) source1 = (</span><span style="color: #a31515;">"b"</span><span style="color: black;">, 2);
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">char</span><span style="color: black;">) source2 = (</span><span style="color: #a31515;">"c"</span><span style="color: black;">, </span><span style="color: #a31515;">'@'</span><span style="color: black;">);
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">) source3 = (</span><span style="color: #a31515;">"d"</span><span style="color: black;">, </span><span style="color: blue;">true</span><span style="color: black;">);

    </span><span style="color: green;">// Associativity preservation: source1.Multiply(source2).Multiply(source3).Select(Associator) == source1.Multiply(source2.Multiply(source3)).
    </span><span style="color: black;">source1.Multiply(source2).Multiply(source3).Select(Associator).WriteLine(); </span><span style="color: green;">// (b, (2, (@, True)))
    </span><span style="color: black;">source1.Multiply(source2.Multiply(source3)).WriteLine(); </span><span style="color: green;">// (b, (2, (@, True)))
    // Left unit preservation: unit.Multiply(source).Select(LeftUnitor) == source.
    </span><span style="color: black;">unit.Multiply(source).Select(LeftUnitor).WriteLine(); </span><span style="color: green;">// (, 1)
    // Right unit preservation: source == source.Multiply(unit).Select(RightUnitor).
    </span><span style="color: black;">source.Multiply(unit).Select(RightUnitor).WriteLine(); </span><span style="color: green;">// (a, 1)
</span><span style="color: black;">}</span></pre>
<p>And the above (Apply, Wrap) implementation breaks all applicative laws:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ApplicativeLaws()
{
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">) source = (</span><span style="color: #a31515;">"a"</span><span style="color: black;">, 1);
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt; selector = int32 =&gt; </span><span style="color: #2b91af;">Math</span><span style="color: black;">.Sqrt(int32);
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;) selectorWrapper1 =
        (</span><span style="color: #a31515;">"b"</span><span style="color: black;">, </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;(int32 =&gt; </span><span style="color: #2b91af;">Math</span><span style="color: black;">.Sqrt(int32)));
    (</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;) selectorWrapper2 =
        (</span><span style="color: #a31515;">"c"</span><span style="color: black;">, </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;(@double =&gt; @double.ToString(</span><span style="color: #a31515;">"0.00"</span><span style="color: black;">)));
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt;&gt; o =
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt;(Linq.</span><span style="color: #2b91af;">FuncExtensions</span><span style="color: black;">.o).Curry();
    </span><span style="color: blue;">int </span><span style="color: black;">value = 5;

    </span><span style="color: green;">// Functor preservation: source.Select(selector) == selector.Wrap().Apply(source).
    </span><span style="color: black;">source.Select(selector).WriteLine(); </span><span style="color: green;">// (a, 1)
    </span><span style="color: black;">selector.ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;&gt;().Apply(source).WriteLine(); </span><span style="color: green;">// (, 1)
    // Identity preservation: Id.Wrap().Apply(source) == source.
    </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">Functions</span><span style="color: black;">.Id).ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;&gt;().Apply(source).WriteLine(); </span><span style="color: green;">// (, 1)
    // Composition preservation: o.Curry().Wrap().Apply(selectorWrapper2).Apply(selectorWrapper1).Apply(source) == selectorWrapper2.Apply(selectorWrapper1.Apply(source)).
    </span><span style="color: black;">o.ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt;&gt;&gt;()
        .Apply(selectorWrapper2).Apply(selectorWrapper1).Apply(source).WriteLine(); </span><span style="color: green;">// (, 1.00)
    </span><span style="color: black;">selectorWrapper2.Apply(selectorWrapper1.Apply(source)).WriteLine(); </span><span style="color: green;">// (c, 1.00)
    // Homomorphism: selector.Wrap().Apply(value.Wrap()) == selector(value).Wrap().
    </span><span style="color: black;">selector.ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;&gt;().Apply(value.ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;()).WriteLine(); </span><span style="color: green;">// (, 2.23606797749979)
    </span><span style="color: black;">selector(value).ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;().WriteLine(); </span><span style="color: green;">// (, 2.23606797749979)
    // Interchange: selectorWrapper.Apply(value.Wrap()) == (selector =&gt; selector(value)).Wrap().Apply(selectorWrapper).
    </span><span style="color: black;">selectorWrapper1.Apply(value.ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;()).WriteLine(); </span><span style="color: green;">// (b, 2.23606797749979)
    </span><span style="color: blue;">new </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: blue;">double</span><span style="color: black;">&gt;(function =&gt; function(value))
        .ValueTuple&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;, </span><span style="color: blue;">double</span><span style="color: black;">&gt;&gt;().Apply(selectorWrapper1).WriteLine(); </span><span style="color: green;">// (, 2.23606797749979)
</span><span style="color: black;">}</span>


</div>
</body>
</html>
