<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<div class="mainDiv">


<h1>LINQ to XML (2) Query Methods (Operators)</h1>

<p>As fore mentioned, LINQ to XML is just a specialized LINQ to Objects, so all the LINQ to Objects query methods can be used in LINQ to XML queries. LINQ to XML provides many function members and other methods for XML tree navigation, ordering, XPath querying, etc. The following list shows these functions and their return types:</p>
<ul>
<li>Navigation queries</li>
<ul><!--StartFragment-->
<li>Query direct parent element</li>
<ul>
<li>XObject.Parent -&gt; XElement</li>
</ul>
<li>Query all ancestor elements:</li>
<ul>
<li>XNode.Ancestors -&gt; IEnumerable&lt;XElement&gt;</li>
<li>XElement.AncestorsAndSelf -&gt; IEnumerable&lt;XElement&gt;</li>
<li>IEnumerable&lt;T&gt;.Ancestors* -&gt; IEnumerable&lt;XElement&gt;, where T : XNode</li>
<li>IEnumerable&lt;XElement&gt;.AncestorsAndSelf*&nbsp; -&gt; IEnumerable&lt;XElement&gt;</li>
<!--EndFragment--><!--StartFragment--></ul>
<li>Query direct child elements</li>
<ul>
<li>XDocument.Root-&gt; XElement</li>
<li>XContainer.Element -&gt; XElement</li>
<li>XContainer.Elements -&gt; IEnumerable&lt;XElement&gt;</li>
<li>IEnumerable&lt;T&gt;.Elements* -&gt; IEnumerable&lt;XElement&gt;, where T : XContainer</li>
</ul>
<li>Query direct child nodes</li>
<ul>
<li>XContainer.FirstNode -&gt; XNode</li>
<li>XContainer.LastNode -&gt; XNode</li>
<li>XContainer.Nodes -&gt; IEnumerable&lt;XNode&gt;</li>
<li>IEnumerable&lt;T&gt;.Nodes* -&gt; IEnumerable&lt;XNode&gt;, where T : XContainer</li>
<!--EndFragment--></ul>
<li>Query all descendant elements</li>
<ul>
<li>XContainer.Descendants -&gt; IEnumerable&lt;XElement&gt;</li>
<li>XElement.DescendantsAndSelf -&gt; IEnumerable&lt;XElement&gt;</li>
<li>IEnumerable&lt;T&gt;.Descendants* -&gt; IEnumerable&lt;XElement&gt;, where T : XContainer</li>
<li>IEnumerable&lt;XElement&gt;.DescendantsAndSelf* -&gt; IEnumerable&lt;XElement&gt;<!--EndFragment--></li>
</ul>
<li>Query all descendant nodes</li>
<ul>
<li>XContainer.DescendantNodes -&gt; IEnumerable&lt;XNode&gt;</li>
<li>XElement.DescendantNodesAndSelf =&gt; IEnumerable&lt;XNode&gt;</li>
<li>IEnumerable&lt;T&gt;.DescendantNodes* -&gt; IEnumerable&lt;XNode&gt;, where T : XContainer</li>
<li>IEnumerable&lt;XElement&gt;.DescendantNodesAndSelf* -&gt; IEnumerable&lt;XNode&gt;</li>
<!--StartFragment--></ul>
<li>Query sibling elements</li>
<ul>
<li>XNode.ElementsAfterSelf -&gt; IEnumerable&lt;XElement&gt;</li>
<li>XNode.ElementsBeforeSelf -&gt; IEnumerable&lt;XElement&gt;</li>
<!--EndFragment--></ul>
<li>Query sibling nodes</li>
<ul>
<li>XNode.PreviousNode -&gt; XNode</li>
<li>XNode.NextNode -&gt; XNode</li>
<li>XNode.NodesBeforeSelf -&gt; IEnumerable&lt;XNode&gt;</li>
<li>XNode.NodesAfterSelf -&gt; IEnumerable&lt;XNode&gt;</li>
</ul>
<li>Query attributes</li>
<ul>
<li>XAttribute.PreviousAttribute –&gt; XAttribute</li>
<li>XAttribute.NextAttribute -&gt; XAttribute</li>
<li>XElement.FirstAttribute -&gt; XAttribute</li>
<li>XElement.LastAttribute -&gt; XAttribute</li>
<li>XElement.Attribute -&gt; XAttribute</li>
<li>XElement.Attributes -&gt; IEnumerable&lt;XAttribute&gt;</li>
<li>IEnumerable&lt;XElement&gt;.Attributes* -&gt; IEnumerable&lt;XAttribute&gt;</li>
</ul>
<li>Query document</li>
<ul>
<li>XObject.Document –&gt; XDocument</li>
</ul>
<li>Query annotations</li>
<ul>
<li>XObject.Annotation&lt;T&gt; –&gt; T, where T : class</li>
<li>XObject.Annotations –&gt; IEnumerable&lt;object&gt;</li>
</ul>
</ul>
<li>Ordering queries</li>
<ul>
<li>XNode.CompareDocumentOrder -&gt; int</li>
<li>XNode.IsAfter -&gt; bool</li>
<li>XNode.IsBefore -&gt; bool</li>
<li>XNodeDocumentOrderComparer.Compare -&gt; int</li>
<li>IEnumerable&lt;T&gt;.InDocumentOrder* -&gt; IEnumerable&lt;T&gt;, where T : XNode</li>
</ul>
<li>Comparison queries</li>
<ul>
<li>XNode.DocumentOrderComparer –&gt; XNodeDocumentOrderComparer</li>
<li>XNodeDocumentOrderComparer.Compare –&gt; int</li>
<li>XNode.EqualityComparer –&gt; XNodeEqualityComparer</li>
<li>XNodeEqualityComparer.Equals –&gt; bool</li>
</ul>
<li>XPath queries</li>
<ul><!--StartFragment-->
<li>XNode.CreateNavigator** –&gt; XPathNavigator</li>
<li>XNode.XPathSelectElement** –&gt; XElement</li>
<li>XNode.XPathSelectElements** –&gt; IEnumerable&lt;XElement&gt;</li>
<li>XNode.XPathEvaluate** –&gt; object<!--EndFragment--></li>
</ul>
</ul>
<p>The functions with * are extension methods provided in static type System.Xml.Linq.Extensions. The functions with ** are extension methods provided in static type System.Xml.XPath.Extensions. The other methods are instance methods or properties.</p>
<h1>Navigation</h1>
<p>LINQ to XML provides rich APIs for navigation. And the methods returning IEnumerable&lt;XObject&gt; are also called <a href="https://msdn.microsoft.com/en-us/library/bb387055.aspx" target="_blank">axis methods or axes</a>. The following example queries the parent element and ancestor element, where. ancestors are parent, parent’s parent, …, recursively:</p>
<pre class="code"><span style="color: blue;">internal static partial class </span><span style="color: #2b91af;">QueryMethods
</span><span style="color: black;">{
    </span><span style="color: blue;">internal static void </span><span style="color: black;">ParentAndAncestors()
    {
        </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element = </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"element"</span><span style="color: black;">);
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">XDocument</span><span style="color: black;">(</span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"grandparent"</span><span style="color: black;">, </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"parent"</span><span style="color: black;">, element)));

        element.Parent.Name.WriteLine(); </span><span style="color: green;">// parent
        </span><span style="color: black;">element
            .Ancestors()
            .Select(ancestor =&gt; ancestor.Name)
            .WriteLines(); </span><span style="color: green;">// parent grandparent
        </span><span style="color: black;">element
            .AncestorsAndSelf()
            .Select(selfOrAncestor =&gt; selfOrAncestor.Name)
            .WriteLines(); </span><span style="color: green;">// element parent grandparent
        </span><span style="color: blue;">object</span><span style="color: black;">.ReferenceEquals(element.Ancestors().Last(), element.Document.Root).WriteLine(); </span><span style="color: green;">// True.
    </span><span style="color: black;">}
}</span></pre>
<p>Notice AncestorsAndSelf method yields self first, then yields ancestors recursively. It could be more intuitive if named as SelfAndAncestors.</p>
<p>The following example queries direct child elements. In RSS feed, each &lt;item&gt; can have 0, 1, or multiple tags. And these tags are &lt;category&gt; elements under each &lt;item&gt; element. The following code queries a given RSS feed to get the items with a permalink, then queries the top 5 tags used by these items:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ChildElements()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; categories = rss
        .Root </span><span style="color: green;">// &lt;rss&gt;.
        </span><span style="color: black;">.Element(</span><span style="color: #a31515;">"channel"</span><span style="color: black;">) </span><span style="color: green;">// Single &lt;channel&gt; under &lt;rss&gt;.
        </span><span style="color: black;">.Elements(</span><span style="color: #a31515;">"item"</span><span style="color: black;">) </span><span style="color: green;">// All &lt;item&gt;s under single &lt;channel&gt;.
        </span><span style="color: black;">.Where(item =&gt; (</span><span style="color: blue;">bool</span><span style="color: black;">)item
            .Element(</span><span style="color: #a31515;">"guid"</span><span style="color: black;">) </span><span style="color: green;">// Single &lt;guid&gt; under each &lt;item&gt;
            </span><span style="color: black;">.Attribute(</span><span style="color: #a31515;">"isPermaLink"</span><span style="color: black;">)) </span><span style="color: green;">// isPermaLink attribute of &lt;guid&gt;.
        </span><span style="color: black;">.Elements(</span><span style="color: #a31515;">"category"</span><span style="color: black;">) </span><span style="color: green;">// All &lt;category&gt;s under all &lt;item&gt;s.
        </span><span style="color: black;">.GroupBy(
            keySelector: category =&gt; (</span><span style="color: blue;">string</span><span style="color: black;">)category, </span><span style="color: green;">// String value of each &lt;category&gt;.
            </span><span style="color: black;">elementSelector: category =&gt; category,
            resultSelector: (key, group) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Name = key, Count = group.Count() },
            comparer: </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase)
        .OrderByDescending(category =&gt; category.Count)
        .Take(5)
        .Select(category =&gt; </span><span style="color: #a31515;">$"[</span><span style="color: black;">{category.Name}</span><span style="color: #a31515;">]:</span><span style="color: black;">{category.Count}</span><span style="color: #a31515;">"</span><span style="color: black;">);
    </span><span style="color: blue;">string</span><span style="color: black;">.Join(</span><span style="color: #a31515;">" "</span><span style="color: black;">, categories).WriteLine();
    </span><span style="color: green;">// [C#]:9 [LINQ]:6 [.NET]:5 [Functional Programming]:4 [LINQ via C#]:4
</span><span style="color: black;">}</span></pre>
<p>Similar to ancestors, descendants are children, children’s children, …, recursively:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ChildrenAndDescendants()
{
    </span><span style="color: #2b91af;">XElement </span><span style="color: black;">root = </span><span style="color: #2b91af;">XElement</span><span style="color: black;">.Parse(</span><span style="color: maroon;">@"
        &lt;root&gt;
            &lt;![CDATA[cdata]]&gt;0&lt;!--Comment--&gt;
            &lt;element&gt;1&lt;/element&gt;
            &lt;element&gt;2&lt;element&gt;3&lt;/element&gt;&lt;/element&gt;
        &lt;/root&gt;"</span><span style="color: black;">);

    root.Elements()
        .WriteLines(element =&gt; element.ToString(</span><span style="color: #2b91af;">SaveOptions</span><span style="color: black;">.DisableFormatting));
    </span><span style="color: green;">// &lt;element&gt;1&lt;/element&gt;
    // &lt;element&gt;2&lt;element&gt;3&lt;/element&gt;&lt;/element&gt;

    </span><span style="color: black;">root.Nodes()
        .WriteLines(node =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{node.NodeType}</span><span style="color: #a31515;">: </span><span style="color: black;">{node.ToString(</span><span style="color: #2b91af;">SaveOptions</span><span style="color: black;">.DisableFormatting)}</span><span style="color: #a31515;">"</span><span style="color: black;">);
    </span><span style="color: green;">// CDATA: &lt;![CDATA[cdata]]&gt;
    // Text: 0
    // Comment: &lt;!--Comment--&gt;
    // Element: &lt;element&gt;1&lt;/element&gt;
    // Element: &lt;element&gt;2&lt;element&gt;3&lt;/element&gt;&lt;/element&gt;

    </span><span style="color: black;">root.Descendants()
        .WriteLines(element =&gt; element.ToString(</span><span style="color: #2b91af;">SaveOptions</span><span style="color: black;">.DisableFormatting));
    </span><span style="color: green;">// &lt;element&gt;1&lt;/element&gt;
    // &lt;element&gt;2&lt;element&gt;3&lt;/element&gt;&lt;/element&gt;
    // &lt;element&gt;3&lt;/element&gt;

    </span><span style="color: black;">root.DescendantNodes()
        .WriteLines(node =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{node.NodeType}</span><span style="color: #a31515;">: </span><span style="color: black;">{node.ToString(</span><span style="color: #2b91af;">SaveOptions</span><span style="color: black;">.DisableFormatting)}</span><span style="color: #a31515;">"</span><span style="color: black;">);
    </span><span style="color: green;">// CDATA: &lt;![CDATA[cdata]]&gt;
    // Text: 0
    // Comment: &lt;!--Comment--&gt;
    // Element: &lt;element&gt;1&lt;/element&gt;
    // Text: 1
    // Element: &lt;element&gt;2&lt;element&gt;3&lt;/element&gt;&lt;/element&gt;
    // Text: 2
    // Element: &lt;element&gt;3&lt;/element&gt;
    // Text: 3
</span><span style="color: black;">}</span></pre>
<p>Regarding all the X* types are reference types, when querying the same XML tree, multiple queries’ results from the same source tree can reference to the same instance:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ResultReferences()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss1 = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XElement</span><span style="color: black;">[] items1 = rss1.Descendants(</span><span style="color: #a31515;">"item"</span><span style="color: black;">).ToArray();
    </span><span style="color: #2b91af;">XElement</span><span style="color: black;">[] items2 = rss1.Element(</span><span style="color: #a31515;">"rss"</span><span style="color: black;">).Element(</span><span style="color: #a31515;">"channel"</span><span style="color: black;">).Elements(</span><span style="color: #a31515;">"item"</span><span style="color: black;">).ToArray();
    </span><span style="color: blue;">object</span><span style="color: black;">.ReferenceEquals(items1.First(), items2.First()).WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: black;">items1.SequenceEqual(items2).WriteLine(); </span><span style="color: green;">// True

    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss2 = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XElement</span><span style="color: black;">[] items3 = rss2.Root.Descendants(</span><span style="color: #a31515;">"item"</span><span style="color: black;">).ToArray();
    </span><span style="color: blue;">object</span><span style="color: black;">.ReferenceEquals(items1.First(), items3.First()).WriteLine(); </span><span style="color: green;">// False
    </span><span style="color: black;">items1.SequenceEqual(items3).WriteLine(); </span><span style="color: green;">// False
</span><span style="color: black;">}</span></pre>
<p>Again, LINQ to XML is just a specialized LINQ to Objects. For example, the implementation of XNode.Ancestors is equivalent to:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Xml.Linq
{</span><span style="color: black;">
    </span><span style="color: blue;">public abstract class </span><span style="color: #2b91af;">XNode </span><span style="color: black;">: </span><span style="color: #2b91af;">XObject
    </span><span style="color: black;">{
        </span><span style="color: blue;">public </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XElement</span><span style="color: black;">&gt; Ancestors()
        {
            </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: #2b91af;">XElement </span><span style="color: black;">parent = </span><span style="color: blue;">this</span><span style="color: black;">.Parent; parent != </span><span style="color: blue;">null</span><span style="color: black;">; parent = parent.Parent)
            {
                </span><span style="color: blue;">yield return </span><span style="color: black;">parent;
            }
        }

        </span><span style="color: green;">// Other members.
    </span><span style="color: black;">}
}</span></pre>
<p>And the implementation of the Extensions.Ancestors extension method is equivalent to:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Xml.Linq
{</span><span style="color: black;">
    </span><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">Extensions
    </span><span style="color: black;">{
        </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XElement</span><span style="color: black;">&gt; Ancestors&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; source) </span><span style="color: blue;">where </span><span style="color: #2b91af;">T </span><span style="color: black;">: </span><span style="color: #2b91af;">XNode </span><span style="color: black;">=&gt;
            source
                .Where(node =&gt; node != </span><span style="color: blue;">null</span><span style="color: black;">)
                .SelectMany(node =&gt; node.Ancestors())
                .Where(ancestor =&gt; ancestor != </span><span style="color: blue;">null</span><span style="color: black;">);
            </span><span style="color: green;">// Equivalent to:
            // from node in source
            // where node != null
            // from ancestor in node.Ancestors()
            // where ancestor != null
            // select ancestor;

        // Other members.
    </span><span style="color: black;">}
}</span></pre>
<h1>Ordering</h1>
<p>Besides the LINQ to Objects ordering query methods, additional ordering methods are provided by LINQ to XML. The InDocumentOrder query method orders nodes by their positions in the XML tree, from top node down. For example, above Ancestors yields parent, parent’s parent, …, recursively. InDocumentOrder can reorder them from top down. As a result, the query result is reversed:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">DocumentOrder()
{
    </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element1 = </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"element"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element2 = </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"element"</span><span style="color: black;">);
    </span><span style="color: blue;">new </span><span style="color: #2b91af;">XDocument</span><span style="color: black;">(</span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"grandparent"</span><span style="color: black;">, </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"parent"</span><span style="color: black;">, element1, element2)));

    element1.IsBefore(element2).WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: #2b91af;">XNode</span><span style="color: black;">.DocumentOrderComparer.Compare(element1, element2).WriteLine(); </span><span style="color: green;">// -1

    </span><span style="color: #2b91af;">XElement</span><span style="color: black;">[] ancestors = element1.Ancestors().ToArray();
    </span><span style="color: #2b91af;">XNode</span><span style="color: black;">.CompareDocumentOrder(ancestors.First(), ancestors.Last()).WriteLine(); </span><span style="color: green;">// 1
    </span><span style="color: black;">ancestors
        .InDocumentOrder()
        .Select(ancestor =&gt; ancestor.Name)
        .WriteLines(); </span><span style="color: green;">// grandparent parent

    </span><span style="color: black;">element1
        .AncestorsAndSelf()
        .Reverse()
        .SequenceEqual(element1.AncestorsAndSelf().InDocumentOrder())
        .WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<p>Apparently, InDocumentOrder requires the source nodes sequence to be in the same XML tree. This is determined by looking up a common ancestor of the source nodes:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CommonAncestor()
{
    </span><span style="color: #2b91af;">XElement </span><span style="color: black;">root = </span><span style="color: #2b91af;">XElement</span><span style="color: black;">.Parse(</span><span style="color: maroon;">@"
        &lt;root&gt;
            &lt;element value='4' /&gt;
            &lt;element value='2' /&gt;
            &lt;element value='3'&gt;&lt;element value='1' /&gt;&lt;/element&gt;
        &lt;/root&gt;"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XElement</span><span style="color: black;">[] elements = root
        .Descendants(</span><span style="color: #a31515;">"element"</span><span style="color: black;">)
        .OrderBy(element =&gt; (</span><span style="color: blue;">int</span><span style="color: black;">)element.Attribute(</span><span style="color: #a31515;">"value"</span><span style="color: black;">)).ToArray();
    elements.WriteLines(ancestorOrSelf =&gt; ancestorOrSelf.ToString(</span><span style="color: #2b91af;">SaveOptions</span><span style="color: black;">.DisableFormatting));
    </span><span style="color: green;">// &lt;element value="1" /&gt;
    // &lt;element value="2" /&gt;
    // &lt;element value="3"&gt;&lt;element value="1" /&gt;&lt;/element&gt;
    // &lt;element value="4" /&gt;

    </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">[] { elements.First(), elements.Last() }
        .InDocumentOrder()
        .WriteLines(ancestorOrSelf =&gt; ancestorOrSelf.ToString(</span><span style="color: #2b91af;">SaveOptions</span><span style="color: black;">.DisableFormatting));
    </span><span style="color: green;">// &lt;element value="4" /&gt;
    // &lt;element value="1" /&gt;

    </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">[] { elements.First(), elements.Last(), </span><span style="color: blue;">new </span><span style="color: #2b91af;">XElement</span><span style="color: black;">(</span><span style="color: #a31515;">"element"</span><span style="color: black;">) }
        .InDocumentOrder()
        .ForEach();
    </span><span style="color: green;">// InvalidOperationException: A common ancestor is missing.
</span><span style="color: black;">}</span></pre>
<p>Notice in the inline XML string, single quotes are used for attribute values, instead of double quotes. This is for readability of C# code, otherwise "" or \" has to be used. According to the <a href="https://www.w3.org/TR/xml/#NT-AttValue" target="_blank">W3C XML spec</a>, single quote is legal.</p>
<h1>Comparison</h1>
<p>LINQ to Objects provides many query methods accepting IComparer&lt;T&gt; or IEqualityComparer&lt;T&gt;. For these scenarios, LINQ to XML provides 2 built-in comparers:</p>
<ul>
<li>XNodeDocumentOrderComparer, which implements IComparer&lt;XNode&gt;. Its Compare method simply calls XNode.CompareDocumentOrder. Its instance is provided by XNode.DocumentOrderComparer property.</li>
<li>XNodeEqualityComparer, which implements IEqualityComparer&lt;XNode&gt;. Its Equals method simply calls XNode.DeepEquals. Its instance is provided by XNode.EqualityComparer property.</li>
</ul>
<p>For example, above InDocumentOrder query method simply calls OrderBy with XNodeDocumentOrderComparer. Its implementation is equivalent to:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">Extensions
</span><span style="color: black;">{
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; InDocumentOrder&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; source) </span><span style="color: blue;">where </span><span style="color: #2b91af;">T </span><span style="color: black;">: </span><span style="color: #2b91af;">XNode </span><span style="color: black;">=&gt;
        source.OrderBy(node =&gt; node, </span><span style="color: #2b91af;">XNode</span><span style="color: black;">.DocumentOrderComparer);
}</span></pre>
<h1>More useful queries</h1>
<p>With the knowledge of LINQ to Objects and LINQ to XML APIs, more useful query methods can be implemented. For example, the following DescendantObjects method queries an XObject source’s all descendant XObject instances:</p>
<pre class="code"><span style="color: blue;">public static partial class </span><span style="color: #2b91af;">XExtensions
</span><span style="color: black;">{
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XObject</span><span style="color: black;">&gt; DescendantObjects(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XObject </span><span style="color: black;">source) =&gt;
        </span><span style="color: #2b91af;">Enumerable
            </span><span style="color: black;">.Empty&lt;</span><span style="color: #2b91af;">XObject</span><span style="color: black;">&gt;()
            .Concat(
                source </span><span style="color: blue;">is </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element
                    ? element.Attributes() </span><span style="color: green;">// T is covariant in IEnumerable&lt;T&gt;.
                    </span><span style="color: black;">: </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: #2b91af;">XObject</span><span style="color: black;">&gt;())
            .Concat(
                source </span><span style="color: blue;">is </span><span style="color: #2b91af;">XContainer </span><span style="color: black;">container
                    ? container
                        .DescendantNodes()
                        .SelectMany(descendant =&gt; </span><span style="color: #2b91af;">EnumerableEx
                            </span><span style="color: black;">.Return</span><span style="color: black;">(descendant)
                            .Concat(
                                descendant </span><span style="color: blue;">is </span><span style="color: #2b91af;">XElement </span><span style="color: black;">descendantElement
                                    ? descendantElement.Attributes() </span><span style="color: green;">// T is covariant in IEnumerable&lt;T&gt;.
                                    </span><span style="color: black;">: </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: #2b91af;">XObject</span><span style="color: black;">&gt;()))
                    : </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: #2b91af;">XObject</span><span style="color: black;">&gt;());
}</span></pre>
<p>As fore mentioned, XObject can be either node or attribute. So in the query, If the source is element, it yields the element’s attributes; if the source is XContainer, it yields each descendant node; If a descendant node is element, it yields the attributes.</p>
<p>The following SelfAndDescendantObjects method is straightforward to implement:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XObject</span><span style="color: black;">&gt; SelfAndDescendantObjects(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XObject </span><span style="color: black;">source) =&gt;
    </span><span style="color: #2b91af;">EnumerableEx
        </span><span style="color: black;">.Return(source)
        .Concat(source.DescendantObjects());</span></pre>
<p>The Names method queries a XContainer source for all elements’ and attributes’ names:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XName</span><span style="color: black;">&gt; Names(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XContainer </span><span style="color: black;">source) =&gt;
    (source </span><span style="color: blue;">is </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element
        ? element.DescendantsAndSelf()
        : source.Descendants())
            .SelectMany(descendantElement =&gt; </span><span style="color: #2b91af;">EnumerableEx
                </span><span style="color: black;">.Return(descendantElement.Name)
                .Concat(descendantElement
                    .Attributes()
                    .Select(attribute =&gt; attribute.Name)))
        .Distinct();</span></pre>
<p>As fore mentioned, XName instances are cached, so Distinct is called to remove the duplicated references.</p>
<p>Above built-in Attributes method is for querying an element’s attributes. The following AllAttributes queries an XContainer source’s attributes (if it is an element) and all its descendant elements’ attributes:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XAttribute</span><span style="color: black;">&gt; AllAttributes(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XContainer </span><span style="color: black;">source) =&gt;
    (source </span><span style="color: blue;">is </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element
        ? element.DescendantsAndSelf()
        : source.Descendants())
        .SelectMany(elementOrDescendant =&gt; elementOrDescendant.Attributes());</span></pre>
<p>The following Namespaces methods queries all namespaces defined in a XContainer source:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;(</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">XNamespace</span><span style="color: black;">)&gt; Namespaces(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XContainer </span><span style="color: black;">source) =&gt;
    source </span><span style="color: green;">// Namespaces are defined as xmlns:prefix="namespace" attributes.
        </span><span style="color: black;">.AllAttributes()
        .Where(attribute =&gt; attribute.IsNamespaceDeclaration)
        .Select(attribute =&gt; (attribute.Name.LocalName, (</span><span style="color: #2b91af;">XNamespace</span><span style="color: black;">)attribute.Value));</span></pre>
<p>It returns a sequence of (prefix, namespace) tuples. This method can be very useful, regarding .NET does not provide such API. With its help, the following XmlNamespaceManager can be defined for any XContainer source:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">XmlNamespaceManager </span><span style="color: black;">CreateNamespaceManager(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XContainer </span><span style="color: black;">source)
{</span><span style="color: black;">
    </span><span style="color: #2b91af;">XmlNamespaceManager </span><span style="color: black;">namespaceManager = </span><span style="color: blue;">new </span><span style="color: #2b91af;">XmlNamespaceManager</span><span style="color: black;">(</span><span style="color: blue;">new </span><span style="color: #2b91af;">NameTable</span><span style="color: black;">());
    source
        .Namespaces()
        .ForEach(@namespace =&gt; namespaceManager.AddNamespace(@namespace.Item1, @namespace.Item2.ToString()));
    </span><span style="color: blue;">return </span><span style="color: black;">namespaceManager;
}</span></pre>
<p>This method is used later when working with XPath.</p>
<h1>XPath</h1>
<p><a href="https://en.wikipedia.org/wiki/XPath" target="_blank">XPath</a> is a simple query language to select or evaluate objects from an XML tree. It consists of 3 parts:</p>
<ul>
<li>axis, e.g.:</li>
<ul>
<li>/ is to select root node (either a document node, or an element node on the fly)</li>
<li>/rss/channel/item is to select root node, then select root node’s all &lt;rss&gt; direct child elements, then select each &lt;rss&gt; element’s all &lt;channel&gt; child elements, then select each &lt;channel&gt; element’s all &lt;item&gt; child elements</li>
<li><a>/rss/@version</a> is to select root node, then select root node’s all &lt;rss&gt; direct child elements, then select each &lt;rss&gt; element’s version attribute</li>
</ul>
<li>node test</li>
<ul>
<li>text() is to select all text nodes, comment() is to select all comment nodes, etc.</li>
<li>/element/text() is to select root node, then select all &lt;element&gt; child elements, then select each &lt;element&gt; element’s all child text nodes.</li>
</ul>
<li>predicate:</li>
<ul>
<li>[1] means select the first node, etc.</li>
<li>/rss[1]/text()[2] means to select root node, then select the first &lt;rss&gt; child element, then select that &lt;rss&gt; element’s second child text node.</li>
</ul>
</ul>
<p>LINQ to XML also provides a few extension methods to work with XPath. The latest XPath version is 3.0, .NET and LINQ to XML implements XPath 1.0.</p>
<p>The CreateNavigator methods creates a XmlXPathNavigator, which can be used for navigation and querying:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">XPathNavigator()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XPathNavigator </span><span style="color: black;">rssNavigator = rss.CreateNavigator();
    rssNavigator.NodeType.WriteLine(); </span><span style="color: green;">// Root
    </span><span style="color: black;">rssNavigator.MoveToFirstChild().WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: black;">rssNavigator.Name.WriteLine(); </span><span style="color: green;">// rss

    </span><span style="color: black;">((</span><span style="color: #2b91af;">XPathNodeIterator</span><span style="color: black;">)rssNavigator
        .Evaluate(</span><span style="color: #a31515;">"/rss/channel/item[guid/@isPermaLink='true']/category"</span><span style="color: black;">))
        .Cast&lt;</span><span style="color: #2b91af;">XPathNavigator</span><span style="color: black;">&gt;()
        .Select(categoryNavigator =&gt; categoryNavigator.UnderlyingObject)
        .Cast&lt;</span><span style="color: #2b91af;">XElement</span><span style="color: black;">&gt;()
        .GroupBy(
            category =&gt; category.Value, </span><span style="color: green;">// Current text node's value.
            </span><span style="color: black;">category =&gt; category,
            (key, group) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Name = key, Count = group.Count() },
            </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase)
        .OrderByDescending(category =&gt; category.Count)
        .Take(5)
        .Select(category =&gt; </span><span style="color: #a31515;">$"[</span><span style="color: black;">{category.Name}</span><span style="color: #a31515;">]:</span><span style="color: black;">{category.Count}</span><span style="color: #a31515;">"</span><span style="color: black;">)
        .WriteLines();
        </span><span style="color: green;">// [C#]:9 [LINQ]:6 [.NET]:5 [Functional Programming]:4 [LINQ via C#]:4
</span><span style="color: black;">}</span></pre>
<p>It implements the same query as previous RSS tags example.</p>
<p>The XPathSelectElements method is a shortcut of calling CreateNavigator to get an XPathNavigator and then call Evaluate. The above query can be shorten as:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">XPathQuery()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    rss
        .XPathSelectElements(</span><span style="color: #a31515;">"/rss/channel/item[guid/@isPermaLink='true']/category"</span><span style="color: black;">)
        .GroupBy(
            category =&gt; category.Value, </span><span style="color: green;">// Current text node's value.
            </span><span style="color: black;">category =&gt; category,
            (key, group) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Name = key, Count = group.Count() },
            </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase)
        .OrderByDescending(category =&gt; category.Count)
        .Take(5)
        .Select(category =&gt; </span><span style="color: #a31515;">$"[</span><span style="color: black;">{category.Name}</span><span style="color: #a31515;">]:</span><span style="color: black;">{category.Count}</span><span style="color: #a31515;">"</span><span style="color: black;">)
        .WriteLines();
        </span><span style="color: green;">// [C#]:9 [LINQ]:6 [.NET]:5 [Functional Programming]:4 [LINQ via C#]:4
</span><span style="color: black;">}</span></pre>
<p>And XPathSelectElement is simply a shortcut of calling XPathSelectElements to get a sequence, then call FirstOrDefault.</p>
<p>XPathEvaluate also calls CreateNavigator and then Evaluate, but it is more flexible. When the XPath is evaluated to a single value, it just returns that value. The following example queries the RSS feed for the average tags count of each &lt;item&gt; element, and also the equivalent LINQ query:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">XPathEvaluateValue()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    </span><span style="color: blue;">double </span><span style="color: black;">average1 = (</span><span style="color: blue;">double</span><span style="color: black;">)rss.XPathEvaluate(</span><span style="color: #a31515;">"count(/rss/channel/item/category) div count(/rss/channel/item)"</span><span style="color: black;">);
    average1.WriteLine(); </span><span style="color: green;">// 4.65

    </span><span style="color: blue;">double </span><span style="color: black;">average2 = rss
        .Element(</span><span style="color: #a31515;">"rss"</span><span style="color: black;">)
        .Element(</span><span style="color: #a31515;">"channel"</span><span style="color: black;">)
        .Elements(</span><span style="color: #a31515;">"item"</span><span style="color: black;">)
        .Average(item =&gt; item.Elements(</span><span style="color: #a31515;">"category"</span><span style="color: black;">).Count());
    average2.WriteLine(); </span><span style="color: green;">// 4.65
</span><span style="color: black;">}</span></pre>
<p>When the XPath is evaluated to a sequence of values, XPathEvaluate returns IEnumerable&lt;object&gt;:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">XPathEvaluateSequence()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    ((</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt;)rss
        .XPathEvaluate(</span><span style="color: #a31515;">"/rss/channel/item[guid/@isPermaLink='true']/category/text()"</span><span style="color: black;">))
        .Cast&lt;</span><span style="color: #2b91af;">XText</span><span style="color: black;">&gt;()
        .GroupBy(
            categoryTextNode =&gt; categoryTextNode.Value, </span><span style="color: green;">// Current text node's value.
            </span><span style="color: black;">categoryTextNode =&gt; categoryTextNode,
            (key, group) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Name = key, Count = group.Count() },
            </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase)
        .OrderByDescending(category =&gt; category.Count)
        .Take(5)
        .Select(category =&gt; </span><span style="color: #a31515;">$"[</span><span style="color: black;">{category.Name}</span><span style="color: #a31515;">]:</span><span style="color: black;">{category.Count}</span><span style="color: #a31515;">"</span><span style="color: black;">)
        .WriteLines();
        </span><span style="color: green;">// [C#]:9 [LINQ]:6 [.NET]:5 [Functional Programming]:4 [LINQ via C#]:4
</span><span style="color: black;">}</span></pre>
<p>LINQ to XML also provides overloads for these XPath methods to accept an IXmlNamespaceResolver parameter. When the XPath expression involves namespace, an IXmlNamespaceResolver instance must be provided. Taking another RSS feed from Flickr as an example:</p>
<pre class="code"><span style="color: blue;">&lt;?</span><span style="color: #a31515;">xml </span><span style="color: red;">version</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">1.0</span><span style="color: black;">" </span><span style="color: red;">encoding</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">utf-8</span><span style="color: black;">"</span><span style="color: blue;">?&gt;
&lt;</span><span style="color: #a31515;">rss </span><span style="color: red;">version</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">2.0</span><span style="color: black;">" </span><span style="color: red;">xmlns:media</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">http://search.yahoo.com/mrss/</span><span style="color: black;">" </span><span style="color: red;">xmlns:dc</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">http://purl.org/dc/elements/1.1/</span><span style="color: black;">" </span><span style="color: red;">xmlns:flickr</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">urn:flickr:user</span><span style="color: black;">"</span><span style="color: blue;">&gt;
  &lt;</span><span style="color: #a31515;">channel</span><span style="color: blue;">&gt;
    &lt;</span><span style="color: #a31515;">item</span><span style="color: blue;">&gt;
      &lt;</span><span style="color: #a31515;">title</span><span style="color: blue;">&gt;</span><span style="color: black;">Microsoft Way, Microsoft Campus</span><span style="color: blue;">&lt;/</span><span style="color: #a31515;">title</span><span style="color: blue;">&gt;
      &lt;</span><span style="color: #a31515;">dc:date.Taken</span><span style="color: blue;">&gt;</span><span style="color: black;">2011-11-02T16:45:54-08:00</span><span style="color: blue;">&lt;/</span><span style="color: #a31515;">dc:date.Taken</span><span style="color: blue;">&gt;
      &lt;</span><span style="color: #a31515;">author </span><span style="color: red;">flickr:profile</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">https://www.flickr.com/people/dixin/</span><span style="color: black;">"</span><span style="color: blue;">&gt;</span><span style="color: black;">nobody@flickr.com (Dixin Yan)</span><span style="color: blue;">&lt;/</span><span style="color: #a31515;">author</span><span style="color: blue;">&gt;
      &lt;</span><span style="color: #a31515;">media:content </span><span style="color: red;">url</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">https://farm3.staticflickr.com/2875/9215169916_f8fa57c3da_b.jpg</span><span style="color: black;">" </span><span style="color: red;">type</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">image/jpeg</span><span style="color: black;">" </span><span style="color: red;">height</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">681</span><span style="color: black;">" </span><span style="color: red;">width</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">1024</span><span style="color: black;">"</span><span style="color: blue;">/&gt;
      &lt;</span><span style="color: #a31515;">media:title</span><span style="color: blue;">&gt;</span><span style="color: black;">Microsoft Way, Microsoft Campus</span><span style="color: blue;">&lt;/</span><span style="color: #a31515;">media:title</span><span style="color: blue;">&gt;
      &lt;</span><span style="color: #a31515;">media:description </span><span style="color: red;">type</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">html</span><span style="color: black;">"</span><span style="color: blue;">&gt;
        &lt;</span><span style="color: #a31515;">p</span><span style="color: blue;">&gt;</span><span style="color: black;">Microsoft Campus is the informal name of Microsoft's corporate headquarters, located at One Microsoft Way in Redmond, Washington. Microsoft initially moved onto the grounds of the campus on February 26, 1986. </span><span style="color: blue;">&lt;</span><span style="color: #a31515;">a </span><span style="color: red;">href</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">http://en.wikipedia.org/wiki/Microsoft_Redmond_Campus</span><span style="color: black;">" </span><span style="color: red;">rel</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">nofollow</span><span style="color: black;">"</span><span style="color: blue;">&gt;</span><span style="color: black;">en.wikipedia.org/wiki/Microsoft_Redmond_Campus</span><span style="color: blue;">&lt;/</span><span style="color: #a31515;">a</span><span style="color: blue;">&gt;&lt;/</span><span style="color: #a31515;">p</span><span style="color: blue;">&gt;
      &lt;/</span><span style="color: #a31515;">media:description</span><span style="color: blue;">&gt;
      &lt;</span><span style="color: #a31515;">media:thumbnail </span><span style="color: red;">url</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">https://farm3.staticflickr.com/2875/9215169916_f8fa57c3da_s.jpg</span><span style="color: black;">" </span><span style="color: red;">height</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">75</span><span style="color: black;">" </span><span style="color: red;">width</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">75</span><span style="color: black;">"</span><span style="color: blue;">/&gt;
      &lt;</span><span style="color: #a31515;">media:credit </span><span style="color: red;">role</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">photographer</span><span style="color: black;">"</span><span style="color: blue;">&gt;</span><span style="color: black;">Dixin Yan</span><span style="color: blue;">&lt;/</span><span style="color: #a31515;">media:credit</span><span style="color: blue;">&gt;
      &lt;</span><span style="color: #a31515;">media:category </span><span style="color: red;">scheme</span><span style="color: blue;">=</span><span style="color: black;">"</span><span style="color: blue;">urn:flickr:tags</span><span style="color: black;">"</span><span style="color: blue;">&gt;</span><span style="color: black;">microsoft</span><span style="color: blue;">&lt;/</span><span style="color: #a31515;">media:category</span><span style="color: blue;">&gt;
      &lt;!-- </span><span style="color: green;">Other elements. </span><span style="color: blue;">--&gt;
    &lt;/</span><span style="color: #a31515;">item</span><span style="color: blue;">&gt;
    &lt;!-- </span><span style="color: green;">Other items. </span><span style="color: blue;">--&gt;
  &lt;/</span><span style="color: #a31515;">channel</span><span style="color: blue;">&gt;
&lt;/</span><span style="color: #a31515;">rss</span><span style="color: blue;">&gt;</span></pre>
<p>It contains additional information than the standard RSS format, and these additional elements/attributes are managed by namespaces. The following example calls the overload of XPathSelectElements to query the &lt;media:category&gt; elements:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">XPathQueryWithNamespace()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://www.flickr.com/services/feeds/photos_public.gne?id=64715861@N07&amp;format=rss2"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XmlNamespaceManager </span><span style="color: black;">namespaceManager = rss.CreateNamespaceManager();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XElement</span><span style="color: black;">&gt; query1 = rss.XPathSelectElements(</span><span style="color: #a31515;">"/rss/channel/item/media:category"</span><span style="color: black;">, namespaceManager);
    query1.Count().WriteLine(); </span><span style="color: green;">// 20

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">XElement</span><span style="color: black;">&gt; query2 = rss.XPathSelectElements(</span><span style="color: #a31515;">"/rss/channel/item/media:category"</span><span style="color: black;">);
    </span><span style="color: green;">// XPathException: Namespace Manager or XsltContext needed. This query has a prefix, variable, or user-defined function.
</span><span style="color: black;">}</span></pre>
<p>Since prefix “media” is in XPath expression, An IXmlNamespaceResolver instance is required. XmlNamespaceManager implements IXmlNamespaceResolver, so simply call the the previously defined CreateNamespaceManager method to create it. In contrast, querying the same XPath expression without IXmlNamespaceResolver instance throws XPathException.</p>
<p>The last example calls the overload of XPathEvaluate to query the items’ titles, which has the tag “microsoft” in the &lt;media:category&gt; element:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">XPathEvaluateSequenceWithNamespace()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">rss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://www.flickr.com/services/feeds/photos_public.gne?id=64715861@N07&amp;format=rss2"</span><span style="color: black;">);
    ((</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt;)rss
        .XPathEvaluate(
            </span><span style="color: #a31515;">"/rss/channel/item[contains(media:category/text(), 'microsoft')]/media:title/text()"</span><span style="color: black;">,
            rss.CreateNamespaceManager()))
        .Cast&lt;</span><span style="color: #2b91af;">XText</span><span style="color: black;">&gt;()
        .WriteLines(mediaTitle =&gt; mediaTitle.Value);
        </span><span style="color: green;">// Chinese President visits Microsoft
        // Satya Nadella, CEO of Microsoft
</span><span style="color: black;">}</span></pre>
<h1>Generate XPath expression</h1>
<p>To leverage LINQ to XML, one example is to generate XPath expression for a specified XObject instance, which can be either XAttribute or XNode. The XPath expression can be calculated with the following 3 segments are needed:</p>
<ol>
<li>the XPath of current object’s parent Element, which can be either calculated recursively, or be provided by caller.</li>
<li>the XPath of current object, which can be</li>
<ul>
<li>@attributeName if it is an attribute</li>
<li>elementName if it is an element</li>
<li>node test like text(), comment(), etc., if it is any other type of node.</li>
</ul>
<li>a predicate for current object, which can simply be the position:</li>
<ul>
<li>For example, [2] can be used to identify a comment node, if there is another sibling comment node before itself</li>
<li>also, the position predicate can be omitted if current object has no ambiguous sibling objects, so that XPath of parent object combining XPath of current object selects one single object. For example, if current node is a comment node with no sibling comment node, then parentElement/comment() without position predicate is good enough</li>
</ul>
</ol>
<p>First of all, a helper method is needed to calculate the current element or attribute’s name, which should be in simple localName format if the XName instance is not under any namespace, and should be in prefix:localName format if the XName instance is under a namespace. XName.ToString does not work for this requirement, because it returns the {namespaceUri}localName format, as already demonstrated. So the following XPath method can be defined for name:</p>
<pre class="code"><span style="color: blue;">public static string </span><span style="color: black;">XPath(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XName </span><span style="color: black;">source, </span><span style="color: #2b91af;">XElement </span><span style="color: black;">container)
{</span><span style="color: black;">
    </span><span style="color: blue;">string </span><span style="color: black;">prefix = source.Namespace == </span><span style="color: #2b91af;">XNamespace</span><span style="color: black;">.None
        ? </span><span style="color: blue;">null
        </span><span style="color: black;">: container.GetPrefixOfNamespace(source.Namespace); </span><span style="color: green;">// GetPrefixOfNamespace returns null if not found.
    </span><span style="color: blue;">return string</span><span style="color: black;">.IsNullOrEmpty(prefix) ? source.ToString() : </span><span style="color: #a31515;">$"</span><span style="color: black;">{prefix}</span><span style="color: #a31515;">:</span><span style="color: black;">{source.LocalName}</span><span style="color: #a31515;">"</span><span style="color: black;">;
}</span></pre>
<p>Regarding the above segment 1 and segment 2 has to be combined, another helper method is needed to combine 2 XPath expressions, which is similar to .NET built-in Combine method provided by System.IO.Path:</p>
<pre class="code"><span style="color: blue;">private static string </span><span style="color: black;">CombineXPath(</span><span style="color: blue;">string </span><span style="color: black;">xPath1, </span><span style="color: blue;">string </span><span style="color: black;">xPath2, </span><span style="color: blue;">string </span><span style="color: black;">predicate = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
    </span><span style="color: blue;">string</span><span style="color: black;">.Equals(xPath1, </span><span style="color: #a31515;">"/"</span><span style="color: black;">, </span><span style="color: #2b91af;">StringComparison</span><span style="color: black;">.Ordinal) || </span><span style="color: blue;">string</span><span style="color: black;">.IsNullOrEmpty(xPath2)
    ? </span><span style="color: #a31515;">$"</span><span style="color: black;">{xPath1}{xPath2}{predicate}</span><span style="color: #a31515;">"
    </span><span style="color: black;">: </span><span style="color: #a31515;">$"</span><span style="color: black;">{xPath1}</span><span style="color: #a31515;">/</span><span style="color: black;">{xPath2}{predicate}</span><span style="color: #a31515;">"</span><span style="color: black;">;</span></pre>
<p>Regarding XObject can be either one type of attribute, or several types of nodes, apparently attribute does not need the position predicate, while the different types of nodes all share similar logic to identify the position and the ambiguous siblings. So the following helper method can be defined for XNode:</p>
<pre class="code"><span style="color: blue;">private static string </span><span style="color: black;">XPath&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">TSource </span><span style="color: black;">source,
    </span><span style="color: blue;">string </span><span style="color: black;">parentXPath,
    </span><span style="color: blue;">string </span><span style="color: black;">selfXPath = </span><span style="color: blue;">null</span><span style="color: black;">,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; siblingPredicate = </span><span style="color: blue;">null</span><span style="color: black;">) </span><span style="color: blue;">where </span><span style="color: #2b91af;">TSource </span><span style="color: black;">: </span><span style="color: #2b91af;">XNode
</span><span style="color: black;">{
    </span><span style="color: blue;">int </span><span style="color: black;">index = source
        .NodesBeforeSelf()
        .Cast&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;()
        .Where(siblingPredicate ?? (_ =&gt; </span><span style="color: blue;">true</span><span style="color: black;">))
        .Count();
    </span><span style="color: blue;">string </span><span style="color: black;">predicate = index == 0
        &amp;&amp; !source
            .NodesAfterSelf()
            .Cast&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;()
            .Where(siblingPredicate ?? (_ =&gt; </span><span style="color: blue;">true</span><span style="color: black;">))
            .Any()
        ? </span><span style="color: blue;">null
        </span><span style="color: black;">: </span><span style="color: #a31515;">$"[</span><span style="color: black;">{index + 1}</span><span style="color: #a31515;">]"</span><span style="color: black;">;
    </span><span style="color: blue;">return </span><span style="color: black;">CombineXPath(parentXPath, selfXPath, predicate);
}</span></pre>
<p>Now, the following XPath method can be defined to generate XPath expression for an element:</p>
<pre class="code"><span style="color: blue;">public static string </span><span style="color: black;">XPath(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XElement </span><span style="color: black;">source, </span><span style="color: blue;">string </span><span style="color: black;">parentXPath = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
    </span><span style="color: blue;">string</span><span style="color: black;">.IsNullOrEmpty(parentXPath) &amp;&amp; source.Parent == </span><span style="color: blue;">null </span><span style="color: black;">&amp;&amp; source.Document == </span><span style="color: blue;">null
        </span><span style="color: black;">? </span><span style="color: #a31515;">"/" </span><span style="color: green;">// source is an element on the fly, not attached to any parent node.
        </span><span style="color: black;">: source.XPath(
            parentXPath ?? source.Parent?.XPath(),
            source.Name.XPath(source),
            sibling =&gt; sibling.Name == source.Name);</span></pre>
<p>In this method, there is a special case for element. As fore mentioned, an element can be constructed on the fly, and it is the root node of its XML tree. In this case, just returns XPath root expression /. For other cases, just call above XPath helper method for XNode, with:</p>
<ul>
<li>XPath of parent element, if not provided then calculate recursively</li>
<li>XPath of element name, which can be generated by calling above XPath helper method for XName</li>
<li>A lambda expression to identify ambiguous sibling elements with the same element name, so that the proper XPath predicate can be generated</li>
</ul>
<p>The XPath overloads for comment/text/processing instruction nodes are straightforward:</p>
<pre class="code"><span style="color: blue;">public static string </span><span style="color: black;">XPath(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XComment </span><span style="color: black;">source, </span><span style="color: blue;">string </span><span style="color: black;">parentXPath = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
    source.XPath(parentXPath ?? source.Parent?.XPath(), </span><span style="color: #a31515;">"comment()"</span><span style="color: black;">);

</span><span style="color: blue;">public static string </span><span style="color: black;">XPath(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XText </span><span style="color: black;">source, </span><span style="color: blue;">string </span><span style="color: black;">parentXPath = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
    source.XPath(parentXPath ?? source.Parent?.XPath(), </span><span style="color: #a31515;">"text()"</span><span style="color: black;">);

</span><span style="color: blue;">public static string </span><span style="color: black;">XPath(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XProcessingInstruction </span><span style="color: black;">source, </span><span style="color: blue;">string </span><span style="color: black;">parentXPath = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
    source.XPath(
        parentXPath ?? source.Parent?.XPath(),
        </span><span style="color: #a31515;">$"processing-instruction('</span><span style="color: black;">{source.Target}</span><span style="color: #a31515;">')"</span><span style="color: black;">,
        sibling =&gt; </span><span style="color: blue;">string</span><span style="color: black;">.Equals(sibling.Target, source.Target, </span><span style="color: #2b91af;">StringComparison</span><span style="color: black;">.Ordinal));</span></pre>
<p>And the XPath overload for attribute just combine parent element’s XPath with the format of @attributeName:</p>
<pre class="code"><span style="color: blue;">public static string </span><span style="color: black;">XPath(</span><span style="color: blue;">this </span><span style="color: #2b91af;">XAttribute </span><span style="color: black;">source, </span><span style="color: blue;">string </span><span style="color: black;">parentXPath = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
    CombineXPath(parentXPath ?? source.Parent?.XPath(), </span><span style="color: #a31515;">$"@</span><span style="color: black;">{source.Name.XPath(source.Parent)}</span><span style="color: #a31515;">"</span><span style="color: black;">);</span></pre>
<p>Here are some examples of using these methods:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GenerateXPath()
{
    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">aspNetRss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://weblogs.asp.net/dixin/rss"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element1 = aspNetRss
        .Root
        .Element(</span><span style="color: #a31515;">"channel"</span><span style="color: black;">)
        .Elements(</span><span style="color: #a31515;">"item"</span><span style="color: black;">)
        .Last();
    element1.XPath().WriteLine(); </span><span style="color: green;">// /rss/channel/item[20]
    </span><span style="color: #2b91af;">XElement </span><span style="color: black;">element2 = aspNetRss.XPathSelectElement(element1.XPath());
    </span><span style="color: blue;">object</span><span style="color: black;">.ReferenceEquals(element1, element2).WriteLine(); </span><span style="color: green;">// True

    </span><span style="color: #2b91af;">XDocument </span><span style="color: black;">flickrRss = <span style="color: black;"></span><span style="color: #2b91af;">XDocument</span><span style="color: black;">.Load</span>(</span><span style="color: #a31515;">"https://www.flickr.com/services/feeds/photos_public.gne?id=64715861@N07&amp;format=rss2"</span><span style="color: black;">);
    </span><span style="color: #2b91af;">XAttribute </span><span style="color: black;">attribute1 = flickrRss
        .Root
        .Descendants(</span><span style="color: #a31515;">"author"</span><span style="color: black;">) </span><span style="color: green;">// &lt;author flickr:profile="https://www.flickr.com/people/dixin/"&gt;...&lt;/author&gt;.
        </span><span style="color: black;">.First()
        .Attribute(</span><span style="color: #2b91af;">XName</span><span style="color: black;">.Get(</span><span style="color: #a31515;">"profile"</span><span style="color: black;">, </span><span style="color: #a31515;">"urn:flickr:user"</span><span style="color: black;">)); </span><span style="color: green;">// &lt;rss xmlns:flickr="urn:flickr:user"&gt;...&lt;/rss&gt;.
    </span><span style="color: black;">attribute1.XPath().WriteLine(); </span><span style="color: green;">// /rss/channel/item[1]/author/@flickr:profile
    </span><span style="color: #2b91af;">XAttribute </span><span style="color: black;">attribute2 = ((</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt;)flickrRss
        .XPathEvaluate(attribute1.XPath(), flickrRss.CreateNamespaceManager()))
        .Cast&lt;</span><span style="color: #2b91af;">XAttribute</span><span style="color: black;">&gt;()
        .Single();
    </span><span style="color: blue;">object</span><span style="color: black;">.ReferenceEquals(attribute1, attribute2).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>


</div>
</body>
</html>
