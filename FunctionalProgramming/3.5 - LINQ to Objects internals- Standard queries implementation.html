<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<div class="mainDiv">



<h1>LINQ to Objects (5) Query Methods Implementation</h1>

<p>Understanding of internals of query methods is very helpful for using them accurately and effectively, and is also helpful for defining custom query methods, which is discussed later in this chapter. Just like the usage discussion part, here query methods are still categorized by returned type, but in a different order:</p>
<ol>
<li>Collection queries: return a new collection (immediate execution):
<ul>
<li>Conversion: ToArray, ToList, ToDictionary, ToLookup</li>
</ul>
</li>
<li>Sequence queries: return a new IEnumerable&lt;T&gt; sequence (deferred execution, underlined are eager evaluation):
<ul>
<li>Conversion: Cast, AsEnumerable</li>
<li>Generation: Empty , Range, Repeat, DefaultIfEmpty</li>
<li>Filtering (restriction): Where, OfType</li>
<li>Mapping (projection): Select, SelectMany</li>
<li>Grouping: GroupBy*</li>
<li>Join: SelectMany, Join*, GroupJoin*</li>
<li>Concatenation: Concat</li>
<li>Set: Distinct, Union, Intersect*, Except*</li>
<li>Convolution: Zip</li>
<li>Partitioning: Take, Skip, TakeWhile, SkipWhile</li>
<li>Ordering: OrderBy*, ThenBy*, OrderByDescending*, ThenByDescending*, Reverse*</li>
</ul>
</li>
<li>Value queries: return a single value (immediate execution):
<ul>
<li>Element: First, FirstOrDefault, Last, LastOrDefault, ElementAt, ElementAtOrDefault, Single, SingleOrDefault</li>
<li>Aggregation: Aggregate, Count, LongCount, Min, Max, Sum, Average</li>
<li>Quantifier: All, Any, Contains</li>
<li>Equality: SequenceEqual</li>
</ul>
</li>
</ol>
<p>The collection conversion queries are discussed first, because they can be used to implement other queries. All query methods work functionally, while many of them have imperative implementation. For the sequential query methods returning IEnumerable&lt;T&gt;, generators are heavily used to enable deferred execution, where the sequence queries marked with * implements eager evaluation, and the other sequence queries implements lazy evaluation. In some cases .NET uses the yield syntactic sugar to create generator, and in other cases .NET defines custom generators to improve the performance. In this tutorial, to make it intuitive and readable, all those query methods are implemented with yield.</p>
<h1>Argument check and deferred execution</h1>
<p>As fore mentioned, all sequence queries returning IEnumerable&lt;T&gt; implement deferred execution. When a generator function contains the yield syntactic sugar, the execution of all code in the function body is deferred, including argument check. For example, argument check can be added to Select query as the following:</p>
<pre class="code"><span style="color: blue;">internal static partial class </span><span style="color: #2b91af;">DeferredExecution
</span><span style="color: black;">{
    <span style="color: blue;">internal </span></span><span style="color: blue;">static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; DeferredSelect&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(source == </span><span style="color: blue;">null</span><span style="color: black;">)<span style="color: black;"> </span><span style="color: green;">// Deferred execution.</span>
        {
            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentNullException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(source));
        }
        </span><span style="color: blue;">if </span><span style="color: black;">(selector == </span><span style="color: blue;">null</span><span style="color: black;">)<span style="color: black;"> </span><span style="color: green;">// Deferred execution.</span>
        {
            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentNullException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(selector));
        }

        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">selector(value);<span style="color: black;"> </span><span style="color: green;">// Deferred execution.</span>
        }
    }
}</span></pre>
<p>When the method is called, the arguments are expected to be checked immediately. However the check is deferred. Its compilation is equivalent to the following generator creation:</p>
<pre class="code"><span style="color: blue;"><span style="color: blue;">internal </span>static partial class </span><span style="color: #2b91af;">DeferredExecution
</span><span style="color: black;">{
    <span style="color: blue;">internal </span></span><span style="color: blue;">static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; CompiledDeferredSelect&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
        </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector) =&gt;
            </span><span style="color: blue;">new </span><span style="color: #2b91af;">Generator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;&gt;(</span><span style="color: green;">
                </span><span style="color: black;">iteratorFactory: sourceIterator =&gt; </span><span style="color: blue;">new </span><span style="color: #2b91af;">Iterator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
                    start: () =&gt;
                    {
                        </span><span style="color: blue;">if </span><span style="color: black;">(source == </span><span style="color: blue;">null</span><span style="color: black;">)
                        {
                            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentNullException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(source));
                        }
                        </span><span style="color: blue;">if </span><span style="color: black;">(selector == </span><span style="color: blue;">null</span><span style="color: black;">)
                        {
                            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentNullException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(selector));
                        }
                        sourceIterator = source.GetEnumerator();
                    },
                    moveNext: () =&gt; sourceIterator.MoveNext(),
                    getCurrent: () =&gt; selector(sourceIterator.Current),
                    dispose: () =&gt; sourceIterator?.Dispose()));</span></pre>
<p>The argument check is deferred to execute when pulling the values from the returns sequence for the first time. The easiest solution is to simply isolate yield statement and deferred execution to another method:</p>
<pre class="code"><span style="color: blue;"><span style="color: blue;">internal </span>static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Select&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(source == </span><span style="color: blue;">null</span><span style="color: black;">)<span style="color: black;"> </span><span style="color: green;">// Immediate execution.</span>
    {
        </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentNullException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(source));
    }
    </span><span style="color: blue;">if </span><span style="color: black;">(selector == </span><span style="color: blue;">null</span><span style="color: black;">)<span style="color: black;"> </span><span style="color: green;">// Immediate execution.</span>
    {
        </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentNullException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(selector));
    }

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectGenerator()
    {
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">selector(value);<span style="color: black;"> </span><span style="color: green;">// Deferred execution.</span>
        }
    }
    </span><span style="color: blue;">return </span><span style="color: black;">SelectGenerator();
}</span></pre>
<p>As a result, the above outer function is no longer a generator function. When it is called, it immediately checks the arguments, then immediately calls the local function to create a generator and return. In this tutorial, argument null check is omitted for readability.</p>
<h1>Collection queries</h1>
<h2>Conversion</h2>
<p>ToArray is implemented by pulling all values from source sequence and store them to a new array. To create an array, its length has to be provided. However, the count of values in source is unknown when starting to pull the values. The easiest way is to create an empty array, when each value is pulled from source sequence, resize the array to store that value:</p>
<pre class="code"><span style="color: blue;"><span style="color: blue;">internal </span>static partial class </span><span style="color: #2b91af;">EnumerableExtensions
</span><span style="color: black;">{
    </span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] ToArray&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
    {
        </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] array = </span><span style="color: blue;">new </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[0];
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: #2b91af;">Array</span><span style="color: black;">.Resize(</span><span style="color: blue;">ref </span><span style="color: black;">array, array.Length + 1);
            array[array.Length - 1] = value;
        }
        </span><span style="color: blue;">return </span><span style="color: black;">array;
    }
}</span></pre>
<p>This implementation can be optimized. First, if the source sequence implements ICollection&lt;T&gt;, then it already has a CopyTo method to store its values to an array:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Collections.Generic
{
    </span><span style="color: blue;">public interface </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">IEnumerable
    </span><span style="color: black;">{
        </span><span style="color: blue;">int </span><span style="color: black;">Count { </span><span style="color: blue;">get</span><span style="color: black;">; }

        </span><span style="color: blue;">bool </span><span style="color: black;">IsReadOnly { </span><span style="color: blue;">get</span><span style="color: black;">; }

        </span><span style="color: blue;">void </span><span style="color: black;">Add(</span><span style="color: #2b91af;">T </span><span style="color: black;">item);

        </span><span style="color: blue;">void </span><span style="color: black;">Clear();

        </span><span style="color: blue;">bool </span><span style="color: black;">Contains(</span><span style="color: #2b91af;">T </span><span style="color: black;">item);

        </span><span style="color: blue;">void </span><span style="color: black;">CopyTo(</span><span style="color: #2b91af;">T</span><span style="color: black;">[] array, </span><span style="color: blue;">int </span><span style="color: black;">arrayIndex);

        </span><span style="color: blue;">bool </span><span style="color: black;">Remove(</span><span style="color: #2b91af;">T </span><span style="color: black;">item);
    }
}</span></pre>
<p>Also, the array resizing for each value can be avoided. One option is, a initial length can be used to create the array; when pulling values from source and storing to array, if array gets full, then double its length; After all values are pulled, the array needs to be consolidated to the actual length. The following is a optimized implementation of ToArray:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] ToArray&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; genericCollection)
    {
        </span><span style="color: blue;">int </span><span style="color: black;">length = genericCollection.Count;
        </span><span style="color: blue;">if </span><span style="color: black;">(length &gt; 0)
        {
            </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] array = </span><span style="color: blue;">new </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[length];
            genericCollection.CopyTo(array, 0);
            </span><span style="color: blue;">return </span><span style="color: black;">array;
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(iterator.MoveNext())
            {
                </span><span style="color: blue;">const int </span><span style="color: black;">InitialLength = 4; </span><span style="color: green;">// Initial array length.
                </span><span style="color: blue;">const int </span><span style="color: black;">MaxLength = 0x7FEFFFFF; </span><span style="color: green;">// Max array length: Array.MaxArrayLength.
                </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] array = </span><span style="color: blue;">new </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[InitialLength];
                array[0] = iterator.Current;
                </span><span style="color: blue;">int </span><span style="color: black;">usedLength = 1;

                </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
                {
                    </span><span style="color: blue;">if </span><span style="color: black;">(usedLength == array.Length)
                    {
                        </span><span style="color: blue;">int </span><span style="color: black;">increaseToLength = usedLength * 2; </span><span style="color: green;">// Array is full, double its length.
                        </span><span style="color: blue;">if </span><span style="color: black;">((</span><span style="color: blue;">uint</span><span style="color: black;">)increaseToLength &gt; MaxLength)
                        {
                            increaseToLength = MaxLength &lt;= usedLength ? usedLength + 1 : MaxLength;
                        }
                        </span><span style="color: #2b91af;">Array</span><span style="color: black;">.Resize(</span><span style="color: blue;">ref </span><span style="color: black;">array, increaseToLength);
                    }
                    array[usedLength++] = iterator.Current;
                }
                </span><span style="color: #2b91af;">Array</span><span style="color: black;">.Resize(</span><span style="color: blue;">ref </span><span style="color: black;">array, usedLength); </span><span style="color: green;">// Consolidate array to its actual length.
                </span><span style="color: blue;">return </span><span style="color: black;">array;
            }
        }
    }
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">Array</span><span style="color: black;">.Empty&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;();
}</span></pre>
<p>ToList is much easier to implement, because List&lt;T&gt; has a constructor accepting an IEnumerable&lt;T&gt; source:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToList&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt; </span><span style="color: blue;">new </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(source);</span></pre>
<p>ToDictionary is also easy, because Dictionary&lt;TKey, TValue&gt; has an Add method:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToDictionary&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        source.ToDictionary(keySelector, value =&gt; value, comparer);

</span><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; ToDictionary&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{

    </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; dictionary = </span><span style="color: blue;">new </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(comparer);
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        dictionary.Add(keySelector(value), elementSelector(value));
    }
    </span><span style="color: blue;">return </span><span style="color: black;">dictionary;
}</span></pre>
<p>As previously discussed, a lookup is a dictionary of key and sequence pairs, and each key and sequence pair is just a group represented by IGrouping&lt;TKey, TElement&gt;, which can be implemented as:</p>
<pre class="code"><span style="color: blue;">public class </span><span style="color: #2b91af;">Grouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;
{
    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; values = </span><span style="color: blue;">new </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;();

    <span style="color: blue;">public </span></span><span style="color: blue;"></span><span style="color: black;">Grouping(</span><span style="color: #2b91af;">TKey </span><span style="color: black;">key) =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.Key = key;

    </span><span style="color: blue;">public </span><span style="color: #2b91af;">TKey </span><span style="color: black;">Key { </span><span style="color: blue;">get</span><span style="color: black;">; }

    </span><span style="color: blue;">public </span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; GetEnumerator() =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.values.GetEnumerator();

    </span><span style="color: #2b91af;">IEnumerator IEnumerable</span><span style="color: black;">.GetEnumerator() =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.GetEnumerator();

    </span><span style="color: blue;">internal void </span><span style="color: black;">Add(</span><span style="color: #2b91af;">TElement </span><span style="color: black;">value) =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.values.Add(value);
}</span></pre>
<p>.NET provides a public lookup type, but there is no public API to instantiate it, except the ToLookup query method itself. For demonstration purpose, with the previous discussion of dictionary and lookup, a custom lookup can be quickly implemented with dictionary, where each dictionary value is a group, and each dictionary key is the has code of group key:</p>
<pre class="code"><span style="color: blue;">public partial class </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;
{
    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">Grouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;&gt; groups =
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">Grouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;&gt;();

    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; equalityComparer;

    <span style="color: blue;">public </span></span><span style="color: blue;"></span><span style="color: black;">Lookup(</span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; equalityComparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        </span><span style="color: blue;">this</span><span style="color: black;">.equalityComparer = equalityComparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;.Default;

    </span><span style="color: blue;">private int </span><span style="color: black;">GetHashCode(</span><span style="color: #2b91af;">TKey </span><span style="color: black;">key) =&gt; key == </span><span style="color: blue;">null
        </span><span style="color: black;">? -1
        : </span><span style="color: blue;">this</span><span style="color: black;">.equalityComparer.GetHashCode(key) &amp; </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue;
        </span><span style="color: green;">// int.MaxValue is 0b01111111_11111111_11111111_11111111. So the hash code of non-null key is always &gt; -1.

    </span><span style="color: blue;">public </span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;&gt; GetEnumerator() =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.groups.Values.GetEnumerator();

    </span><span style="color: #2b91af;">IEnumerator IEnumerable</span><span style="color: black;">.GetEnumerator() =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.GetEnumerator();

    </span><span style="color: blue;">public bool </span><span style="color: black;">Contains(</span><span style="color: #2b91af;">TKey </span><span style="color: black;">key) =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.groups.ContainsKey(</span><span style="color: blue;">this</span><span style="color: black;">.GetHashCode(key));

    </span><span style="color: blue;">public int </span><span style="color: black;">Count =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.groups.Count;

    </span><span style="color: blue;">public </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; </span><span style="color: blue;">this</span><span style="color: black;">[</span><span style="color: #2b91af;">TKey </span><span style="color: black;">key] =&gt;
        </span><span style="color: blue;">this</span><span style="color: black;">.groups.TryGetValue(</span><span style="color: blue;">this</span><span style="color: black;">.GetHashCode(key), </span><span style="color: blue;">out </span><span style="color: #2b91af;">Grouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; group)
            ? (</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;)group
            : </span><span style="color: #2b91af;">Array</span><span style="color: black;">.Empty&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;();
}</span></pre>
<p>The built-in API object.GetHashCode is not directly used to get each value’s hash code, because it does not handle null value very well in some cases. System.Nullable&lt;T&gt;.GetHashCode is such an example. ((int?)0).GetHashCode() and ((int?)null).GetHashCode() both return 0. So the above GetHashCode method reserves -1 for null. And any non-null value’s hash code is converted to a positive int by a <a href="https://msdn.microsoft.com/en-us/library/sbf85k1c.aspx" target="_blank">bitwise and operation</a> with int.MaxValue. The above indexer getter return an empty sequence when the specified key does not exist. Similar to Grouping&lt;TKey, TElement&gt;.Add, the following Lookup&lt;TKey, TElement&gt;.AddRange is defined to add data:</p>
<pre class="code"><span style="color: blue;">public partial class </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;</span><span style="color: black;">
{
    </span><span style="color: blue;">public </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; AddRange&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
        </span><span style="color: blue;">bool </span><span style="color: black;">skipNullKey = </span><span style="color: blue;">false</span><span style="color: black;">)
    {
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: #2b91af;">TKey </span><span style="color: black;">key = keySelector(value);
            </span><span style="color: blue;">if </span><span style="color: black;">(key == </span><span style="color: blue;">null </span><span style="color: black;">&amp;&amp; skipNullKey)
            {
                </span><span style="color: blue;">continue</span><span style="color: black;">;
            }
            </span><span style="color: blue;">int </span><span style="color: black;">hashCOde = </span><span style="color: blue;">this</span><span style="color: black;">.GetHashCode(key);
            </span><span style="color: blue;">if </span><span style="color: black;">(</span><span style="color: blue;">this</span><span style="color: black;">.groups.TryGetValue(hashCOde, </span><span style="color: blue;">out </span><span style="color: #2b91af;">Grouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; group))
            {
                group.Add(elementSelector(value));
            }
            </span><span style="color: blue;">else
            </span><span style="color: black;">{
                </span><span style="color: blue;">this</span><span style="color: black;">.groups.Add(hashCOde, </span><span style="color: blue;">new </span><span style="color: #2b91af;">Grouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(key) { elementSelector(value) });
            }
        }
        </span><span style="color: blue;">return this</span><span style="color: black;">;
    }
}</span></pre>
<p>Now, ToLookup can be implemented by creating a lookup and adding all data:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; ToLookup&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(comparer).AddRange(source, keySelector, elementSelector);

</span><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToLookup&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        source.ToLookup(keySelector, value =&gt; value, comparer);</span></pre>
<h1>Sequence queries</h1>
<h2>Conversion</h2>
<p>AsEnumerable does nothing:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; AsEnumerable&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source) =&gt;
    source; </span><span style="color: green;">// Deferred execution.</span></pre>
<p>It also implements deferred execution, because calling AsEnumerable does not pull any value from source sequence.</p>
<p>Cast is very easy to implement with the generator syntactic sugar. Just yield each casted value:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Cast&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">source)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">object </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">(</span><span style="color: #2b91af;">TResult</span><span style="color: black;">)value; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<p>Here a little optimization can be done as well. If the source is already a generic sequence of the specified result type, it can be directly returned. Logically it should be something like:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Cast&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">source)
{</span><span style="color: black;">
    </span><span style="color: blue;">if </span><span style="color: black;">(<span style="color: black;">source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; </span>genericSource</span><span style="color: black;">)
    {
        </span><span style="color: blue;">return </span><span style="color: black;">genericSource;</span><span style="color: green;">
    </span><span style="color: black;">}

    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">object </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">(</span><span style="color: #2b91af;">TResult</span><span style="color: black;">)value; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<p>However the above code cannot be compiled. The yield statement indicates the entire method should be compiled to a generator, so the return statement does not make sense here. Similar to argument check, the solution is to isolate yield statement into another method:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Cast&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">source)
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; CastGenerator()
    {
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">object </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">(</span><span style="color: #2b91af;">TResult</span><span style="color: black;">)value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
    </span><span style="color: blue;">return </span><span style="color: black;">source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; genericSource
        ? genericSource
        : CastGenerator();</span><span style="color: green;">
</span><span style="color: black;">}</span></pre>
<p>Cast also implements deferred execution. When it is called, it returns either the source sequence itself or a generator, without pulling values from source or execute the casting.</p>
<h2>Generation</h2>
<p>Empty can simply return an empty array::</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Empty&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;() =&gt; </span><span style="color: #2b91af;">Array</span><span style="color: black;">.Empty<span style="color: #2b91af;"></span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;()</span>;</span></pre>
<p>It can also be implemented with a single yield break statement, which means yielding nothing to the caller:</p>
<pre class="code"><span style="color: blue;"><span style="color: black;"></span><span style="color: blue;">public </span>static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; EmptyGenerator&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;()
{
    </span><span style="color: blue;">yield break</span><span style="color: black;">;
}</span></pre>
<p>Just like yield return statement can be viewed as virtually yielding a value into the generated sequence, yield break statement can also be viewed as virtually end the generated sequence. The first implementation is used by .NET because it can be faster with cache. And creating empty array is less expensive than instantiating generator.</p>
<p>Range can be simply implemented with a loop:</p>
<pre class="code"><span style="color: black;"></span><span style="color: blue;">public </span><span style="color: blue;">static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; Range(</span><span style="color: blue;">int </span><span style="color: black;">start, </span><span style="color: blue;">int </span><span style="color: black;">count)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(count &lt; 0 || (((</span><span style="color: blue;">long</span><span style="color: black;">)start) + count - 1L) &gt; </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue)
    {
        </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentOutOfRangeException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(count));
    }

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; RangeGenerator()
    {
        </span><span style="color: blue;">int </span><span style="color: black;">end = start + count;
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">value = start; value != end; value++)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
    </span><span style="color: blue;">return </span><span style="color: black;">RangeGenerator();
}</span></pre>
<p>And Repeat has been discussed:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Repeat&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">TResult </span><span style="color: black;">element, </span><span style="color: blue;">int </span><span style="color: black;">count)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(count &lt; 0)
    {
        </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentOutOfRangeException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(count));
    }

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; RepeatGenerator()
    {
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">index = 0; index &lt; count; index++)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">element; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
    </span><span style="color: blue;">return </span><span style="color: black;">RepeatGenerator();
}</span></pre>
<p>DefaultIfEmpty can be implemented with a desugared foreach loop on source sequence:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; DefaultIfEmpty&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">defaultValue = </span><span style="color: blue;">default</span><span style="color: black;">)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(iterator.MoveNext())
        {
            </span><span style="color: green;">// source is not empty.
            </span><span style="color: blue;">do
            </span><span style="color: black;">{
                </span><span style="color: blue;">yield return </span><span style="color: black;">iterator.Current; </span><span style="color: green;">// Deferred execution.
            </span><span style="color: black;">}
            </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext());
        }
        </span><span style="color: blue;">else
        </span><span style="color: black;">{
            </span><span style="color: green;">// source is empty.
            </span><span style="color: blue;">yield return </span><span style="color: black;">defaultValue; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>The first MoveNext call detects if the source sequence is empty. If so, just yield the default value,, otherwise yield all values in the source sequence.</p>
<h2>Filtering</h2>
<p>Where is already discussed. The following are the non-indexed overload and index overload:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Where&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Where&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">int </span><span style="color: black;">index = -1;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        index = </span><span style="color: blue;">checked</span><span style="color: black;">(index + 1);
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value, index))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>In contrast, OfType has a type check to replace the predicate call:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; OfType&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">source)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">object </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(value </span><span style="color: blue;">is </span><span style="color: #2b91af;">TResult</span><span style="color: black;">)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">(</span><span style="color: #2b91af;">TResult</span><span style="color: black;">)value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<h2>Mapping</h2>
<p>Select has also been discussed:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Select&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">selector(value); </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Select&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector)
{
    </span><span style="color: blue;">int </span><span style="color: black;">index = -1;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        index = </span><span style="color: blue;">checked</span><span style="color: black;">(index + 1);
        </span><span style="color: blue;">yield return </span><span style="color: black;">selector(value, index); </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<p>The implementation of SelectMany is also straightforward:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selector)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TResult </span><span style="color: black;">result </span><span style="color: blue;">in </span><span style="color: black;">selector(value))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">result; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>Above code clearly shows its capacity to flatten a hierarchical 2-level-sequence to a flat 1-level-sequence. To implement the overload with resultSelector, just call it and yield its result:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TCollection</span><span style="color: black;">&gt;&gt; collectionSelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">sourceValue </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TCollection </span><span style="color: black;">collectionValue </span><span style="color: blue;">in </span><span style="color: black;">collectionSelector(sourceValue))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(sourceValue, collectionValue); </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>And the following are the indexed overloads:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selector)
{
    </span><span style="color: blue;">int </span><span style="color: black;">index = -1;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        index = </span><span style="color: blue;">checked</span><span style="color: black;">(index + 1);
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TResult </span><span style="color: black;">result </span><span style="color: blue;">in </span><span style="color: black;">selector(value, index))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">result; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TCollection</span><span style="color: black;">&gt;&gt; collectionSelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector)
{
    </span><span style="color: blue;">int </span><span style="color: black;">index = -1;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">sourceValue </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        index = </span><span style="color: blue;">checked</span><span style="color: black;">(index + 1);
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TCollection </span><span style="color: black;">collectionValue </span><span style="color: blue;">in </span><span style="color: black;">collectionSelector(sourceValue, index))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(sourceValue, collectionValue); </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<h2>Grouping</h2>
<p>GroupBy’s signature is very close to ToLookup. ToLookup returns a ILookup&lt;TKey, TElement&gt;, which implements IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;. However, directly calling ToLookup pulls the source values and execute the grouping immediately:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;&gt; GroupByWithToLookup&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        source.ToLookup(keySelector, comparer);</span></pre>
<p>To implement deferred execution, the easiest way is to involve yield statement:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; lookup = source.ToLookup(keySelector, comparer); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; group </span><span style="color: blue;">in </span><span style="color: black;">lookup)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">group; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<p>When trying to pull the first value from the returned generator, ToLookup is called to evaluate all source values and group them, so that the first group can be yielded. So GroupBy implements eager evaluation. The overloads with elementSelector and resultSelector can all be implemented in the same pattern:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; lookup = source.ToLookup(keySelector, elementSelector, comparer); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; group </span><span style="color: blue;">in </span><span style="color: black;">lookup)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">group; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; lookup = source.ToLookup(keySelector, comparer); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; group </span><span style="color: blue;">in </span><span style="color: black;">lookup)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(group.Key, group); </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; lookup = source.ToLookup(keySelector, elementSelector, comparer); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; group </span><span style="color: blue;">in </span><span style="color: black;">lookup)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(group.Key, group); </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<h2>Join</h2>
<p>Similar to GroupBy, GroupJoin for outer join can be simply implemented with ToLookup and yield:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupJoinWithLookup&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; innerLookup = inner.ToLookup(innerKeySelector, comparer); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TOuter </span><span style="color: black;">outerValue </span><span style="color: blue;">in </span><span style="color: black;">outer)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(outerValue, innerLookup[outerKeySelector(outerValue)]); </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<p>When trying to pull the first value from the returned generator, the inner values are grouped by the keys, and stored in the inner lookup. Then, for each outer value, query the inner lookup by key. Remember when a lookup is queried with a key, it always return a sequence, even when the key does not exist, it returns a empty sequence. So that in GroupJoin, each outer value is always paired with a group of inner values. The above implementation is straightforward, but the inner source is always pulled, even when the outer source is empty. This can be avoided by a little optimization:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupJoin&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outerIterator = outer.GetEnumerator())
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(outerIterator.MoveNext())
        {
            </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; innerLookup = </span><span style="color: blue;">new </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt;(comparer).AddRange(
                inner, innerKeySelector, innerValue =&gt; innerValue, skipNullKey: </span><span style="color: blue;">true</span><span style="color: black;">); </span><span style="color: green;">// Eager evaluation.
            </span><span style="color: blue;">do
            </span><span style="color: black;">{
                </span><span style="color: #2b91af;">TOuter </span><span style="color: black;">outerValue = outerIterator.Current;
                </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(outerValue, innerLookup[outerKeySelector(outerValue)]); </span><span style="color: green;">// Deferred execution.
            </span><span style="color: black;">}
            </span><span style="color: blue;">while </span><span style="color: black;">(outerIterator.MoveNext());
        }
    }
}</span></pre>
<p>Similar to DefaultIfEmpty, the first MoveNext call detects if the outer source is empty. Only if not, the inner values are pulled and converted to a lookup.</p>
<p>Join for inner join can also be implemented with the similar pattern:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; JoinWithToLookup&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; innerLookup = inner.ToLookup(innerKeySelector, comparer); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TOuter </span><span style="color: black;">outerValue </span><span style="color: blue;">in </span><span style="color: black;">outer)
    {
        </span><span style="color: #2b91af;">TKey </span><span style="color: black;">key = outerKeySelector(outerValue);
        </span><span style="color: blue;">if </span><span style="color: black;">(innerLookup.Contains(key))
        {
            </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TInner </span><span style="color: black;">innerValue </span><span style="color: blue;">in </span><span style="color: black;">innerLookup[key])
            {
                </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(outerValue, innerValue); </span><span style="color: green;">// Deferred execution.
            </span><span style="color: black;">}
        }
    }
}</span></pre>
<p>It calls the ILookup&lt;TKey, TElement&gt;.Contains filter, because in inner join each outer value has to be paired with a matching inner value. Again, the above implementation can be optimized, so that the inner values are not pulled and converted to lookup even when the outer source is empty:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Join&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outerIterator = outer.GetEnumerator())
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(outerIterator.MoveNext())
        {
            </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; innerLookup = </span><span style="color: blue;">new </span><span style="color: #2b91af;">Lookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt;(comparer).AddRange(
                inner, innerKeySelector, innerValue =&gt; innerValue, skipNullKey: </span><span style="color: blue;">true</span><span style="color: black;">); </span><span style="color: green;">// Eager evaluation.
            </span><span style="color: blue;">if </span><span style="color: black;">(innerLookup.Count &gt; 0)
            {
                </span><span style="color: blue;">do
                </span><span style="color: black;">{
                    </span><span style="color: #2b91af;">TOuter </span><span style="color: black;">outerValue = outerIterator.Current;
                    </span><span style="color: #2b91af;">TKey </span><span style="color: black;">key = outerKeySelector(outerValue);
                    </span><span style="color: blue;">if </span><span style="color: black;">(innerLookup.Contains(key))
                    {
                        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TInner </span><span style="color: black;">innerValue </span><span style="color: blue;">in </span><span style="color: black;">innerLookup[key])
                        {
                            </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(outerValue, innerValue); </span><span style="color: green;">// Deferred execution.
                        </span><span style="color: black;">}
                    }
                }
                </span><span style="color: blue;">while </span><span style="color: black;">(outerIterator.MoveNext());
            }
        }
    }
}</span></pre>
<h2>Concatenation</h2>
<p>Concat can be implemented by yielding values from the first source sequence, then from the second:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Concat&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">first)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">second)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<p>Append and Prepend can also be implemented with the similar pattern:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Append&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">element)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">value;
    }
    </span><span style="color: blue;">yield return </span><span style="color: black;">element;
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Prepend&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">element)
{
    </span><span style="color: blue;">yield return </span><span style="color: black;">element;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">value;
    }
}</span></pre>
<h2>Set</h2>
<p>All the set query methods need to remove duplicate values in the result sequence. So the following hash set is defined to represent a collection of distinct values. The duplication of values can be identified by their hash codes, so a dictionary can be used to store distinct hash code and value pairs:</p>
<pre class="code"><span style="color: blue;">public partial class </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
{
    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; equalityComparer;

    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; dictionary = </span><span style="color: blue;">new </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;();

    <span style="color: blue;">public </span></span><span style="color: blue;"></span><span style="color: black;">HashSet(</span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; equalityComparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        </span><span style="color: blue;">this</span><span style="color: black;">.equalityComparer = equalityComparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;.Default;

    </span><span style="color: blue;">public </span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; GetEnumerator() =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.dictionary.Values.GetEnumerator();

    </span><span style="color: #2b91af;">IEnumerator IEnumerable</span><span style="color: black;">.GetEnumerator() =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.GetEnumerator();
}</span></pre>
<p>Then, the following Add and AddRange methods can be defined:</p>
<pre class="code"><span style="color: blue;">public partial class </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
{
    </span><span style="color: blue;">private int </span><span style="color: black;">GetHashCode(</span><span style="color: #2b91af;">T </span><span style="color: black;">value) =&gt; value == </span><span style="color: blue;">null
        </span><span style="color: black;">? -1
        : </span><span style="color: blue;">this</span><span style="color: black;">.equalityComparer.GetHashCode(value) &amp; </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue;
        </span><span style="color: green;">// int.MaxValue is ‭0b01111111_11111111_11111111_11111111‬, so the result of &amp; is always &gt; -1.

    </span><span style="color: blue;">public bool </span><span style="color: black;">Add(</span><span style="color: #2b91af;">T </span><span style="color: black;">value)
    {
        </span><span style="color: blue;">int </span><span style="color: black;">hashCode = </span><span style="color: blue;">this</span><span style="color: black;">.GetHashCode(value);
        </span><span style="color: blue;">if </span><span style="color: black;">(</span><span style="color: blue;">this</span><span style="color: black;">.dictionary.ContainsKey(hashCode))
        {
            </span><span style="color: blue;">return false</span><span style="color: black;">;
        }
        </span><span style="color: blue;">this</span><span style="color: black;">.dictionary.Add(hashCode, value);
        </span><span style="color: blue;">return true</span><span style="color: black;">;
    }

    </span><span style="color: blue;">public </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; AddRange(</span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; values)
    {
        </span><span style="color: blue;">foreach</span><span style="color: black;">(</span><span style="color: #2b91af;">T </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">values)
        {
            </span><span style="color: blue;">this</span><span style="color: black;">.Add(value);
        }
        </span><span style="color: blue;">return this</span><span style="color: black;">;
    }
}</span></pre>
<p>When Add is called with a specified value, if there is already a duplicate hash code in the internal dictionary, the specified value is not stored in the dictionary and false is returned; otherwise, the specified value and its hash code are added to the internal dictionary, and true is returned. With above hash set, it is very easy to implement Distinct.</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Distinct&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; hashSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(comparer);
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(hashSet.Add(value))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>Add filters the values in the source sequence. This foreach-if-yield pattern is the same as Where. So logically the above implementation is equivalent to:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; DistinctWithWhere&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; hashSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(comparer);
    </span><span style="color: blue;">return </span><span style="color: black;">source.Where(hashSet.Add); </span><span style="color: green;">// Deferred execution.
</span><span style="color: black;">}</span></pre>
<p>However, this version becomes different, because It does not involve yield statement. As a result, the hash set is instantiated immediately.</p>
<p>Union can be implemented by filtering the first source sequence with HashSet&lt;T&gt;.Add, then filter the second source sequence with HashSet&lt;T&gt;.Add:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Union&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; hashSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(comparer);
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">firstValue </span><span style="color: blue;">in </span><span style="color: black;">first)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(hashSet.Add(firstValue))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">firstValue; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">secondValue </span><span style="color: blue;">in </span><span style="color: black;">second)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(hashSet.Add(secondValue))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">secondValue; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>Except can be implemented with the same pattern of filtering with HashSet&lt;T&gt;.Add:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Except&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; secondHashSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(comparer).AddRange(second); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">firstValue </span><span style="color: blue;">in </span><span style="color: black;">first)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(secondHashSet.Add(firstValue))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">firstValue; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>When trying to pull the first value from the returned generator, values in the second sequence are eagerly evaluated to a hash set, which is then used to filter the first sequence.</p>
<p>And Intersect can also be implemented with this pattern:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; IntersectWithAdd&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; secondHashSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(comparer).AddRange(second); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; firstHashSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(comparer);
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">firstValue </span><span style="color: blue;">in </span><span style="color: black;">first)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(secondHashSet.Add(firstValue))
        {
            firstHashSet.Add(firstValue);
        }
        </span><span style="color: blue;">else if </span><span style="color: black;">(firstHashSet.Add(firstValue))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">firstValue; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>To simplify above implementation, A Remove method can be defined for hash set:</p>
<pre class="code"><span style="color: blue;">public partial class </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
{
    </span><span style="color: blue;">public bool </span><span style="color: black;">Remove(</span><span style="color: #2b91af;">T </span><span style="color: black;">value)
    {
        </span><span style="color: blue;">int </span><span style="color: black;">hasCode = </span><span style="color: blue;">this</span><span style="color: black;">.GetHashCode(value);
        </span><span style="color: blue;">if </span><span style="color: black;">(</span><span style="color: blue;">this</span><span style="color: black;">.dictionary.ContainsKey(hasCode))
        {
            </span><span style="color: blue;">this</span><span style="color: black;">.dictionary.Remove(hasCode);
            </span><span style="color: blue;">return true</span><span style="color: black;">;
        }
        </span><span style="color: blue;">return false</span><span style="color: black;">;
    }
}</span></pre>
<p>Similar to Add, here if a value is found and removed, Remove returns true; otherwise, Remove directly returns false. So Intersect can be implemented by filtering with Remove:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Intersect&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; secondHashSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">HashSet</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(comparer).AddRange(second); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">firstValue </span><span style="color: blue;">in </span><span style="color: black;">first)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(secondHashSet.Remove(firstValue))
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">firstValue; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<h2>Convolution</h2>
<p>Zip is easy to implement with a desugared foreach:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Zip&lt;</span><span style="color: #2b91af;">TFirst</span><span style="color: black;">, </span><span style="color: #2b91af;">TSecond</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TFirst</span><span style="color: black;">&gt; first,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSecond</span><span style="color: black;">&gt; second,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TFirst</span><span style="color: black;">, </span><span style="color: #2b91af;">TSecond</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TFirst</span><span style="color: black;">&gt; firstIterator = first.GetEnumerator())
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSecond</span><span style="color: black;">&gt; secondIterator = second.GetEnumerator())
    {
        </span><span style="color: blue;">while </span><span style="color: black;">(firstIterator.MoveNext() &amp;&amp; secondIterator.MoveNext())
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">resultSelector(firstIterator.Current, secondIterator.Current); </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>It stops yielding result when one of those 2 source sequences reaches the end..</p>
<h2>Partitioning</h2>
<p>Skip is easy to implement:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Skip&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">count)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(count &gt; 0)
        {
            count--;
        }
        </span><span style="color: blue;">else
        </span><span style="color: black;">{
            </span><span style="color: blue;">yield return </span><span style="color: black;">value;
        }
    }
}</span></pre>
<p>It can be optimized a little bit by desugaring the foreach loop, so that when a value should be skipped, only the source iterator’s MoveNext method is called.</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Skip&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">count)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">while </span><span style="color: black;">(count &gt; 0 &amp;&amp; iterator.MoveNext())
        {
            count--; </span><span style="color: green;">// Comparing foreach loop, iterator.Current is not called.
        </span><span style="color: black;">}
        </span><span style="color: blue;">if </span><span style="color: black;">(count &lt;= 0)
        {
            </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
            {
                </span><span style="color: blue;">yield return </span><span style="color: black;">iterator.Current; </span><span style="color: green;">// Deferred execution.
            </span><span style="color: black;">}
        }
    }
}</span></pre>
<p>In contrast, SkipWhile has to pull each value from source sequence to call predicate, so there is no need to desugar foreach. The following are the non-index overload and indexed overload:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; SkipWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">bool </span><span style="color: black;">skip = </span><span style="color: blue;">true</span><span style="color: black;">;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(skip &amp;&amp; !predicate(value))
        {
            skip = </span><span style="color: blue;">false</span><span style="color: black;">;
        }
        </span><span style="color: blue;">if </span><span style="color: black;">(!skip)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; SkipWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">int </span><span style="color: black;">index = -1;
    </span><span style="color: blue;">bool </span><span style="color: black;">skip = </span><span style="color: blue;">true</span><span style="color: black;">;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        index = </span><span style="color: blue;">checked</span><span style="color: black;">(index + 1);
        </span><span style="color: blue;">if </span><span style="color: black;">(skip &amp;&amp; !predicate(value, index))
        {
            skip = </span><span style="color: blue;">false</span><span style="color: black;">;
        }
        </span><span style="color: blue;">if </span><span style="color: black;">(!skip)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
        </span><span style="color: black;">}
    }
}</span></pre>
<p>Take is also straightforward:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Take&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">count)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(count &gt; 0)
    {
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
            </span><span style="color: blue;">if </span><span style="color: black;">(--count == 0)
            {
                </span><span style="color: blue;">break</span><span style="color: black;">;
            }
        }
    }
}</span></pre>
<p>And the following are TakeWhile’s non-indexed overload and indexed overload:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; TakeWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(!predicate(value))
        {
            </span><span style="color: blue;">break</span><span style="color: black;">;
        }
        </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; TakeWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">int </span><span style="color: black;">index = -1;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        index = </span><span style="color: blue;">checked</span><span style="color: black;">(index + 1);
        </span><span style="color: blue;">if </span><span style="color: black;">(!predicate(value, index))
        {
            </span><span style="color: blue;">break</span><span style="color: black;">;
        }
        </span><span style="color: blue;">yield return </span><span style="color: black;">value; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<h2>Ordering</h2>
<p>Reverse has been discussed:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Reverse&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] array = ToArray(source); </span><span style="color: green;">// Eager evaluation.
    </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">index = array.Length - 1; index &gt;= 0; index--)
    {
        </span><span style="color: blue;">yield return </span><span style="color: black;">array[index]; </span><span style="color: green;">// Deferred execution.
    </span><span style="color: black;">}
}</span></pre>
<p>The other ordering query methods are different because they involve the IOrderedEnumerable&lt;T&gt; interface. Again here are the signatures:</p>
<pre class="code"><span style="color: black;"></span><span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector);

<span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector, <span style="color: #2b91af;">IComparer</span>&lt;TKey&gt; comparer);

<span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector);

<span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector, <span style="color: #2b91af;">IComparer</span>&lt;TKey&gt; comparer);</pre>
<p>And once again the following is the definition of IOrderedEnumerable&lt;T&gt;:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Linq
{
    </span><span style="color: blue;">public interface </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;, IEnumerable
    {
        </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; CreateOrderedEnumerable&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
            </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector, </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer, </span><span style="color: blue;">bool </span><span style="color: black;">descending);
    }
}</span></pre>
<p>Its implementation is a little complex:</p>
<pre class="code"><span style="color: blue;">internal class </span><span style="color: #2b91af;">OrderedSequence</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;
{
    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source;

    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer;

    </span><span style="color: blue;">private readonly bool </span><span style="color: black;">descending;

    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector;

    </span><span style="color: blue;">private readonly </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">[], </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;&gt; previousGetComparison;</span><span style="color: green;">

    </span><span style="color: blue;">internal </span><span style="color: black;">OrderedSequence(
        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
        </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer,
        </span><span style="color: blue;">bool </span><span style="color: black;">descending = </span><span style="color: blue;">false</span><span style="color: black;">,
        </span><span style="color: green;">// previousGetComparison is only specified in CreateOrderedEnumerable,
        // and CreateOrderedEnumerable is only called by ThenBy/ThenByDescending.
        // When OrderBy/OrderByDescending is called, previousGetComparison is not specified.
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">[], </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;&gt; previousGetComparison = </span><span style="color: blue;">null</span><span style="color: black;">)</span><span style="color: green;">
    </span><span style="color: black;">{
        </span><span style="color: blue;">this</span><span style="color: black;">.source = source;
        </span><span style="color: blue;">this</span><span style="color: black;">.keySelector = keySelector;
        </span><span style="color: blue;">this</span><span style="color: black;">.comparer = comparer ?? </span><span style="color: #2b91af;">Comparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;.Default;
        </span><span style="color: blue;">this</span><span style="color: black;">.descending = descending;
        </span><span style="color: blue;">this</span><span style="color: black;">.previousGetComparison = previousGetComparison;
    }

    </span><span style="color: blue;">public </span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; GetEnumerator()
    {
        </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] values = </span><span style="color: blue;">this</span><span style="color: black;">.source.ToArray(); </span><span style="color: green;">// Eager evaluation.
        </span><span style="color: blue;">int </span><span style="color: black;">count = values.Length;
        </span><span style="color: blue;">if </span><span style="color: black;">(count &lt;= 0)
        {
            </span><span style="color: blue;">yield break</span><span style="color: black;">;
        }

        </span><span style="color: blue;">int</span><span style="color: black;">[] indexMap = </span><span style="color: blue;">new int</span><span style="color: black;">[count];
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">index = 0; index &lt; count; index++)
        {
            indexMap[index] = index;
        }
        </span><span style="color: green;">// GetComparison is only called once for each generator instance.
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; comparison = </span><span style="color: blue;">this</span><span style="color: black;">.GetComparison(values);</span><span style="color: green;">
        </span><span style="color: #2b91af;">Array</span><span style="color: black;">.Sort(indexMap, (index1, index2) =&gt; </span><span style="color: green;">// index1 &lt; index2
        </span><span style="color: black;">{
            </span><span style="color: green;">// Format compareResult.
            // When compareResult is 0 (equal), return index1 - index2,
            // so that indexMap[index1] is before indexMap[index2],
            // 2 equal values' original order is preserved.
            </span><span style="color: blue;">int </span><span style="color: black;">compareResult = comparison(index1, index2);
            </span><span style="color: blue;">return </span><span style="color: black;">compareResult == 0 ? index1 - index2 : compareResult;
        }); </span><span style="color: green;">// More eager evaluation.
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">index = 0; index &lt; count; index++)
        {
            </span><span style="color: blue;">yield return </span><span style="color: black;">values[indexMap[index]];
        }
    }

    </span><span style="color: #2b91af;">IEnumerator IEnumerable</span><span style="color: black;">.GetEnumerator() =&gt; </span><span style="color: blue;">this</span><span style="color: black;">.GetEnumerator();

    </span><span style="color: green;">// Only called by ThenBy/ThenByDescending.
    </span><span style="color: blue;">public </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; CreateOrderedEnumerable&lt;</span><span style="color: #2b91af;">TNextKey</span><span style="color: black;">&gt;
        (</span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TNextKey</span><span style="color: black;">&gt; nextKeySelector, </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TNextKey</span><span style="color: black;">&gt; nextComparer, </span><span style="color: blue;">bool </span><span style="color: black;">nextDescending) =&gt;
            </span><span style="color: blue;">new </span><span style="color: #2b91af;">OrderedSequence</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TNextKey</span><span style="color: black;">&gt;(
                </span><span style="color: blue;">this</span><span style="color: black;">.source, nextKeySelector, nextComparer, nextDescending, </span><span style="color: blue;">this</span><span style="color: black;">.GetComparison);

    </span><span style="color: blue;">private </span><span style="color: #2b91af;">TKey</span><span style="color: black;">[] GetKeys(</span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] values)
    {
        </span><span style="color: blue;">int </span><span style="color: black;">count = values.Length;
        </span><span style="color: #2b91af;">TKey</span><span style="color: black;">[] keys = </span><span style="color: blue;">new </span><span style="color: #2b91af;">TKey</span><span style="color: black;">[count];
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">index = 0; index &lt; count; index++)
        {
            keys[index] = </span><span style="color: blue;">this</span><span style="color: black;">.keySelector(values[index]);
        }
        </span><span style="color: blue;">return </span><span style="color: black;">keys;
    }

    </span><span style="color: blue;">private </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; GetComparison(</span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] values)</span><span style="color: green;">
    </span><span style="color: black;">{
        </span><span style="color: green;">// GetComparison is only called once for each generator instance,
        // so GetKeys is only called once during the ordering query execution.
        </span><span style="color: #2b91af;">TKey</span><span style="color: black;">[] keys = </span><span style="color: blue;">this</span><span style="color: black;">.GetKeys(values);
        </span><span style="color: blue;">if </span><span style="color: black;">(</span><span style="color: blue;">this</span><span style="color: black;">.previousGetComparison == </span><span style="color: blue;">null</span><span style="color: black;">)
        {
            </span><span style="color: green;">// In OrderBy/OrderByDescending.
            </span><span style="color: blue;">return </span><span style="color: black;">(index1, index2) =&gt;
                </span><span style="color: green;">// OrderBy/OrderByDescending always need to compare keys of 2 values.
                </span><span style="color: blue;">this</span><span style="color: black;">.CompareKeys(keys, index1, index2);
        }
        </span><span style="color: green;">// In ThenBy/ThenByDescending.
        </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; previousComparison = </span><span style="color: blue;">this</span><span style="color: black;">.previousGetComparison(values);
        </span><span style="color: blue;">return </span><span style="color: black;">(index1, index2) =&gt;
        {
            </span><span style="color: green;">// Only when previousCompareResult is 0 (equal),
            // ThenBy/ThenByDescending needs to compare keys of 2 values.
            </span><span style="color: blue;">int </span><span style="color: black;">previousCompareResult = previousComparison(index1, index2);
            </span><span style="color: blue;">return </span><span style="color: black;">previousCompareResult == 0
                ? </span><span style="color: blue;">this</span><span style="color: black;">.CompareKeys(keys, index1, index2)
                : previousCompareResult;
        };
    }

    </span><span style="color: blue;">private int </span><span style="color: black;">CompareKeys(</span><span style="color: #2b91af;">TKey</span><span style="color: black;">[] keys, </span><span style="color: blue;">int </span><span style="color: black;">index1, </span><span style="color: blue;">int </span><span style="color: black;">index2)
    {
        </span><span style="color: green;">// Format compareResult to always be 0, -1, or 1.
        </span><span style="color: blue;">int </span><span style="color: black;">compareResult = </span><span style="color: blue;">this</span><span style="color: black;">.comparer.Compare(keys[index1], keys[index2]);
        </span><span style="color: blue;">return </span><span style="color: black;">compareResult == 0
            ? 0
            : (</span><span style="color: blue;">this</span><span style="color: black;">.descending ? (compareResult &gt; 0 ? -1 : 1) : (compareResult &gt; 0 ? 1 : -1));
    }
}</span></pre>
<p>To implement deferred execution, its constructor does not evaluate any value from source. So that the query methods can just instantiate it and return:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; OrderBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">OrderedSequence</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(source, keySelector, comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; OrderByDescending&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">OrderedSequence</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(source, keySelector, comparer, descending: </span><span style="color: blue;">true</span><span style="color: black;">);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ThenBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        source.CreateOrderedEnumerable(keySelector, comparer, descending: </span><span style="color: blue;">false</span><span style="color: black;">);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ThenByDescending&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IOrderedEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">) =&gt;
        source.CreateOrderedEnumerable(keySelector, comparer, descending: </span><span style="color: blue;">true</span><span style="color: black;">);</span></pre>
<p>OrderedSequence&lt;T&gt; is a sequence wrapping the source data and iteration algorithm of ordering, including:</p>
<ul>
<li>the source sequence,</li>
<li>the keySelector function,</li>
<li>a bool value indicating the ordering should be descending or ascending</li>
<li>a previousGetComparison function, which identifies whether current OrderedSequence&lt;T&gt; is created by OrderBy/OrderByDescending, or by ThenBy/ThenByDescending
<ul>
<li>When OrderBy/OrderByDescending are called, they directly instantiate an OrderedSequence&lt;T&gt; with a null previousGetComparison function.</li>
<li>When ThenBy/ThenByDescending are called, they call CreateOrderedEnumerable to instantiate OrderedSequence&lt;T&gt;, and pass its OrderedSequence&lt;T&gt;’s GetComparison method as the previousGetComparison function for the new OrderedSequence&lt;T&gt;.</li>
</ul>
</li>
</ul>
<p>OrderedSequence’s GetEnumeraor method uses yield statement to return an iterator (not generator this time). Eager evaluation is implemented, because it has to pull all values in the source sequence and sort them, in order to know which value is the first one to yield. For performance consideration, instead of sorting the values from source sequence, here the indexes of values are sorted. For example, in the values array, if indexes { 0, 1, 2 } become { 2, 0, 1 } after sorting, then the values are yielded in the order of { values[2], values[0], values[1] }.</p>
<p>When the eager evaluation starts, GetComparison is called. It evaluates all keys of the values, and returns a comparison function:</p>
<ul>
<li>If previousGetComparison function is null, it returns a comparison function to represent an OrderBy/OrderByDescending query, which just compares the keys.</li>
<li>if previousGetComparison function is not null, it returns a comparison function to&nbsp; represents an ThenBy/ThenByDescending query, which first check the previous compare result, and only compare the keys when previous compare result is equal.</li>
<li>In both cases, comparison function calls CompareKeys to compare 2 keys. CompareKeys calls IComparer&lt;TKey&gt;.Compare, and format the compare result to 0, -1, or 1 to represent less then, equal to, greater than. If the descending field is true, 1 and -1 are swapped.</li>
</ul>
<p>Eventually, the returned comparison function is used during GetEnumerator’s eager evaluation, to sort the indexes of values. When comparing keys for index1 and index2, index1 is always less than index2. In another word, values[index1] is before values[index2] before the ordering query execution. If the result from comparison function is equal, index1 - index2 is used instead of 0. So that the relative positions of values at index1 and index2 are preserved, values[index1] is still before values[index2] after the ordering query execution.</p>
<h1>Value queries</h1>
<p>This category of query methods iterate the source sequence, and cannot implement deferred execution.</p>
<h2>Element</h2>
<p>To implement First, just pull the source sequence once. But if the source already supports index, then source[0] can be pulled, which is cheaper than calling the GetEnumerator, MoveNext, and Current methods. The index support can be identified by detecting if source also implements IList&lt;T&gt;:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Collections.Generic
{
    </span><span style="color: blue;">public interface </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">IEnumerable
    </span><span style="color: black;">{
        </span><span style="color: #2b91af;">T </span><span style="color: blue;">this</span><span style="color: black;">[</span><span style="color: blue;">int </span><span style="color: black;">index] { </span><span style="color: blue;">get</span><span style="color: black;">; </span><span style="color: blue;">set</span><span style="color: black;">; }

        </span><span style="color: blue;">int </span><span style="color: black;">IndexOf(</span><span style="color: #2b91af;">T </span><span style="color: black;">item);

        </span><span style="color: blue;">void </span><span style="color: black;">Insert(</span><span style="color: blue;">int </span><span style="color: black;">index, </span><span style="color: #2b91af;">T </span><span style="color: black;">item);

        </span><span style="color: blue;">void </span><span style="color: black;">RemoveAt(</span><span style="color: blue;">int </span><span style="color: black;">index);
    }
}</span></pre>
<p>As fore mentioned, IList&lt;T&gt; is implemented by T[] array, List&lt;T&gt;, and Collection&lt;T&gt;, etc. So the following is an optimized implementation of First:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">First&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(list.Count &gt; 0)
        {
            </span><span style="color: blue;">return </span><span style="color: black;">list[0];
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: blue;">return </span><span style="color: black;">value;
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
}</span></pre>
<p>The other overload with predicate is also easy to implement:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">First&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
        {
            </span><span style="color: blue;">return </span><span style="color: black;">value;
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no matching element."</span><span style="color: black;">);
}</span></pre>
<p>The implementation of FirstOrDefault is very similar. When source is empty, just return the default value instead of throwing exception:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">FirstOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(list.Count &gt; 0)
        {
            </span><span style="color: blue;">return </span><span style="color: black;">list[0];
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
        {
            </span><span style="color: blue;">return </span><span style="color: black;">value;
        }
    }
    </span><span style="color: blue;">return default</span><span style="color: black;">;
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">FirstOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
        {
            </span><span style="color: blue;">return </span><span style="color: black;">value;
        }
    }
    </span><span style="color: blue;">return default</span><span style="color: black;">;
}</span></pre>
<p>Last and LastOrDefault can be implemented in the similar pattern, with desugared foreach loop:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Last&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{</span><span style="color: black;">
    <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
</span></span><span style="color: black;">    {
        </span><span style="color: blue;">int </span><span style="color: black;">count = list.Count;
        </span><span style="color: blue;">if </span><span style="color: black;">(count &gt; 0)
        {
            </span><span style="color: blue;">return </span><span style="color: black;">list[count - 1];
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(iterator.MoveNext())
            {
                </span><span style="color: #2b91af;">TSource </span><span style="color: black;">last;
                </span><span style="color: blue;">do
                </span><span style="color: black;">{
                    last = iterator.Current;
                }
                </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext());
                </span><span style="color: blue;">return </span><span style="color: black;">last;
            }
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Last&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{</span><span style="color: black;">
    <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
</span></span><span style="color: black;">    {
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">index = list.Count - 1; index &gt;= 0; index--)
        {
            </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value = list[index];
            </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
            {
                </span><span style="color: blue;">return </span><span style="color: black;">value;
            }
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
        {
            </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
            {
                </span><span style="color: #2b91af;">TSource </span><span style="color: black;">last = iterator.Current;
                </span><span style="color: blue;">if </span><span style="color: black;">(predicate(last))
                {
                    </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
                    {
                        </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value = iterator.Current;
                        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
                        {
                            last = value;
                        }
                    }
                    </span><span style="color: blue;">return </span><span style="color: black;">last;
                }
            }
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no matching element."</span><span style="color: black;">);
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">LastOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{</span><span style="color: black;">
    <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
</span></span><span style="color: black;">    {
        </span><span style="color: blue;">int </span><span style="color: black;">count = list.Count;
        </span><span style="color: blue;">if </span><span style="color: black;">(count &gt; 0)
        {
            </span><span style="color: blue;">return </span><span style="color: black;">list[count - 1];
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(iterator.MoveNext())
            {
                </span><span style="color: #2b91af;">TSource </span><span style="color: black;">last;
                </span><span style="color: blue;">do
                </span><span style="color: black;">{
                    last = iterator.Current;
                }
                </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext());
                </span><span style="color: blue;">return </span><span style="color: black;">last;
            }
        }
    }
    </span><span style="color: blue;">return default</span><span style="color: black;">;
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">LastOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{</span><span style="color: black;">
    <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
</span></span><span style="color: black;">    {
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">index = list.Count - 1; index &gt;= 0; index--)
        {
            </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value = list[index];
            </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
            {
                </span><span style="color: blue;">return </span><span style="color: black;">value;
            }
        }
        </span><span style="color: blue;">return default</span><span style="color: black;">;
    }
    </span><span style="color: #2b91af;">TSource </span><span style="color: black;">last = </span><span style="color: blue;">default</span><span style="color: black;">;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
        {
            last = value;
        }
    }
    </span><span style="color: blue;">return </span><span style="color: black;">last;
}</span></pre>
<p>And ElementAt and ElementAtOrDefault too:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">ElementAt&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">index)
{</span><span style="color: black;">
    <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
</span></span><span style="color: black;">    {
        </span><span style="color: blue;">return </span><span style="color: black;">list[index];
    }

    </span><span style="color: blue;">if </span><span style="color: black;">(index &lt; 0)
    {
        </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentOutOfRangeException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(index));
    }

    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(index-- == 0)
            {
                </span><span style="color: blue;">return </span><span style="color: black;">iterator.Current;
            }
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">ArgumentOutOfRangeException</span><span style="color: black;">(</span><span style="color: blue;">nameof</span><span style="color: black;">(index));
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">ElementAtOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">index)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(index &gt;= 0)
    {</span><span style="color: black;">
        <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
</span></span><span style="color: black;">
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(index &lt; list.Count)
            {
                </span><span style="color: blue;">return </span><span style="color: black;">list[index];
            }
        }
        </span><span style="color: blue;">else
        </span><span style="color: black;">{
            </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
            {
                </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
                {
                    </span><span style="color: blue;">if </span><span style="color: black;">(index-- == 0)
                    {
                        </span><span style="color: blue;">return </span><span style="color: black;">iterator.Current;
                    }
                }
            }
        }
    }
    </span><span style="color: blue;">return default</span><span style="color: black;">;
}</span></pre>
<p>Single and SingleOrDefault is more strict:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Single&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)</span></span><span style="color: black;">
    {
        </span><span style="color: blue;">switch </span><span style="color: black;">(list.Count)
        {
            </span><span style="color: blue;">case </span><span style="color: black;">0:
                </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
            </span><span style="color: blue;">case </span><span style="color: black;">1:
                </span><span style="color: blue;">return </span><span style="color: black;">list[0];
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(!iterator.MoveNext()) </span><span style="color: green;">// source is empty.
            </span><span style="color: black;">{
                </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
            }

            </span><span style="color: #2b91af;">TSource </span><span style="color: black;">first = iterator.Current;
            </span><span style="color: blue;">if </span><span style="color: black;">(!iterator.MoveNext())
            {
                </span><span style="color: blue;">return </span><span style="color: black;">first;
            }
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains more than one element."</span><span style="color: black;">);
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Single&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value = iterator.Current;
            </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
            {
                </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
                {
                    </span><span style="color: blue;">if </span><span style="color: black;">(predicate(iterator.Current))
                    {
                        </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains more than one matching element."</span><span style="color: black;">);
                    }
                }
                </span><span style="color: blue;">return </span><span style="color: black;">value;
            }
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no matching element."</span><span style="color: black;">);
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">SingleOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    <span style="color: black;"></span><span style="color: blue;">if </span><span style="color: black;">(source </span><span style="color: blue;">is </span><span style="color: #2b91af;">IList</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; list)
</span></span><span style="color: black;">    {
        </span><span style="color: blue;">switch </span><span style="color: black;">(list.Count)
        {
            </span><span style="color: blue;">case </span><span style="color: black;">0:
                </span><span style="color: blue;">return default</span><span style="color: black;">;
            </span><span style="color: blue;">case </span><span style="color: black;">1:
                </span><span style="color: blue;">return </span><span style="color: black;">list[0];
        }
    }
    </span><span style="color: blue;">else
    </span><span style="color: black;">{
        </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(iterator.MoveNext())
            {
                </span><span style="color: #2b91af;">TSource </span><span style="color: black;">first = iterator.Current;
                </span><span style="color: blue;">if </span><span style="color: black;">(!iterator.MoveNext())
                {
                    </span><span style="color: blue;">return </span><span style="color: black;">first;
                }
            }
            </span><span style="color: blue;">else
            </span><span style="color: black;">{
                </span><span style="color: blue;">return default</span><span style="color: black;">;
            }
        }
    }
    </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains more than one element."</span><span style="color: black;">);
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">SingleOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value = iterator.Current;
            </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
            {
                </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
                {
                    </span><span style="color: blue;">if </span><span style="color: black;">(predicate(iterator.Current))
                    {
                        </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains more than one matching element."</span><span style="color: black;">);
                    }
                }

                </span><span style="color: blue;">return </span><span style="color: black;">value;
            }
        }
    }
    </span><span style="color: blue;">return default</span><span style="color: black;">;
}</span></pre>
<h2>Aggregation</h2>
<p>Aggregation pulls all values from source and accumulate them:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TResult </span><span style="color: black;">Aggregate&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">seed,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">&gt; func,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector)
{
    </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">accumulate = seed;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        accumulate = func(accumulate, value);
    }
    </span><span style="color: blue;">return </span><span style="color: black;">resultSelector(accumulate);
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">Aggregate&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">seed, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">&gt; func)
{
    </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">accumulate = seed;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        accumulate = func(accumulate, value);
    }
    </span><span style="color: blue;">return </span><span style="color: black;">accumulate;
}

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Aggregate&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; func)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(!iterator.MoveNext())
        {
            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
        }

        </span><span style="color: #2b91af;">TSource </span><span style="color: black;">accumulate = iterator.Current;
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            accumulate = func(accumulate, iterator.Current);
        }
        </span><span style="color: blue;">return </span><span style="color: black;">accumulate;
    }
}</span></pre>
<p>Count can be implemented by iterating the source sequence. And if the source sequence is a collection, then it has a Count property:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Count&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">switch </span><span style="color: black;">(source)
    {
        </span><span style="color: blue;">case </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; genericCollection:
            </span><span style="color: blue;">return </span><span style="color: black;">genericCollection.Count;
        </span><span style="color: blue;">case </span><span style="color: #2b91af;">ICollection </span><span style="color: black;">collection:
            </span><span style="color: blue;">return </span><span style="color: black;">collection.Count;
        </span><span style="color: blue;">default</span><span style="color: black;">:
            </span><span style="color: blue;">int </span><span style="color: black;">count = 0;
            </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
            {
                </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
                {
                    count = </span><span style="color: blue;">checked</span><span style="color: black;">(count + 1); </span><span style="color: green;">// Comparing foreach loop, iterator.Current is never called.
                </span><span style="color: black;">}
            }
            </span><span style="color: blue;">return </span><span style="color: black;">count;
    }
}</span></pre>
<p>And the overload with predicate can be implemented by filtering with the predicate function:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Count&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">int </span><span style="color: black;">count = 0;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
        {
            count = </span><span style="color: blue;">checked</span><span style="color: black;">(count + 1);
        }
    }
    </span><span style="color: blue;">return </span><span style="color: black;">count;
}</span></pre>
<p>LongCount cannot use collections’ Count property because it returns int. It simply counts the values:</p>
<pre class="code"><span style="color: blue;">public static long </span><span style="color: black;">LongCount&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">long </span><span style="color: black;">count = 0L;
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            count = </span><span style="color: blue;">checked</span><span style="color: black;">(count + 1L); </span><span style="color: green;">// Comparing foreach loop, iterator.Current is never called.
        </span><span style="color: black;">}
    }
    </span><span style="color: blue;">return </span><span style="color: black;">count;
}

</span><span style="color: blue;">public static long </span><span style="color: black;">LongCount&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">long </span><span style="color: black;">count = 0L;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
        {
            count = </span><span style="color: blue;">checked</span><span style="color: black;">(count + 1L);
        }
    }
    </span><span style="color: blue;">return </span><span style="color: black;">count;
}</span></pre>
<p>BTW – <a href="https://msdn.microsoft.com/en-us/library/ms229042.aspx" target="_blank">.NET Framework Design Guidelines’</a> <a href="https://msdn.microsoft.com/en-us/library/ms229045.aspx" target="_blank">General Naming Conventions</a> says:</p>
<blockquote>
<p>DO use a generic CLR type name, rather than a language-specific name.</p>
</blockquote>
<p>It would be more consistent if LongCount was named as Int64Count, just like Convert.ToInt64, etc.</p>
<p>Min has 22 overloads, the following is the overload for decimal:</p>
<pre class="code"><span style="color: blue;">public static decimal </span><span style="color: black;">Min(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">decimal</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">decimal </span><span style="color: black;">min;
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: blue;">decimal</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(!iterator.MoveNext())
        {
            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
        }
        min = iterator.Current;
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            </span><span style="color: blue;">decimal </span><span style="color: black;">value = iterator.Current;
            </span><span style="color: blue;">if </span><span style="color: black;">(value &lt; min)
            {
                min = value;
            }
        }
    }
    </span><span style="color: blue;">return </span><span style="color: black;">min;
}</span></pre>
<p>And the decimal overload with selector can be implemented with Select:</p>
<pre class="code"><span style="color: blue;">public static decimal </span><span style="color: black;">Min&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">decimal</span><span style="color: black;">&gt; selector) =&gt; source.Select(selector).Min();</span></pre>
<p>Max also has 22 overloads. The overload for decimal without and with selector can be implemented with the same pattern:</p>
<pre class="code"><span style="color: blue;">public static decimal </span><span style="color: black;">Max(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">decimal</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">decimal </span><span style="color: black;">max;
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: blue;">decimal</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(!iterator.MoveNext())
        {
            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
        }

        max = iterator.Current;
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            </span><span style="color: blue;">decimal </span><span style="color: black;">value = iterator.Current;
            </span><span style="color: blue;">if </span><span style="color: black;">(value &gt; max)
            {
                max = value;
            }
        }
    }
    </span><span style="color: blue;">return </span><span style="color: black;">max;
}

</span><span style="color: blue;">public static decimal </span><span style="color: black;">Max&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">decimal</span><span style="color: black;">&gt; selector) =&gt; source.Select(selector).Max();</span></pre>
<p>Sum/Average has 20 overloads each. Also take the decimal overloads as example:</p>
<pre class="code"><span style="color: blue;">public static long </span><span style="color: black;">Sum&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">long</span><span style="color: black;">&gt; selector) =&gt;
    source.Select(selector).Sum();

</span><span style="color: blue;">public static decimal </span><span style="color: black;">Sum(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">decimal</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">decimal </span><span style="color: black;">sum = 0;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">decimal </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        sum += value;
    }
    </span><span style="color: blue;">return </span><span style="color: black;">sum;
}

</span><span style="color: blue;">public static decimal </span><span style="color: black;">Average&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">decimal</span><span style="color: black;">&gt; selector)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(!iterator.MoveNext())
        {
            </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">(</span><span style="color: #a31515;">"Sequence contains no elements."</span><span style="color: black;">);
        }
        </span><span style="color: blue;">decimal </span><span style="color: black;">sum = selector(iterator.Current);
        </span><span style="color: blue;">long </span><span style="color: black;">count = 1L;
        </span><span style="color: blue;">while </span><span style="color: black;">(iterator.MoveNext())
        {
            sum += selector(iterator.Current);
            count++;
        }
        </span><span style="color: blue;">return </span><span style="color: black;">sum / count;
    }
}</span></pre>
<h2>Quantifier</h2>
<p>All, Any, and Contains return a bool result. They can be implemented in a similar foreach-if pattern:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">All&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(!predicate(value))
        {
            </span><span style="color: blue;">return false</span><span style="color: black;">;
        }
    }
    </span><span style="color: blue;">return true</span><span style="color: black;">;
}

</span><span style="color: blue;">public static bool </span><span style="color: black;">Any&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate)
{
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(predicate(value))
        {
            </span><span style="color: blue;">return true</span><span style="color: black;">;
        }
    }
    </span><span style="color: blue;">return false</span><span style="color: black;">;
}

</span><span style="color: blue;">public static bool </span><span style="color: black;">Any&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; iterator = source.GetEnumerator())
    {
        </span><span style="color: blue;">return </span><span style="color: black;">iterator.MoveNext(); </span><span style="color: green;">// Not needed to call iterator.Current.
    </span><span style="color: black;">}
}

</span><span style="color: blue;">public static bool </span><span style="color: black;">Contains&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    </span><span style="color: blue;">if </span><span style="color: black;">(comparer == </span><span style="color: blue;">null </span><span style="color: black;">&amp;&amp; source </span><span style="color: blue;">is </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; collection)
    {
        </span><span style="color: blue;">return </span><span style="color: black;">collection.Contains(value);
    }
    comparer = comparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;.Default;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">TSource </span><span style="color: black;">sourceValue </span><span style="color: blue;">in </span><span style="color: black;">source)
    {
        </span><span style="color: blue;">if </span><span style="color: black;">(comparer.Equals(sourceValue, value))
        {
            </span><span style="color: blue;">return true</span><span style="color: black;">;
        }
    }
    </span><span style="color: blue;">return false</span><span style="color: black;">;
}
</span></pre>
<p>Contains can b optimized a little bit because collection already has a Contains method.</p>
<h2>Equality</h2>
<p>The implementation of SequenceEqual is a little similar to Zip, where 2 sequences are iterated at the same time. They are equal only when their counts are equal, and their values at each index are equal:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">SequenceEqual&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    comparer = comparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;.Default;
    </span><span style="color: blue;">if </span><span style="color: black;">(first </span><span style="color: blue;">is </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; firstCollection &amp;&amp; second </span><span style="color: blue;">is </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; secondCollection
        &amp;&amp; firstCollection.Count != secondCollection.Count)
    {
        </span><span style="color: blue;">return false</span><span style="color: black;">;
    }
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; firstIterator = first.GetEnumerator())
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">IEnumerator</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; secondIterator = second.GetEnumerator())
    {
        </span><span style="color: blue;">while </span><span style="color: black;">(firstIterator.MoveNext())
        {
            </span><span style="color: blue;">if </span><span style="color: black;">(!secondIterator.MoveNext() || !comparer.Equals(firstIterator.Current, secondIterator.Current))
            {
                </span><span style="color: blue;">return false</span><span style="color: black;">;
            }
        }
        </span><span style="color: blue;">return </span><span style="color: black;">!secondIterator.MoveNext();
    }
}</span></pre>


</div>
</body>
</html>
