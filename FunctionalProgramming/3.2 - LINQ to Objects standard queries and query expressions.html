<html>
<head>
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<div class="mainDiv">



<h1>LINQ to Objects (2) Query Methods (Operators) and Query Expressions</h1>

<p>This part discusses the usages of built-in LINQ to Objects query methods and query expressions. As fore mentioned, these query methods (also called <a href="http://msdn.microsoft.com/en-us/library/bb397896.aspx" target="_blank" mce_href="http://msdn.microsoft.com/en-us/library/bb397896.aspx">standard query operators</a>) are provided in System.Linq.Enumerable type, most of which are IEnumerable&lt;T&gt; extension methods. They can be categorized by return type:</p>
<ol>
<li>Sequence queries: return a new IEnumerable&lt;T&gt; sequence:
<ul>
<li>Generation: Empty , Range, Repeat, DefaultIfEmpty</li>
<li>Filtering (restriction): Where*, OfType</li>
<li>Mapping (projection): Select*, SelectMany*</li>
<li>Grouping: GroupBy*</li>
<li>Join: SelectMany, Join*, GroupJoin*</li>
<li>Concatenation: Concat, Append, Prepend</li>
<li>Set: Distinct, Union, Intersect, Except</li>
<li>Convolution: Zip</li>
<li>Partitioning: Take, Skip, TakeWhile, SkipWhile</li>
<li>Ordering: OrderBy*, ThenBy*, OrderByDescending*, ThenByDescending*, Reverse*</li>
<li>Conversion: Cast*, AsEnumerable</li>
</ul>
</li>
<li>Collection queries: return a new collection:
<ul>
<li>Conversion: ToArray, ToList, ToDictionary, ToLookup</li>
</ul>
</li>
<li>Value queries: return a single value:
<ul>
<li>Element: First, FirstOrDefault, Last, LastOrDefault, ElementAt, ElementAtOrDefault, Single, SingleOrDefault</li>
<li>Aggregation: Aggregate, Count, LongCount, Min, Max, Sum, Average</li>
<li>Quantifier: All, Any, Contains</li>
<li>Equality: SequenceEqual</li>
</ul>
</li>
</ol>
<p>These LINQ query methods are very functional. They are functions that can be composed by fluent chaining. Many of them are higher-order functions accepting function parameters, so that anonymous functions (lambda expressions) or named functions can be passed to them. The query methods returning IEnumerable&lt;T&gt; are pure functions. They are referential transparency and side effect free. When they are called, they only create and return a new sequence wrapping the input sequence and the query logic, with the query logic not executed, so there is no state changes, data mutation, I/O, etc. The query logic execution is deferred until the result values are pulled from the returned sequence. The other query methods (returning a new collection or a single value) are impure functions. When they are called, they immediately evaluate the values of the input source sequence, and execute the query logic.</p>
<p>As discussed in the Functional Programming chapter, The query methods marked with * are supported with query expressions syntax.</p>
<table width="577" cellspacing="0" cellpadding="2" border="0">
<tbody>
<tr>
<td width="297" valign="top">Query expression</td>
<td width="278" valign="top">Query method</td>
</tr>
<tr>
<td width="297" valign="top">single from clause with select clause</td>
<td width="278" valign="top">Select</td>
</tr>
<tr>
<td width="297" valign="top">multiple from clauses with select clause</td>
<td width="278" valign="top">SelectMany</td>
</tr>
<tr>
<td width="297" valign="top">Type in from/join clauses</td>
<td width="278" valign="top">Cast</td>
</tr>
<tr>
<td width="297" valign="top">join clause without into</td>
<td width="278" valign="top">Join</td>
</tr>
<tr>
<td width="297" valign="top">join clause with into</td>
<td width="278" valign="top">GroupJoin</td>
</tr>
<tr>
<td width="297" valign="top">let clause</td>
<td width="278" valign="top">Select</td>
</tr>
<tr>
<td width="297" valign="top">where clauses</td>
<td width="278" valign="top">Where</td>
</tr>
<tr>
<td width="297" valign="top">orderby clause with or without ascending</td>
<td width="278" valign="top">OrderBy, ThenBy</td>
</tr>
<tr>
<td width="297" valign="top">orderby clause with descending</td>
<td width="278" valign="top">OrderByDescending, ThenByDescending</td>
</tr>
<tr>
<td width="297" valign="top">group clause</td>
<td width="278" valign="top">GroupBy</td>
</tr>
<tr>
<td width="297" valign="top">into with continuation</td>
<td width="278" valign="top">Nested query</td>
</tr>
</tbody>
</table>
<h1>Sequence queries</h1>
<h2>Generation</h2>
<p>Enumerable type’s Empty , Range, Repeat methods can generate an IEnumerable&lt;T&gt; sequence. They are just normal static methods instead of extension methods:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Linq
{
    </span><span style="color: blue;">public static class </span><span style="color: #2b91af;">Enumerable
    </span><span style="color: black;">{
        </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Empty&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;();

        </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; Range(</span><span style="color: blue;">int </span><span style="color: black;">start, </span><span style="color: blue;">int </span><span style="color: black;">count);

        </span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Repeat&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">TResult </span><span style="color: black;">element, </span><span style="color: blue;">int </span><span style="color: black;">count);
    }
}</span></pre>
<p>Empty just generates an IEnumerable&lt;T&gt; sequence, which contains no value:</p>
<pre class="code"><span style="color: blue;">internal static partial class </span><span style="color: #2b91af;">QueryMethods
</span><span style="color: black;">{
    </span><span style="color: blue;">internal static void </span><span style="color: black;">Empty()
    {
        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; empty = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;(); </span><span style="color: green;">// Define query.
        </span><span style="color: blue;">int </span><span style="color: black;">count = 0;
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">string </span><span style="color: black;">result </span><span style="color: blue;">in </span><span style="color: black;">empty) </span><span style="color: green;">// Execute query by pulling the results.
        </span><span style="color: black;">{
            count++; </span><span style="color: green;">// Not executed.
        </span><span style="color: black;">}
        count.WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: black;">}
}</span></pre>
<p>Range generates an int sequence with the specified initial int value and range:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Range()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; range = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(-1, 5); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">range.WriteLines(); </span><span style="color: green;">// Execute query. -1 0 1 2 3
    // Equivalent to:
    // foreach (int int32 in range)
    // {
    //    int32.WriteLine();
    // }
</span><span style="color: black;">}</span></pre>
<p>The following example creates a sequence with large number of int values:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">MaxRange()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; range = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(1</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue); </span><span style="color: green;">// Define query.
</span><span style="color: black;">}</span></pre>
<p>As just mentioned, calling above MaxRange just defines a query. A large sequence is created, but each actual value in the large sequence is not generated.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Repeat()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; repeat = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Repeat(</span><span style="color: #a31515;">"*"</span><span style="color: black;">, 5); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">repeat.WriteLines(); </span><span style="color: green;">// Execute query. * * * * *
</span><span style="color: black;">}</span></pre>
<p>DefaultIfEmpty generates a sequence based on the source sequence. If the source sequence is not empty, the returned sequence contains the same values from the source sequence. If the source sequence is empty, the returned sequence contains a single value, which is the default value of TSource type:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; DefaultIfEmpty&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>The other overload of DefaultIfEmpty allows to specify what default value to use if the source sequence is empty:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; DefaultIfEmpty&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">defaultValue);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">DefaultIfEmpty()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; souce = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; singletonIfEmpty = souce.DefaultIfEmpty(); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">singletonIfEmpty.WriteLines(); </span><span style="color: green;">// Execute query: 0
</span><span style="color: black;">}

</span><span style="color: blue;">internal static void </span><span style="color: black;">DefaultIfEmptyWithDefaultValue()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; souce = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; singletonIfEmpty = souce.DefaultIfEmpty(1);
    singletonIfEmpty.WriteLines(); </span><span style="color: green;">// Execute query. 1
</span><span style="color: black;">}</span></pre>
<p>DefaultIfEmpty is also commonly used in left outer join, which will be discussed later.</p>
<h2>Filtering (restriction)</h2>
<p>As demonstrated earlier, Where filters the values in the source sequence:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; Where&lt;TSource&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, <span style="color: blue;">bool</span>&gt; predicate);</pre>
<p>The other predicate parameter is a callback function. When the query is executed, predicate is called with each value in the source sequence, and return a bool value. If true is returned, this value is in the query result sequence; if false is returned, this value is filtered out. For example, the following query filters all types in .NET core library to get all primitive type:</p>
<pre class="code"><span style="color: blue;">private static readonly </span><span style="color: #2b91af;">Assembly </span><span style="color: black;">CoreLibrary = </span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: blue;">object</span><span style="color: black;">).Assembly;

</span><span style="color: blue;">internal static void </span><span style="color: black;">Where()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; source = CoreLibrary.GetExportedTypes();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; primitives = source.Where(type =&gt; type.IsPrimitive); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">primitives.WriteLines(); </span><span style="color: green;">// Execute query. System.Boolean System.Byte System.Char System.Double ...
</span><span style="color: black;">}</span></pre>
<p>And the equivalent query expression has a where clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Where()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; source = CoreLibrary.GetExportedTypes();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; primitives = </span><span style="color: blue;">from </span><span style="color: black;">type </span><span style="color: blue;">in </span><span style="color: black;">source
                                   </span><span style="color: blue;">where </span><span style="color: black;">type.IsPrimitive
                                   </span><span style="color: blue;">select </span><span style="color: black;">type;
}</span></pre>
<p>The other overload of Where has a indexed predicate function:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; Where&lt;TSource&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, <span style="color: blue;">int</span>, <span style="color: blue;">bool</span>&gt; predicate);</pre>
<p>Here each time predicate is called with 2 parameters, the current value in source sequence, and the current value’s index in source sequence. For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">WhereWithIndex()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: #a31515;">"zero"</span><span style="color: black;">, </span><span style="color: #a31515;">"one"</span><span style="color: black;">, </span><span style="color: #a31515;">"two"</span><span style="color: black;">, </span><span style="color: #a31515;">"three"</span><span style="color: black;">, </span><span style="color: #a31515;">"four" </span><span style="color: black;">};
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; even = source.Where((value, index) =&gt; index % 2 == 0); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">even.WriteLines(); </span><span style="color: green;">// Execute query. zero two four
</span><span style="color: black;">}</span></pre>
<p>The indexed Where overload is not supported in query expression syntax.</p>
<p>The other filtering query method is OfType. It filters values by type:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OfType()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new object</span><span style="color: black;">[] { 1, 2, </span><span style="color: #a31515;">'a'</span><span style="color: black;">, </span><span style="color: #a31515;">'b'</span><span style="color: black;">, </span><span style="color: #a31515;">"aa"</span><span style="color: black;">, </span><span style="color: #a31515;">"bb"</span><span style="color: black;">, </span><span style="color: blue;">new object</span><span style="color: black;">() };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; strings = source.OfType&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;();  </span><span style="color: green;">// Define query.
    </span><span style="color: black;">strings.WriteLines(); </span><span style="color: green;">// Execute query. aa bb
</span><span style="color: black;">}</span></pre>
<p>OfType is not supported in query expression either.</p>
<h2>Mapping (projection)</h2>
<p>Similar to Where, Select has 2 overloads:</p>
<pre class="code"><span style="color: #2b91af;">IEnumerable</span>&lt;TResult&gt; Select&lt;TSource, TResult&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TResult&gt; selector);

<span style="color: #2b91af;">IEnumerable</span>&lt;TResult&gt; Select&lt;TSource, TResult&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, <span style="color: blue;">int</span>, TResult&gt; selector);</pre>
<p>When the query is executed, the selector function is called with each TSource value, and map it to a TResult result in the returned sequence. And in the indexed overload, selector is also called with TSource value’s index. For example, the following Select query maps each integer to a formatted string representing the integer’s square root:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Select()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(0, 5);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; squareRoots = source.Select(int32 =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{</span><span style="color: #2b91af;">Math</span><span style="color: black;">.Sqrt(int32):</span><span style="color: #a31515;">0.00</span><span style="color: black;">}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">squareRoots.WriteLines(); </span><span style="color: green;">// Execute query. 0.00 1.00 1.41 1.73 2.00
</span><span style="color: black;">}</span></pre>
<p>The equivalent query expression is a select clause with a single from clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Select()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(0, 5);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; squareRoots = </span><span style="color: blue;">from </span><span style="color: black;">int32 </span><span style="color: blue;">in </span><span style="color: black;">source
                                      </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{</span><span style="color: #2b91af;">Math</span><span style="color: black;">.Sqrt(int32)</span><span style="color: #3cb371;">:0.00</span><span style="color: black;">}</span><span style="color: #a31515;">"</span><span style="color: black;">;</span><span style="color: black;">
}</span></pre>
<p>Query expression must end with either a select clause, or group clause (will be discussed below). If there are other clauses between the starting from clause and the ending select clause, and the ending select clause simply has the value from the source sequencce, then that ending select clause is ignored and is not compiled to a Select query method call. Above where query expression is such an example.</p>
<p>The following is an example of the indexed overload:</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; Words() =&gt; </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: #a31515;">"Zero"</span><span style="color: black;">, </span><span style="color: #a31515;">"one"</span><span style="color: black;">, </span><span style="color: #a31515;">"Two"</span><span style="color: black;">, </span><span style="color: #a31515;">"three"</span><span style="color: black;">, </span><span style="color: #a31515;">"four" </span><span style="color: black;">};

[</span><span style="color: #2b91af;">SuppressMessage</span><span style="color: black;">(</span><span style="color: #a31515;">"Microsoft.Globalization"</span><span style="color: black;">, </span><span style="color: #a31515;">"CA1308:NormalizeStringsToUppercase"</span><span style="color: black;">)]
</span><span style="color: blue;">internal static void </span><span style="color: black;">SelectWithIndex()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = Words();
    </span><span style="color: blue;">var </span><span style="color: black;">mapped = source.Select((value, index) =&gt; </span><span style="color: blue;">new
    </span><span style="color: black;">{
        Index = index,
        Word = value.ToLowerInvariant()
    }); </span><span style="color: green;">// Define query: IEnumerable&lt;(string Word, int Index)&gt;
    </span><span style="color: black;">mapped.WriteLines(result =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{result.Index}</span><span style="color: #a31515;">:</span><span style="color: black;">{result.Word}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Execute query.
    // 0:zero 1:one 2:two 3:three 4:four
</span><span style="color: black;">}</span></pre>
<p>Here selector returns anonymous type. As a result, Select returns a sequence of anonymous type, and var has to be used.</p>
<p>As discussed in the Functional Programming chapter, let clause is also compiled to Select query with a selector function returning anonymous type:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Let()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(-2, 5);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; absoluteValues = </span><span style="color: blue;">from </span><span style="color: black;">int32 </span><span style="color: blue;">in </span><span style="color: black;">source
                                         </span><span style="color: blue;">let </span><span style="color: black;">abs = </span><span style="color: #2b91af;">Math</span><span style="color: black;">.Abs(int32)
                                         </span><span style="color: blue;">where </span><span style="color: black;">abs &gt; 0
                                         </span><span style="color: blue;">select </span><span style="color: #a31515;">$"Math.Abs(</span><span style="color: black;">{int32}</span><span style="color: #a31515;">) == </span><span style="color: black;">{abs}</span><span style="color: #a31515;">"</span><span style="color: black;">;
</span><span style="color: black;">}</span></pre>
<p>The compiled Select query returns a (int int32, int abs) anonymous type:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CompiledLet()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(-2, 5);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; absoluteValues = source
        .Select(int32 =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ int32 = int32, abs = </span><span style="color: #2b91af;">Math</span><span style="color: black;">.Abs(int32) })
        .Where(anonymous =&gt; anonymous.abs &gt; 0)
        .Select(anonymous =&gt; </span><span style="color: #a31515;">$"Math.Abs(</span><span style="color: black;">{anonymous.int32}</span><span style="color: #a31515;">):</span><span style="color: black;">{anonymous.abs}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">absoluteValues.WriteLines(); </span><span style="color: green;">// Execute query.
    // Math.Abs(-2):2 Math.Abs(-1):1 Math.Abs(1):1 Math.Abs(2):2
</span><span style="color: black;">}</span></pre>
<p>SelectMany has 4 overloads. Similar to Where and Select, the following 2 overloads accept unindexed and indexed selector:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selector);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;&gt; selector);</span></pre>
<p>In contrast with Select, SelectMany’s selector is a one to many mapping. If there are N values from the source sequence, then they are mapped to N sequences. And eventually, SelectMany concatenates these N sequences into one single sequence. The following example calls SelectMany to query all members of all types in .NET core library, then filter the obsolete members (members with [Obsolete]):</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">MemberInfo</span><span style="color: black;">[] GetDeclaredMembers(</span><span style="color: blue;">this </span><span style="color: #2b91af;">Type </span><span style="color: black;">type) =&gt;
    type.GetMembers(
        </span><span style="color: #2b91af;">BindingFlags</span><span style="color: black;">.Public | </span><span style="color: #2b91af;">BindingFlags</span><span style="color: black;">.Static | </span><span style="color: #2b91af;">BindingFlags</span><span style="color: black;">.Instance | </span><span style="color: #2b91af;">BindingFlags</span><span style="color: black;">.DeclaredOnly);

</span><span style="color: blue;">internal static bool </span><span style="color: black;">IsObsolete(</span><span style="color: blue;">this </span><span style="color: #2b91af;">MemberInfo </span><span style="color: black;">member) =&gt;
    member.IsDefined(attributeType: </span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: #2b91af;">ObsoleteAttribute</span><span style="color: black;">), inherit: </span><span style="color: blue;">false</span><span style="color: black;">);

</span><span style="color: blue;">internal static void </span><span style="color: black;">SelectMany()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; source = CoreLibrary.GetExportedTypes();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">MemberInfo</span><span style="color: black;">&gt; oneToManymapped = source.SelectMany(type =&gt; type.GetDeclaredMembers()); </span><span style="color: green;">// Define query.
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">MemberInfo</span><span style="color: black;">&gt; filtered = oneToManymapped.Where(member =&gt; member.IsObsolete()); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">filtered.WriteLines(obsoleteMember =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{obsoleteMember.DeclaringType}</span><span style="color: #a31515;">:</span><span style="color: black;">{obsoleteMember}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Execute query.
    // Equivalent to:
    // foreach (MemberInfo obsoleteMember in filtered)
    // {
    //    Trace.WriteLine($"{obsoleteMember.DeclaringType}:{obsoleteMember}");
    // }
    // ...
    // System.Enum:System.String ToString(System.String, System.IFormatProvider)
    // System.Enum:System.String ToString(System.IFormatProvider)
    // ...
</span><span style="color: black;">}</span></pre>
<p>Apparently, the above SelectMany, Where, and&nbsp; are both extension methods for IEnumerable&lt;T&gt;, and they both return IEnumerable&lt;T&gt;, so that above LINQ query can be fluent, as expected:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">FluentSelectMany()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">MemberInfo</span><span style="color: black;">&gt; mappedAndFiltered = CoreLibrary
        .GetExportedTypes()
        .SelectMany(type =&gt; type.GetDeclaredMembers())
        .Where(member =&gt; member.IsObsolete()); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">mappedAndFiltered.WriteLines(obsoleteMember =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{obsoleteMember.DeclaringType}</span><span style="color: #a31515;">:</span><span style="color: black;">{obsoleteMember}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Execute query.
</span><span style="color: black;">}</span></pre>
<p>And the equivalent query expression has 2 from clauses:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SelectMany()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">MemberInfo</span><span style="color: black;">&gt; mappedAndFiltered =
        </span><span style="color: blue;">from </span><span style="color: black;">type </span><span style="color: blue;">in </span><span style="color: black;">CoreLibrary.GetExportedTypes()
        </span><span style="color: blue;">from </span><span style="color: black;">member </span><span style="color: blue;">in </span><span style="color: black;">type.GetPublicDeclaredMembers()
        </span><span style="color: blue;">where </span><span style="color: black;">member.IsObsolete()
        </span><span style="color: blue;">select </span><span style="color: black;">member;</span><span style="color: black;">
}</span></pre>
<p>Generally, SelectMany can flatten a hierarchical 2-level-sequence into a flat 1-level-sequence. In these examples, the source sequence is hierarchical – it has many types, and each type can have a sequence of many members. SelectMany flattens the hierarchy, and concatenates many sequences of members into a single sequence of members.</p>
<p>The other 2 SelectMany overloads accept 2 selector functions:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TCollection</span><span style="color: black;">&gt;&gt; collectionSelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; SelectMany&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TCollection</span><span style="color: black;">&gt;&gt; collectionSelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TCollection</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector);</span></pre>
<p>They accept 2 selector functions. The collection selector (non indexed and index) maps source sequence’s each TSource value to many TCollection values (a IEnumerable&lt;TCollection&gt; sequence), and the result selector maps each TCollection value and its original TSource value to a TResult value. So eventually they still return a sequence of TResult values. For example, the following example use result selector to map type and member to string representation:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SelectManyWithResultSelector()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; source = CoreLibrary.GetExportedTypes();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; obsoleteMembers = source</span><span style="color: green;">
        </span><span style="color: black;">.SelectMany(
            collectionSelector: type =&gt; type.GetDeclaredMembers(),
            resultSelector: (type, member) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Type = type, Member = member })
        .Where(typeAndMember =&gt; typeAndMember.Member.IsObsolete())
        .Select(typeAndMember =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{typeAndMember.Type}</span><span style="color: #a31515;">:</span><span style="color: black;">{typeAndMember.Member}</span><span style="color: #a31515;">"</span><span style="color: black;">);
}</span></pre>
<p>The equivalent query expression has 2 from clauses for the SelectMany query, a where clause for Where, and 1 select query for Select:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SelectManyWithResultSelector()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; source = CoreLibrary.GetExportedTypes();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; obsoleteMembers =
        </span><span style="color: blue;">from </span><span style="color: black;">type </span><span style="color: blue;">in </span><span style="color: black;">source
        </span><span style="color: blue;">from </span><span style="color: black;">member </span><span style="color: blue;">in </span><span style="color: black;">type.GetDeclaredMembers()
        </span><span style="color: blue;">where </span><span style="color: black;">member.IsObsolete()
        </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{type}</span><span style="color: #a31515;">:</span><span style="color: black;">{member}</span><span style="color: #a31515;">"</span><span style="color: black;">;
}</span></pre>
<p>The collection selector function returns a sequence, which can be queried too. Here the Where query logically filters the obsolete member can be equivalently applied to the collection selector, which is called a subquery:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SelectManyWithResultSelectorAndSubquery()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; source = CoreLibrary.GetExportedTypes();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; obsoleteMembers = source.SelectMany(
        collectionSelector: type =&gt; type.GetDeclaredMembers().Where(member =&gt; member.IsObsolete()),
        resultSelector: (type, obsoleteMember) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{type}</span><span style="color: #a31515;">:</span><span style="color: black;">{obsoleteMember}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">obsoleteMembers.WriteLines(); </span><span style="color: green;">// Execute query.
</span><span style="color: black;">}</span></pre>
<p>The equivalent query expression has a sub query expression for Where:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SelectManyWithResultSelectorAndSubquery()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; source = CoreLibrary.GetExportedTypes();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; obsoleteMembers =
        </span><span style="color: blue;">from </span><span style="color: black;">type </span><span style="color: blue;">in </span><span style="color: black;">source
        </span><span style="color: blue;">from </span><span style="color: black;">obsoleteMember </span><span style="color: blue;">in </span><span style="color: black;">(</span><span style="color: blue;">from </span><span style="color: black;">member </span><span style="color: blue;">in </span><span style="color: black;">type.GetDeclaredMembers()
                                </span><span style="color: blue;">where </span><span style="color: black;">member.IsObsolete()
                                </span><span style="color: blue;">select </span><span style="color: black;">member)
        </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{type}</span><span style="color: #a31515;">:</span><span style="color: black;">{obsoleteMember}</span><span style="color: #a31515;">"</span><span style="color: black;">; </span><span style="color: green;">// Define query.
    </span><span style="color: black;">obsoleteMembers.WriteLines(); </span><span style="color: green;">// Execute query.
</span><span style="color: black;">}</span></pre>
<p>SelectMany is a very powerful query method, and the multiple from clauses is also a powerful syntax to build a functional workflow. This will be discussed in the Category Theory chapter.</p>
<h2>Grouping</h2>
<p>The GroupBy method has 8 overloads. The minimum requirement is to specified a key selector function, which is called with each value in the source sequence, and return a key:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector);</span></pre>
<p>Each value from he source sequence is mapped to a key by calling the keys elector. If 2 keys are equal, these 2 source values are in the same group. Take the following persons as example:</p>
<pre class="code"><span style="color: blue;">internal class </span><span style="color: #2b91af;">Person
</span><span style="color: black;">{
    </span><span style="color: blue;">internal </span><span style="color: black;">Person(</span><span style="color: blue;">string </span><span style="color: black;">name, </span><span style="color: blue;">string </span><span style="color: black;">placeOfBirth)
    {
        </span><span style="color: blue;">this</span><span style="color: black;">.Name = name;
        </span><span style="color: blue;">this</span><span style="color: black;">.PlaceOfBirth = placeOfBirth;
    }

    </span><span style="color: blue;">internal string </span><span style="color: black;">Name { </span><span style="color: blue;">get</span><span style="color: black;">; }

    </span><span style="color: blue;">internal string </span><span style="color: black;">PlaceOfBirth { </span><span style="color: blue;">get</span><span style="color: black;">; }
}

</span><span style="color: blue;">internal static partial class </span><span style="color: #2b91af;">QueryMethods
</span><span style="color: black;">{
    </span><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; Persons() =&gt; </span><span style="color: blue;">new </span><span style="color: #2b91af;">Person</span><span style="color: black;">[]
    {
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Person</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Robert Downey Jr."</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"US"</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Person</span><span style="color: black;">(name:  </span><span style="color: #a31515;">"Tom Hiddleston"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"UK"</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Person</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Chris Hemsworth"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"AU"</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Person</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Chris Evans"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"US"</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Person</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Paul Bettany"</span><span style="color: black;">, placeOfBirth:  </span><span style="color: #a31515;">"UK"</span><span style="color: black;">)
    };
}</span></pre>
<p>These Person instances represents actors of <a href="https://en.wikipedia.org/wiki/Marvel_Cinematic_Universe" target="_blank">Marvel Cinematic Universe</a>. They can be simply grouped by their place of birth:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupBy()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt;&gt; groups = source.GroupBy(person =&gt; person.PlaceOfBirth); </span><span style="color: green;">// Define query.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; group </span><span style="color: blue;">in </span><span style="color: black;">groups) </span><span style="color: green;">// Execute query.
    </span><span style="color: black;">{
        </span><span style="color: #a31515;">$"</span><span style="color: black;">{group.Key}</span><span style="color: #a31515;">: "</span><span style="color: black;">.Write();
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">Person </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">group)
        {
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.Name}</span><span style="color: #a31515;">, "</span><span style="color: black;">.Write();
        }
        </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
    }
    </span><span style="color: green;">// US: Robert Downey Jr., Chris Evans,
    // UK: Tom Hiddleston, Paul Bettany,
    // AU: Chris Hemsworth,
</span><span style="color: black;">}</span></pre>
<p>GroupBy returns IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;. The following is the definition of IGrouping&lt;TKey, TElement&gt; interface:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Linq
{
</span><span style="color: green;">    </span><span style="color: blue;">public interface </span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">out </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: blue;">out </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">IEnumerable
    </span><span style="color: black;">{</span><span style="color: green;">
        </span><span style="color: #2b91af;">TKey </span><span style="color: black;">Key { </span><span style="color: blue;">get</span><span style="color: black;">; }
    }
}</span></pre>
<p>It is just an IEnumerable&lt;T&gt; sequence with an additional Key property. So, above GroupBy returns a hierarchical sequence. It is a sequence of groups, where each group is a sequence of values. The equivalent query expression is a group clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupBy()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt;&gt; groups = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                                    </span><span style="color: blue;">group </span><span style="color: black;">person </span><span style="color: blue;">by </span><span style="color: black;">person.PlaceOfBirth;</span><span style="color: black;">
}</span></pre>
<p>GroupBy can also accepts a result selector function to map each group and its key to a result in the returned sequence:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector);</span></pre>
<p>This overload, does not return of hierarchical sequence of groups, but flattened sequence of result values:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByWithResultSelector()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; groups = source
        .GroupBy(
            keySelector: person =&gt; person.PlaceOfBirth,
            resultSelector: (key, group) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{key}</span><span style="color: #a31515;">:</span><span style="color: black;">{group.Count()}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">groups.WriteLines(); </span><span style="color: green;">// Execute query. US:2 UK:2 AU:1
</span><span style="color: black;">}</span></pre>
<p>This overload is directly not supported by query expression. However, its result selector can be equivalently applied with an additional Select query:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByAndSelect()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt;&gt; groups = source.GroupBy(person =&gt; person.PlaceOfBirth);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; mapped = groups.Select(group =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{group.Key}</span><span style="color: #a31515;">: </span><span style="color: black;">{group.Count()}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">groups.WriteLines(); </span><span style="color: green;">// Execute query. US:2 UK:2 AU:1
</span><span style="color: black;">}</span></pre>
<p>As just demonstrated, this GroupBy overload is equivalent to query expression with a group clause, and Select can be compiled from a select clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByAndSelect()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt;&gt; groups = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                                    </span><span style="color: blue;">group </span><span style="color: black;">person </span><span style="color: blue;">by </span><span style="color: black;">person.PlaceOfBirth;
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; mapped = </span><span style="color: blue;">from </span><span style="color: black;">@group </span><span style="color: blue;">in </span><span style="color: black;">groups
                                 </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{@group.Key}</span><span style="color: #a31515;">: </span><span style="color: black;"><a href="mailto:{@group.Count">{@group.Count</a>()}</span><span style="color: #a31515;">"</span><span style="color: black;">;</span><span style="color: black;">
}</span></pre>
<p>Here @ is prepended to the @group identifier, because group is a query keyword. By removing the groups variable, the first query expression becomes the second query expression’s subquery:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">FluentGroupByAndSelect()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; mapped = </span><span style="color: blue;">from </span><span style="color: black;">@group </span><span style="color: blue;">in </span><span style="color: black;">(</span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                                 </span><span style="color: blue;">group </span><span style="color: black;">person </span><span style="color: blue;">by </span><span style="color: black;">person.PlaceOfBirth)
                                 </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{@group.Key}</span><span style="color: #a31515;">: </span><span style="color: black;"><a href="mailto:{@group.Count">{@group.Count</a>()}</span><span style="color: #a31515;">"</span><span style="color: black;">;
}</span></pre>
<p>The above expression is nested rather than fluent. So a into query keyword is provided for continuation like this:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByAndSelectWithInto()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; mapped = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                 </span><span style="color: blue;">group </span><span style="color: black;">person </span><span style="color: blue;">by </span><span style="color: black;">person.PlaceOfBirth </span><span style="color: blue;">into </span><span style="color: black;">@group
                                 </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{@group.Key}</span><span style="color: #a31515;">: </span><span style="color: black;">{@group.Count()}</span><span style="color: #a31515;">"</span><span style="color: black;">;
</span><span style="color: black;">}</span></pre>
<p>The compilation of the above 2 query expressions are identical.</p>
<p>GroupBy can also accept an element selector function to map each value in he source sequence in the source sequence to a result value in the group:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByWithElementSelector()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt; groups = source
        .GroupBy(
            keySelector: person =&gt; person.PlaceOfBirth,
            elementSelector: person =&gt; person.Name); </span><span style="color: green;">// Define query.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt; group </span><span style="color: blue;">in </span><span style="color: black;">groups) </span><span style="color: green;">// Execute query.
    </span><span style="color: black;">{
        </span><span style="color: #a31515;">$"</span><span style="color: black;">{group.Key}</span><span style="color: #a31515;">: "</span><span style="color: black;">.Write();
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">string </span><span style="color: black;">name </span><span style="color: blue;">in </span><span style="color: black;">group)
        {
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{name}</span><span style="color: #a31515;">, "</span><span style="color: black;">.Write();
        }
        </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
    }
    </span><span style="color: green;">// US: Robert Downey Jr., Chris Evans,
    // UK: Tom Hiddleston, Paul Bettany,
    // AU: Chris Hemsworth,
</span><span style="color: black;">}</span></pre>
<p>In query expression, the element selector can be specified after the group keyword:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByWithElementSelector()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt;&gt; groups = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                                    </span><span style="color: blue;">group </span><span style="color: black;">person.Name </span><span style="color: blue;">by </span><span style="color: black;">person.PlaceOfBirth;
</span><span style="color: black;">}</span></pre>
<p>And element selector can be used with result selector:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector);</span></pre>
<p>Again, result selector can flatten the hierarchical sequence:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByWithElementAndResultSelector()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; groups = source.GroupBy(
        keySelector: person =&gt; person.PlaceOfBirth,
        elementSelector: person =&gt; person.Name,
        resultSelector: (key, group) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{key}</span><span style="color: #a31515;">: </span><span style="color: black;">{</span><span style="color: blue;">string</span><span style="color: black;">.Join(</span><span style="color: #a31515;">", "</span><span style="color: black;">, group)}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">groups.WriteLines(); </span><span style="color: green;">// Execute query.
    // US: Robert Downey Jr., Chris Evans
    // UK: Tom Hiddleston, Paul Bettany
    // AU: Chris Hemsworth
</span><span style="color: black;">}</span></pre>
<p>Similar to SelectMany, GroupBy with both element selector and result selector is not directly supported in query expression. The result selector logic can be done with a select continuation:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByWithElementSelectorAndSelect()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; groups = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                 </span><span style="color: blue;">group </span><span style="color: black;">person.Name </span><span style="color: blue;">by </span><span style="color: black;">person.PlaceOfBirth </span><span style="color: blue;">into </span><span style="color: black;">@group
                                 </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{@group.Key}</span><span style="color: #a31515;">: </span><span style="color: black;">{</span><span style="color: blue;">string</span><span style="color: black;">.Join(</span><span style="color: #a31515;">","</span><span style="color: black;">, @group)}</span><span style="color: #a31515;">"</span><span style="color: black;">;</span><span style="color: black;">
}</span></pre>
<p>The rest 4 overloads accept an IEqualityComparer&lt;TKey&gt; interface:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; GroupBy&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);</span></pre>
<p>IEqualityComparer&lt;TKey&gt; provides the methods to determine whether 2 keys are equal when grouping all keys:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Collections.Generic
{
</span><span style="color: green;">    </span><span style="color: blue;">public interface </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: blue;">in </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
    {
</span><span style="color: green;">        </span><span style="color: blue;">bool </span><span style="color: black;">Equals(</span><span style="color: #2b91af;">T </span><span style="color: black;">x, </span><span style="color: #2b91af;">T </span><span style="color: black;">y);
</span><span style="color: green;">
        </span><span style="color: blue;">int </span><span style="color: black;">GetHashCode(</span><span style="color: #2b91af;">T </span><span style="color: black;">obj);
    }
}</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">GroupByWithEqualityComparer()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; groups = source.GroupBy(
        keySelector: person =&gt; person.PlaceOfBirth,
        elementSelector: person =&gt; person.Name,
        resultSelector: (key, group) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{key}</span><span style="color: #a31515;">:</span><span style="color: black;">{</span><span style="color: blue;">string</span><span style="color: black;">.Join(</span><span style="color: #a31515;">","</span><span style="color: black;">, group)}</span><span style="color: #a31515;">"</span><span style="color: black;">,
        comparer: </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">groups.WriteLines(); </span><span style="color: green;">// Execute query. US:2 UK: 2 AU: 1
</span><span style="color: black;">}</span></pre>
<p>These 4 overloads is not supported by query expression.</p>
<h2>Join</h2>
<h3>Inner join</h3>
<p>Join is designed for <a href="http://en.wikipedia.org/wiki/Inner_join#Inner_join" target="_blank" mce_href="http://en.wikipedia.org/wiki/Inner_join#Inner_join">inner join</a>:</p>
<pre class="code"><span style="color: #2b91af;">IEnumerable</span>&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TOuter&gt; outer, <span style="color: #2b91af;">IEnumerable</span>&lt;TInner&gt; inner,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, TKey&gt; outerKeySelector, <span style="color: #2b91af;">Func</span>&lt;TInner, TKey&gt; innerKeySelector,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, TInner, TResult&gt; resultSelector)

<span style="color: #2b91af;">IEnumerable</span>&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TOuter&gt; outer, <span style="color: #2b91af;">IEnumerable</span>&lt;TInner&gt; inner,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, TKey&gt; outerKeySelector, <span style="color: #2b91af;">Func</span>&lt;TInner, TKey&gt; innerKeySelector,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, TInner, TResult&gt; resultSelector,
    <span style="color: #2b91af;">IEqualityComparer</span>&lt;TKey&gt; comparer)</pre>
<p>Each outer value from the outer source is mapped to an outer key by calling the outer key selector, and each inner value from the inner source is mapped to an inner key. When a outer key is equal to an inner key, the source outer value and the matching source inner value are paired, and mapped to a result by calling the result selector. So each outer value with a matching inner value is mapped to a result in the returned sequence, and each outer value without a matching inner value is ignored. Take the following characters as example:</p>
<pre class="code"><span style="color: blue;">internal partial class </span><span style="color: #2b91af;">Character
</span><span style="color: black;">{
    </span><span style="color: blue;">internal </span><span style="color: black;">Character(</span><span style="color: blue;">string </span><span style="color: black;">name, </span><span style="color: blue;">string </span><span style="color: black;">placeOfBirth, </span><span style="color: blue;">string </span><span style="color: black;">starring)
    {
        </span><span style="color: blue;">this</span><span style="color: black;">.Name = name;
        </span><span style="color: blue;">this</span><span style="color: black;">.PlaceOfBirth = placeOfBirth;
        </span><span style="color: blue;">this</span><span style="color: black;">.Starring = starring;
    }

    </span><span style="color: blue;">internal string </span><span style="color: black;">Name { </span><span style="color: blue;">get</span><span style="color: black;">; }

    </span><span style="color: blue;">internal string </span><span style="color: black;">PlaceOfBirth { </span><span style="color: blue;">get</span><span style="color: black;">; }

    </span><span style="color: blue;">internal string </span><span style="color: black;">Starring { </span><span style="color: blue;">get</span><span style="color: black;">; }
}

</span><span style="color: blue;">internal static partial class </span><span style="color: #2b91af;">QueryMethods
</span><span style="color: black;">{
    </span><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; Characters() =&gt; </span><span style="color: blue;">new </span><span style="color: #2b91af;">Character</span><span style="color: black;">[]
    {
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Character</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Tony Stark"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"US"</span><span style="color: black;">, starring: </span><span style="color: #a31515;">"Robert Downey Jr."</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Character</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Thor"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"Asgard"</span><span style="color: black;">, starring: </span><span style="color: #a31515;">"Chris Hemsworth"</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Character</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Steve Rogers"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"US"</span><span style="color: black;">, starring: </span><span style="color: #a31515;">"Chris Evans"</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Character</span><span style="color: black;">(name: </span><span style="color: #a31515;">"Vision"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"KR"</span><span style="color: black;">, starring: </span><span style="color: #a31515;">"Paul Bettany"</span><span style="color: black;">),
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Character</span><span style="color: black;">(name: </span><span style="color: #a31515;">"JARVIS"</span><span style="color: black;">, placeOfBirth: </span><span style="color: #a31515;">"US"</span><span style="color: black;">, starring: </span><span style="color: #a31515;">"Paul Bettany"</span><span style="color: black;">)
    };
}</span></pre>
<p>These Character instances represents characters in the movie <a href="https://en.wikipedia.org/wiki/Avengers:_Age_of_Ultron" target="_blank">Avengers 2</a>, and can be joined with actors. When a character from outer sequence matches an actor from inner sequence by <a href="https://en.wikipedia.org/wiki/Avengers:_Age_of_Ultron#Cast" target="_blank">cast</a>, these 2 values are paired and mapped to the result sequence:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">InnerJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin = outer.Join(
        inner: inner,
        outerKeySelector: person =&gt; person.Name,
        innerKeySelector: character =&gt; character.Starring,</span><span style="color: green;">
        </span><span style="color: black;">resultSelector: (person, character) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{person.PlaceOfBirth}</span><span style="color: #a31515;">): </span><span style="color: black;">{character.Name}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">innerJoin.WriteLines(); </span><span style="color: green;">// Execute query.
    // Robert Downey Jr. (US): Tony Stark
    // Chris Hemsworth (AU): Thor
    // Chris Evans (US): Steve Rogers
    // Paul Bettany (UK): Vision
    // Paul Bettany (UK): JARVIS
</span><span style="color: black;">}</span></pre>
<p>In the inner join results, the name “Tom Hiddleston” does not exist in the results, because the person with this name cannot match with any character’s starring (<a href="https://en.wikipedia.org/wiki/Tom_Hiddleston" target="_blank">Tom Hiddleston</a> is the actor of <a href="https://en.wikipedia.org/wiki/Loki_(comics)" target="_blank">Loki</a>, who is in <a href="https://en.wikipedia.org/wiki/The_Avengers_(2012_film)" target="_blank">Avengers 1</a> but not in Avengers 2). And the name “Paul Bettany” appears twice in the results, because the person with this name matches 2 characters’ starring (<a href="https://en.wikipedia.org/wiki/Paul_Bettany" target="_blank">Paul Bettany</a> is the voice of <a href="https://en.wikipedia.org/wiki/Edwin_Jarvis#J.A.R.V.I.S." target="_blank">JARVIS</a> and the actor of <a href="https://en.wikipedia.org/wiki/Vision_(Marvel_Comics)" target="_blank">Vision</a>). The equivalent query expression has a join clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">InnerJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin =
        </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">outer
        </span><span style="color: blue;">join </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">inner </span><span style="color: blue;">on </span><span style="color: black;">person.Name </span><span style="color: blue;">equals </span><span style="color: black;">character.Starring
        </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{person.PlaceOfBirth}</span><span style="color: #a31515;">): </span><span style="color: black;">{character.Name}</span><span style="color: #a31515;">"</span><span style="color: black;">;
</span><span style="color: black;">}</span></pre>
<p>In the above example, the outer value and the inner value are matched with a single key - Person.Name property and Character.Starring property. To match with multiple keys, just have both outer key selector and inner key selector return the same anonymous type with multiple properties:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">InnerJoinWithMultipleKeys()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin = outer.Join(
        inner: inner,
        outerKeySelector: person =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Starring = person.Name, PlaceOfBirth = person.PlaceOfBirth },
        innerKeySelector: character =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Starring = character.Starring, PlaceOfBirth = character.PlaceOfBirth },</span><span style="color: green;">
        </span><span style="color: black;">resultSelector: (person, character) =&gt;
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{person.PlaceOfBirth}</span><span style="color: #a31515;">): </span><span style="color: black;">{character.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{character.PlaceOfBirth}</span><span style="color: #a31515;">)"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">innerJoin.WriteLines(); </span><span style="color: green;">// Execute query.
    // Robert Downey Jr. (US): Tony Stark (US)
    // Chris Evans (US): Steve Rogers (US)
</span><span style="color: black;">}</span></pre>
<p>Anonymous type can be also used with join clause in query expression:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">InnerJoinWithMultiKeys()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin =
        </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">outer
        </span><span style="color: blue;">join </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">inner
            </span><span style="color: blue;">on new </span><span style="color: black;">{ Starring = person.Name, PlaceOfBirth = person.PlaceOfBirth }
            </span><span style="color: blue;">equals new </span><span style="color: black;">{ Starring = character.Starring, PlaceOfBirth = character.PlaceOfBirth }
        </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{person.PlaceOfBirth}</span><span style="color: #a31515;">): </span><span style="color: black;">{character.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{character.PlaceOfBirth}</span><span style="color: #a31515;">)"</span><span style="color: black;">;
</span><span style="color: black;">}</span></pre>
<h3>Left outer join</h3>
<p>GroupJoin is designed for <a href="https://en.wikipedia.org/wiki/Join_(SQL)#Left_outer_join" target="_blank">left outer join</a>:</p>
<pre class="code"><span style="color: #2b91af;">IEnumerable</span>&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TOuter&gt; outer, <span style="color: #2b91af;">IEnumerable</span>&lt;TInner&gt; inner,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, TKey&gt; outerKeySelector, <span style="color: #2b91af;">Func</span>&lt;TInner, TKey&gt; innerKeySelector,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, <span style="color: #2b91af;">IEnumerable</span>&lt;TInner&gt;, TResult&gt; resultSelector)

<span style="color: #2b91af;">IEnumerable</span>&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TOuter&gt; outer, <span style="color: #2b91af;">IEnumerable</span>&lt;TInner&gt; inner,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, TKey&gt; outerKeySelector, <span style="color: #2b91af;">Func</span>&lt;TInner, TKey&gt; innerKeySelector,
    <span style="color: #2b91af;">Func</span>&lt;TOuter, <span style="color: #2b91af;">IEnumerable</span>&lt;TInner&gt;, TResult&gt; resultSelector,
    <span style="color: #2b91af;">IEqualityComparer</span>&lt;TKey&gt; comparer)</pre>
<p>Each outer value from the outer source is mapped to an outer key by calling the outer key selector, and each inner value from the inner source is mapped to an inner key. When a outer key is equal to zero, one, or more inner key, the source outer value and all the matching source inner values are paired, and mapped to a result by calling the result selector. So each outer value with or without matching inner values is mapped to a result in the returned sequence. It is called GroupJoin, because each outer value is paired with a group of matching inner values. If there is no matching inner values, the outer value is paired with an empty group:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LeftOuterJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: blue;">var </span><span style="color: black;">leftOuterJoin = outer.GroupJoin(
        inner: inner,
        outerKeySelector: person =&gt; person.Name,
        innerKeySelector: character =&gt; character.Starring,</span><span style="color: green;">
        </span><span style="color: black;">resultSelector: (person, charactersGroup) =&gt;
            </span><span style="color: blue;">new </span><span style="color: black;">{ Person = person, Characters = charactersGroup }); </span><span style="color: green;">// Define query.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">var </span><span style="color: black;">result </span><span style="color: blue;">in </span><span style="color: black;">leftOuterJoin) </span><span style="color: green;">// Execute query.
    </span><span style="color: black;">{
        </span><span style="color: #a31515;">$"</span><span style="color: black;">{result.Person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{result.Person.PlaceOfBirth}</span><span style="color: #a31515;">): "</span><span style="color: black;">.Write();
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">Character </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">result.Characters)
        {
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{character.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{character.PlaceOfBirth}</span><span style="color: #a31515;">), "</span><span style="color: black;">.Write();
        }
        </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
    }
    </span><span style="color: green;">// Robert Downey Jr. (US): Tony Stark (US),
    // Tom Hiddleston (UK):
    // Chris Hemsworth (AU): Thor (Asgard),
    // Chris Evans (US): Steve Rogers (US),
    // Paul Bettany (UK): Vision (KR), JARVIS (US),
</span><span style="color: black;">}</span></pre>
<p>Here result selector is called with each actor, and a group of matching characters, then it returns anonymous type consists of both the actor and the matching characters. So eventually GroupJoin returns a hierarchical sequence. In the results, the person with name “Tom Hiddleston” matches no character, so it is paired with an empty Character group, and each other person matches 1 or more characters, so is paired with a non-empty Character group. In query expression, GroupJoin is equivalent to join clause with the into keyword:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LeftOuterJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: blue;">var </span><span style="color: black;">leftOuterJoin =
        </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">outer
        </span><span style="color: blue;">join </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">inner </span><span style="color: blue;">on </span><span style="color: black;">person.Name </span><span style="color: blue;">equals </span><span style="color: black;">character.Starring </span><span style="color: blue;">into </span><span style="color: black;">charactersGroup
        </span><span style="color: blue;">select new </span><span style="color: black;">{ Person = person, Characters = charactersGroup };
</span><span style="color: black;">}</span></pre>
<p>In the join clause, into does not mean a continuation. it is a a part of the join.</p>
<p>The hierarchical sequence returned by GroupJoin can be flattened by SelectMany. In this kind of flatenning scenario, DefaultIfEmpty is usually used:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LeftOuterJoinWithDefaultIfEmpty()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: blue;">var </span><span style="color: black;">leftOuterJoin = outer
        .GroupJoin(
            inner: inner,
            outerKeySelector: person =&gt; person.Name,
            innerKeySelector: character =&gt; character.Starring,
            resultSelector: (person, charactersGroup) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Person = person, Characters = charactersGroup })
        .SelectMany(
            collectionSelector: group =&gt; group.Characters.DefaultIfEmpty(),
            resultSelector: (group, character) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Person = group.Person, Character = character }); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">leftOuterJoin.WriteLines(result =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{result.Person.Name}</span><span style="color: #a31515;">: </span><span style="color: black;">{result.Character?.Name}</span><span style="color: #a31515;">"</span><span style="color: black;">);
    </span><span style="color: green;">// Robert Downey Jr.: Tony Stark
    // Tom Hiddleston:
    // Chris Hemsworth: Thor
    // Chris Evans: Steve Rogers
    // Paul Bettany: Vision
    // Paul Bettany: JARVIS
</span><span style="color: black;">}</span></pre>
<p>Without the DefaultIfEmpty call, the second result “Tom Hiddleston” is ignored in the result sequence. The equivalent query expression has 2 from clauses for SelectMany:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LeftOuterJoinWithDefaultIfEmpty()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: blue;">var </span><span style="color: black;">leftOuterJoin =
        </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">outer
        </span><span style="color: blue;">join </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">inner </span><span style="color: blue;">on </span><span style="color: black;">person.Name </span><span style="color: blue;">equals </span><span style="color: black;">character.Starring </span><span style="color: blue;">into </span><span style="color: black;">charactersGroup
        </span><span style="color: blue;">from </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">charactersGroup.DefaultIfEmpty()
        </span><span style="color: blue;">select new </span><span style="color: black;">{ Person = person, Character = character };</span><span style="color: black;">
}</span></pre>
<p>There is already a from clause before join clause, so, just add one more from clause after join clause.</p>
<p>Left outer join can also implement by mapping each outer value with all filtered matching inner values:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LeftOuterJoinWithSelect()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: blue;">var </span><span style="color: black;">leftOuterJoin = outer.Select(person =&gt; </span><span style="color: blue;">new
    </span><span style="color: black;">{
        Person = person,
        Characters = inner.Where(character =&gt;
            </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;.Default.Equals(person.Name, character.Starring))
    }); </span><span style="color: green;">// Define query.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">var </span><span style="color: black;">result </span><span style="color: blue;">in </span><span style="color: black;">leftOuterJoin) </span><span style="color: green;">// Execute query.
    </span><span style="color: black;">{
        </span><span style="color: #a31515;">$"</span><span style="color: black;">{result.Person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{result.Person.PlaceOfBirth}</span><span style="color: #a31515;">): "</span><span style="color: black;">.Write();
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">Character </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">result.Characters)
        {
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{character.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{character.PlaceOfBirth}</span><span style="color: #a31515;">), "</span><span style="color: black;">.Write();
        }
        </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
    }
    </span><span style="color: green;">// Robert Downey Jr. (US): Tony Stark (US),
    // Tom Hiddleston (UK):
    // Chris Hemsworth (AU): Thor (Asgard),
    // Chris Evans (US): Steve Rogers (US),
    // Paul Bettany (UK): Vision (KR), JARVIS (US),
</span><span style="color: black;">}</span></pre>
<p>Notice here the Where subquery filters all inner values for each outer value. Generally, left outer join can be implemented with mapping query and filtering subquery:</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; LeftOuterJoinWithSelect&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    comparer = comparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;.Default;
    </span><span style="color: blue;">return </span><span style="color: black;">outer.Select(outerValue =&gt; resultSelector(
        outerValue,
        inner.Where(innerValue =&gt; comparer.Equals(outerKeySelector(outerValue), innerKeySelector(innerValue)))));
}</span></pre>
<p>In query expression, it just a simple query expression with a select clause containing a subquery with a where clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LeftOuterJoinWithSelect()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: blue;">var </span><span style="color: black;">leftOuterJoin =
        </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">outer
        </span><span style="color: blue;">select new
        </span><span style="color: black;">{
            Person = person,
            Characters = </span><span style="color: blue;">from </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">inner
                         </span><span style="color: blue;">where </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;.Default.Equals(person.Name, character.Starring)
                         </span><span style="color: blue;">select </span><span style="color: black;">character
        };
</span><span style="color: black;">}

</span><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; LeftOuterJoinWithSelect&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    comparer = comparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;.Default;
    </span><span style="color: blue;">return from </span><span style="color: black;">outerValue </span><span style="color: blue;">in </span><span style="color: black;">outer
           </span><span style="color: blue;">select </span><span style="color: black;">resultSelector(
                outerValue,
                (</span><span style="color: blue;">from </span><span style="color: black;">innerValue </span><span style="color: blue;">in </span><span style="color: black;">inner
                 </span><span style="color: blue;">where </span><span style="color: black;">comparer.Equals(outerKeySelector(outerValue), innerKeySelector(innerValue))
                 </span><span style="color: blue;">select </span><span style="color: black;">innerValue));
}</span></pre>
<p>The difference is, for N outer values, GroupJoin pull all inner values once and cache them, Select and Where does not cache anything and pull all inner values N times. The internal implementation of these query methods are discussed later in this chapter.</p>
<h3>Cross Join</h3>
<p><a href="https://en.wikipedia.org/wiki/Join_(SQL)#Cross_join" target="_blank">Cross join</a> 2 sequences is to return the <a href="https://en.wikipedia.org/wiki/Cartesian_product" target="_blank">Cartesian product</a> of values in those 2 sequences. The easiest way for cross join is SelectMany:</p>
<pre class="code"><span style="color: blue;">private static readonly int</span><span style="color: black;">[] rows = { 1, 2, 3 };

</span><span style="color: blue;">private static readonly string</span><span style="color: black;">[] columns = { </span><span style="color: #a31515;">"A"</span><span style="color: black;">, </span><span style="color: #a31515;">"B"</span><span style="color: black;">, </span><span style="color: #a31515;">"C"</span><span style="color: black;">, </span><span style="color: #a31515;">"D" </span><span style="color: black;">};

</span><span style="color: blue;">internal static void </span><span style="color: black;">CrossJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; cells = rows
        .SelectMany(row =&gt; columns, (row, column) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{column}{row}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.

    </span><span style="color: blue;">int </span><span style="color: black;">cellIndex = 0;
    </span><span style="color: blue;">int </span><span style="color: black;">columnCount = columns.Length;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">string </span><span style="color: black;">cell </span><span style="color: blue;">in </span><span style="color: black;">cells) </span><span style="color: green;">// Execute query.
    </span><span style="color: black;">{
        </span><span style="color: #a31515;">$"</span><span style="color: black;">{cell} </span><span style="color: #a31515;">"</span><span style="color: black;">.Write();
        </span><span style="color: blue;">if </span><span style="color: black;">(++cellIndex % columnCount == 0)
        {
            </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
        }
    }
    </span><span style="color: green;">// A1 B1 C1 D1
    // A2 B2 C2 D2
    // A3 B3 C3 D3
</span><span style="color: black;">}</span></pre>
<p>Notice here all inner values are pulled for each outer value. If outer sequence has N outer values, then the inner sequence are iterated N times. In query expression, as fore mentioned, 2 from clauses are compiled to SelectMany:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CrossJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; cells = </span><span style="color: blue;">from </span><span style="color: black;">row </span><span style="color: blue;">in </span><span style="color: black;">rows
                                </span><span style="color: blue;">from </span><span style="color: black;">column </span><span style="color: blue;">in </span><span style="color: black;">columns
                                </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{column}{row}</span><span style="color: #a31515;">"</span><span style="color: black;">;
</span><span style="color: black;">}</span></pre>
<p>A general CrossJoin query method can be implemented as:</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; CrossJoin&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector) =&gt;
        outer.SelectMany(outerValue =&gt; inner, resultSelector);
        </span><span style="color: green;">// Equivalent to:
        // from outerValue in outer
        // from innerValue in inner
        // select resultSelector(outerValue, innerValue);</span></pre>
<p>Cross join can also be done with Join, with inner key always equal to outer key, so that each outer value matches all inner values:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CrossJoinWithJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; cells = rows.Join(
        inner: columns,
        outerKeySelector: row =&gt; </span><span style="color: blue;">true</span><span style="color: black;">,
        innerKeySelector: column =&gt; </span><span style="color: blue;">true</span><span style="color: black;">,</span><span style="color: green;">
        </span><span style="color: black;">resultSelector: (row, column) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{column}{row}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: blue;">int </span><span style="color: black;">cellIndex = 0;
    </span><span style="color: blue;">int </span><span style="color: black;">columnCount = columns.Length;
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">string </span><span style="color: black;">cell </span><span style="color: blue;">in </span><span style="color: black;">cells) </span><span style="color: green;">// Execute query.
    </span><span style="color: black;">{
        </span><span style="color: #a31515;">$"</span><span style="color: black;">{cell} </span><span style="color: #a31515;">"</span><span style="color: black;">.Write();
        </span><span style="color: blue;">if </span><span style="color: black;">(++cellIndex % columnCount == 0)
        {
            </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
        }
    }
}</span></pre>
<p>And generally, cross join can be implemented by Join as:</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; CrossJoinWithJoin&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector) =&gt;
        outer.Join(
            inner: inner,
            outerKeySelector: outerValue =&gt; </span><span style="color: blue;">true</span><span style="color: black;">,
            innerKeySelector: innerValue =&gt; </span><span style="color: blue;">true</span><span style="color: black;">,</span><span style="color: green;">
            </span><span style="color: black;">resultSelector: resultSelector); </span><span style="color: green;">// Equivalent to:
        // Equivalent to:
        // from outerValue in outer
        // join innerValue in inner on true equals true
        // select resultSelector(outerValue, innerValue);</span></pre>
<p>In query expression, again, Join is just a join clause without into:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CrossJoinWithJoin()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; cells = </span><span style="color: blue;">from </span><span style="color: black;">row </span><span style="color: blue;">in </span><span style="color: black;">rows
                                </span><span style="color: blue;">join </span><span style="color: black;">column </span><span style="color: blue;">in </span><span style="color: black;">columns </span><span style="color: blue;">on true equals true
                                select </span><span style="color: #a31515;">$"</span><span style="color: black;">{column}{row}</span><span style="color: #a31515;">"</span><span style="color: black;">;</span><span style="color: black;">
}

</span><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; CrossJoinWithJoin&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector) =&gt;
        </span><span style="color: blue;">from </span><span style="color: black;">outerValue </span><span style="color: blue;">in </span><span style="color: black;">outer
        </span><span style="color: blue;">join </span><span style="color: black;">innerValue </span><span style="color: blue;">in </span><span style="color: black;">inner </span><span style="color: blue;">on true equals true
        select </span><span style="color: black;">resultSelector(outerValue, innerValue);</span></pre>
<p>The above inner join can be logically viewed as cross join with filtering the matching outer value and inner value. The above inner join of persons and characters can be implemented with SelectMany and Where as:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">InnerJoinWithSelectMany()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin = outer
        .SelectMany(
            collectionSelector: person =&gt; inner,
            resultSelector: (person, character) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ Person = person, Character = character })
        .Where(crossJoinValue =&gt; </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;.Default.Equals(
            crossJoinValue.Person.Name, crossJoinValue.Character.Starring))
        .Select(innerJoinValue =&gt;
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{innerJoinValue.Person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{innerJoinValue.Person.PlaceOfBirth}</span><span style="color: #a31515;">): </span><span style="color: black;">{innerJoinValue.Character.Name}</span><span style="color: #a31515;">"</span><span style="color: black;">);
    </span><span style="color: green;">// Define query.
    </span><span style="color: black;">innerJoin.WriteLines(); </span><span style="color: green;">// Execute query.
    // Robert Downey Jr. (US): Tony Stark
    // Chris Hemsworth (AU): Thor
    // Chris Evans (US): Steve Rogers
    // Paul Bettany (UK): Vision
    // Paul Bettany (UK): JARVIS
</span><span style="color: black;">}</span></pre>
<p>Generally, inner join and be implemented with cross join and filtering:</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; InnerJoinWithSelectMany&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    comparer = comparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;.Default;
    </span><span style="color: blue;">return </span><span style="color: black;">outer
        .SelectMany(
            collectionSelector: outerValue =&gt; inner,
            resultSelector: (outerValue, innerValue) =&gt; </span><span style="color: blue;">new </span><span style="color: black;">{ OuterValue = outerValue, InnerValue = innerValue })
        .Where(
            crossJoinValue =&gt; comparer.Equals(
                outerKeySelector(crossJoinValue.OuterValue),
                innerKeySelector(crossJoinValue.InnerValue)))
        .Select(innerJoinValue =&gt; resultSelector(innerJoinValue.OuterValue, innerJoinValue.InnerValue));
}</span></pre>
<p>In query expression, as fore mentioned, SelectMany is 2 from clauses:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">InnerJoinWithSelectMany()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; outer = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt; inner = Characters();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin =
        </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">outer
        </span><span style="color: blue;">from </span><span style="color: black;">character </span><span style="color: blue;">in </span><span style="color: black;">inner
        </span><span style="color: blue;">where </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;.Default.Equals(person.Name, character.Starring)
        </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.Name} </span><span style="color: #a31515;">(</span><span style="color: black;">{person.PlaceOfBirth}</span><span style="color: #a31515;">): </span><span style="color: black;">{character.Name}</span><span style="color: #a31515;">"</span><span style="color: black;">;
</span><span style="color: black;">}

</span><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; InnerJoinWithSelectMany&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">&gt; outer,
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">&gt; inner,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; outerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; innerKeySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TOuter</span><span style="color: black;">, </span><span style="color: #2b91af;">TInner</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer = </span><span style="color: blue;">null</span><span style="color: black;">)
{
    comparer = comparer ?? </span><span style="color: #2b91af;">EqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;.Default;
    </span><span style="color: blue;">return from </span><span style="color: black;">outerValue </span><span style="color: blue;">in </span><span style="color: black;">outer,
           </span><span style="color: blue;">from </span><span style="color: black;">innerValue </span><span style="color: blue;">in </span><span style="color: black;">inner
           </span><span style="color: blue;">where </span><span style="color: black;">comparer.Equals(outerKeySelector(outerValue), innerKeySelector(innerValue))
           </span><span style="color: blue;">select </span><span style="color: black;">resultSelector(outerValue, innerValue);
}</span></pre>
<p>The difference is, for N outer values, Join pull all inner values once and cache them, SelectMany does not cache anything and pull all inner values N times. Again the internal implementation of these query methods are discussed later in this chapter.</p>
<h2>Concatenation</h2>
<p>Concat merges 2 sequences by putting the second sequence’s values after the first sequence’s values:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Concat&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static int</span><span style="color: black;">[] First() =&gt; </span><span style="color: blue;">new int</span><span style="color: black;">[] { 1, 2, 3, 4, 4 };

</span><span style="color: blue;">internal static int</span><span style="color: black;">[] Second() =&gt; </span><span style="color: blue;">new int</span><span style="color: black;">[] { 3, 4, 5, 6 };

</span><span style="color: blue;">internal static void </span><span style="color: black;">Concat()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; first = First();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; second = Second();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; concat = first.Concat(second); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">concat.WriteLines(); </span><span style="color: green;">// Execute query. 1 2 3 4 4 3 4 5 6
</span><span style="color: black;">}</span></pre>
<p>.NET Core provides Prepend/Append, which merge the specified value to the beginning/end of the source sequence:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Prepend&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">element);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Append&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">element);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AppendPrepend()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; prepend = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(0, 5).Prepend(-1); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">prepend.WriteLines(); </span><span style="color: green;">// Execute query. -1 0 1 2 3 4

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; append = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(0, 5).Append(-1); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">append.WriteLines(); </span><span style="color: green;">// Execute query. 0 1 2 3 4 -1
</span><span style="color: black;">}</span></pre>
<h2>Set</h2>
<p>Distinct accepts a source sequence, and returns a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)" target="_blank">set</a>, where duplicate values are removed:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Distinct&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Distinct()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; first = First();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; distinct = first.Distinct(); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">distinct.WriteLines(); </span><span style="color: green;">// Execute query. 1 2 3 4
</span><span style="color: black;">}</span></pre>
<p>The following query methods accepts 2 sequences and returns a set:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Union&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Intersect&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Except&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second);</span></pre>
<p>In contrast to Concat, Union adds 2 sequences as if they are sets, and returns their <a href="https://en.wikipedia.org/wiki/Union_(set_theory)" target="_blank">set union</a>, which is equivalent to concatenating 2 sequences with duplicate values removed:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Union()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; first = First();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; second = Second();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; union = first.Union(second); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">union.WriteLines(); </span><span style="color: green;">// Execute query. 1 2 3 4 5 6
</span><span style="color: black;">}</span></pre>
<p>Intersect returns 2 sequences’ <a href="https://en.wikipedia.org/wiki/Intersection_(set_theory)" target="_blank">set intersection</a>, the distinct values that 2 sequences have in common:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Intersect()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; first = First();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; second = Second();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; intersect = first.Intersect(second); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">intersect.WriteLines(); </span><span style="color: green;">// Execute query. 3 4
</span><span style="color: black;">}</span></pre>
<p>Except returns the <a href="https://en.wikipedia.org/wiki/Complement_(set_theory)" target="_blank">set complement</a> of 2 sequences, by subtracting the second sequence from the first one:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Except()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; first = First();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; second = Second();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; except = first.Except(second); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">except.WriteLines(); </span><span style="color: green;">// Execute query. 1 2
</span><span style="color: black;">}</span></pre>
<p>There are other overloads that accepts a comparer:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Distinct&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Union&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Intersect&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Except&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">DistinctWithComparer()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: #a31515;">"aa"</span><span style="color: black;">, </span><span style="color: #a31515;">"AA"</span><span style="color: black;">, </span><span style="color: #a31515;">"Aa"</span><span style="color: black;">, </span><span style="color: #a31515;">"aA"</span><span style="color: black;">, </span><span style="color: #a31515;">"bb" </span><span style="color: black;">};
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; distinctWithComparer = source.Distinct(</span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">distinctWithComparer.WriteLines(); </span><span style="color: green;">// Execute query. aa bb
</span><span style="color: black;">}</span></pre>
<h2>Convolution</h2>
<p>Zip is provided since .NET Framework 4.0. It accepts 2 sequences and returns their <a href="https://en.wikipedia.org/wiki/Convolution_(computer_science)" target="_blank">convolution</a>:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Zip&lt;</span><span style="color: #2b91af;">TFirst</span><span style="color: black;">, </span><span style="color: #2b91af;">TSecond</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TFirst</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSecond</span><span style="color: black;">&gt; second, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TFirst</span><span style="color: black;">, </span><span style="color: #2b91af;">TSecond</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector);</span></pre>
<p>It calls result selector to map 2 values (each value from each sequence) to a result in the returned sequence:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Zip()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; first = First();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; second = Second();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; zip = first.Zip(second, (a, b) =&gt; a + b); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">zip.WriteLines(); </span><span style="color: green;">// Execute query. 4 6 8 10
</span><span style="color: black;">}</span></pre>
<p>When one input sequence has more values than the other, those values are ignored. Here the first sequence { 1, 2, 3, 4, 4 } and second sequence { 3, 4, 5, 6 } are zipped to a new sequence { 1 + 3, 2 + 4, 3 + 5, 4 + 6 }. The first sequence has one more value than the second, so its last value 4 is ignored.</p>
<h2>Partitioning</h2>
<p>Partitioning query methods are straightforward. Skip/Take simply skips/takes the specified number of values in the source sequence:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Skip&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">count);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Take&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">count);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SkipTake()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(0, 5);</span><span style="color: green;">

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; partition1 = source.Skip(2); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">partition1.WriteLines(); </span><span style="color: green;">// Execute query. 2 3 4

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; partition2 = source.Take(2); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">partition2.WriteLines(); </span><span style="color: green;">// Execute query. 0 1
</span><span style="color: black;">}</span></pre>
<p>SkipWhile/TakeWhile accept a predicate function:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; SkipWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; TakeWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>SkipWhile/TakeWhile skips/takes values while predicate is called with each value and returns true. Once predicate is called with a value and returns false, SkipWhile/TakeWhile stop partitioning:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">TakeWhileSkipWhile()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new int</span><span style="color: black;">[] { 1, 2, 3, -1, 4, 5 };

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; partition1 = source.TakeWhile(int32 =&gt; int32 &gt; 0); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">partition1.WriteLines(); </span><span style="color: green;">// Execute query. 1 2 3

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; partition2 = source.SkipWhile(int32 =&gt; int32 &gt; 0); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">partition2.WriteLines(); </span><span style="color: green;">// Execute query. -1 4 5
</span><span style="color: black;">}</span></pre>
<p>Just like Where and Select, SkipWhile/TakeWhile also have the indexed overload:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; SkipWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; TakeWhile&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">TakeWhileSkipWhileWithIndex()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new int</span><span style="color: black;">[] { 4, 3, 2, 1, 5 };

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; partition1 = source.TakeWhile((int32, index) =&gt; int32 &gt;= index); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">partition1.WriteLines();  </span><span style="color: green;">// Execute query. 4 3 2

    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; partition2 = source.SkipWhile((int32, index) =&gt; int32 &gt;= index); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">partition2.WriteLines();  </span><span style="color: green;">// Execute query. 1 5
</span><span style="color: black;">}</span></pre>
<h2>Ordering</h2>
<p mce_keep="true">The ordering methods are OrderBy and OrderByDescending:</p>
<pre class="code"><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector)

<span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector, <span style="color: #2b91af;">IComparer</span>&lt;TKey&gt; comparer)

<span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector)

<span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector, <span style="color: #2b91af;">IComparer</span>&lt;TKey&gt; comparer)</pre>
<p>The key selector specifies what should be compared to determine the order of values in the result sequence:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OrderBy()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = Words();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; ordered = source.OrderBy(word =&gt; word); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">ordered.WriteLines(); </span><span style="color: green;">// Execute query. four one three Two Zero
    </span><span style="color: black;">source.WriteLines(); </span><span style="color: green;">// Original sequence. Zero one Two three four
</span><span style="color: black;">}

</span><span style="color: blue;">internal static void </span><span style="color: black;">OrderByDescending()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = Words();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; ordered = source.OrderByDescending(word =&gt; word); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">ordered.WriteLines(); </span><span style="color: green;">// Execute query. Zero Two three one four
    </span><span style="color: black;">source.WriteLines(); </span><span style="color: green;">// Original sequence. Zero one Two three four
</span><span style="color: black;">}</span></pre>
<p>Here each value from the source sequence uses itself as the key for ordering. Also, as demonstrated above, OrderBy returns a new sequence, so OrderBy/OrderByDescending does not impact the source sequence. The equivalent query expression has a orderby clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OrderBy()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = Words();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; ordered = </span><span style="color: blue;">from </span><span style="color: black;">word </span><span style="color: blue;">in </span><span style="color: black;">source
                                  </span><span style="color: blue;">orderby </span><span style="color: black;">word </span><span style="color: blue;">ascending </span><span style="color: green;">// ascending can be omitted.
                                  </span><span style="color: blue;">select </span><span style="color: black;">word;
</span><span style="color: black;">}

</span><span style="color: blue;">internal static void </span><span style="color: black;">OrderByDescending()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = Words();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; ordered = </span><span style="color: blue;">from </span><span style="color: black;">word </span><span style="color: blue;">in </span><span style="color: black;">source
                                  </span><span style="color: blue;">orderby </span><span style="color: black;">word </span><span style="color: blue;">descending
                                  select </span><span style="color: black;">word;</span><span style="color: green;">
</span><span style="color: black;">}</span></pre>
<p>The comparer can be specified to provides the method to compare 2 keys:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Collections.Generic
{
</span><span style="color: green;">    </span><span style="color: blue;">public interface </span><span style="color: #2b91af;">IComparer</span><span style="color: black;">&lt;</span><span style="color: blue;">in </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
    {
</span><span style="color: green;">        </span><span style="color: blue;">int </span><span style="color: black;">Compare(</span><span style="color: #2b91af;">T </span><span style="color: black;">x, </span><span style="color: #2b91af;">T </span><span style="color: black;">y);
    }
}</span></pre>
<p>Compare returns an integer to determine the 2 values’ relative position in the ordered sequence. If x is less than y, Compare returns negative int value; If x is equal to y, Compare returns 0; If&nbsp; x is greater than y, Compare returns positive int value. For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OrderByWithComparer()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; source = Words();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; ordered = source.OrderBy(
        keySelector: word =&gt; word, comparer: </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.Ordinal); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">ordered.WriteLines(); </span><span style="color: green;">// Execute query. Two Zero four one three
</span><span style="color: black;">}</span></pre>
<p>Here StringComparer.Ordinal provides a case-sensitive comparison. “Zero” comes to the first position of the result sequence, because upper case letter is less than lower case letter. This overload with comparer is not supported in query expression. When using the other overload without comparer, OrderBy/OrderByDescending uses System.Collections.Generic.Comparer&lt;TKey&gt;.Default. In the first OrderBy example, Comparer&lt;string&gt;.Default is used, which is equivalent to StringComparer.CurrentCulture.</p>
<p>As fore mentioned, ThenBy/ThenByDescending are extension methods of IOrderedEnumerable&lt;T&gt;, not IEnumerable&lt;T&gt;:</p>
<pre class="code"><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; ThenBy&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector)

<span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; ThenBy&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector, <span style="color: #2b91af;">IComparer</span>&lt;TKey&gt; comparer)

<span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector)

<span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(
    <span style="color: blue;">this </span><span style="color: #2b91af;">IOrderedEnumerable</span>&lt;TSource&gt; source, <span style="color: #2b91af;">Func</span>&lt;TSource, TKey&gt; keySelector, <span style="color: #2b91af;">IComparer</span>&lt;TKey&gt; comparer)</pre>
<p>So they can be composed right after OrderBy/OrderByDescending:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ThenBy()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; ordered = source </span><span style="color: green;">// IEnumerable&lt;Person&gt;
        </span><span style="color: black;">.OrderBy(person =&gt; person.PlaceOfBirth) </span><span style="color: green;">// IOrderedEnumerable&lt;Person&gt;
        </span><span style="color: black;">.ThenBy(person =&gt; person.Name); </span><span style="color: green;">// IOrderedEnumerable&lt;Person&gt;
    </span><span style="color: black;">ordered.WriteLines(person =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.PlaceOfBirth}</span><span style="color: #a31515;">: </span><span style="color: black;">{person.Name}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Execute query.
    // AU: Chris Hemsworth
    // UK: Paul Bettany
    // UK: Tom Hiddleston
    // US: Chris Evans
    // US: Robert Downey Jr.
</span><span style="color: black;">}</span></pre>
<p>In the above example, persons are ordered by place of birth. If there are Person objects with the same PlaceOfBirth, they are ordered by Name. The query expression can have multiple key selectors in the orderby clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ThenBy()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; ordered = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                  </span><span style="color: blue;">orderby </span><span style="color: black;">person.PlaceOfBirth, person.Name
                                  </span><span style="color: blue;">select </span><span style="color: black;">person;</span><span style="color: black;">
}</span></pre>
<p>Notice OrderBy can also be called after calling OrderBy:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OrderByAndOrderBy()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; ordered = source
        .OrderBy(person =&gt; person.PlaceOfBirth)
        .OrderBy(person =&gt; person.Name); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">ordered.WriteLines(person =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{person.PlaceOfBirth}</span><span style="color: #a31515;">: </span><span style="color: black;">{person.Name}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Execute query.
    // US: Chris Evans
    // AU: Chris Hemsworth
    // UK: Paul Bettany
    // US: Robert Downey Jr.
    // UK: Tom Hiddleston
</span><span style="color: black;">}</span></pre>
<p>OrderBy with OrderBy is totally different from OrderBy with ThenBy. Here persons are ordered by place of birth. Then, all persons are ordered again by name. The equivalent query expression is:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OrderByOrderBy1()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; ordered = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                  </span><span style="color: blue;">orderby </span><span style="color: black;">person.PlaceOfBirth

                                  </span><span style="color: blue;">orderby </span><span style="color: black;">person.Name
                                  </span><span style="color: blue;">select </span><span style="color: black;">person;</span><span style="color: black;">
}</span></pre>
<p>To makes it more intuitive, it can be separated to 2 query expressions:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OrderByOrderBy2()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; ordered1 = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                   </span><span style="color: blue;">orderby </span><span style="color: black;">person.PlaceOfBirth
                                   </span><span style="color: blue;">select </span><span style="color: black;">person;
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; ordered2 = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">ordered1
                                   </span><span style="color: blue;">orderby </span><span style="color: black;">person.Name
                                   </span><span style="color: blue;">select </span><span style="color: black;">person;
</span><span style="color: black;">}</span></pre>
<p>Apparently, both orderby clauses work on the entire input sequence. As fore mentioned, the into query keyword is for this kind scenario of continuation:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">OrderByOrderBy3()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; source = Persons();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Person</span><span style="color: black;">&gt; ordered = </span><span style="color: blue;">from </span><span style="color: black;">person </span><span style="color: blue;">in </span><span style="color: black;">source
                                  </span><span style="color: blue;">orderby </span><span style="color: black;">person.PlaceOfBirth
                                  </span><span style="color: blue;">select </span><span style="color: black;">person </span><span style="color: blue;">into </span><span style="color: black;">person
                                  </span><span style="color: blue;">orderby </span><span style="color: black;">person.Name
                                  </span><span style="color: blue;">select </span><span style="color: black;">person;
</span><span style="color: black;">}</span></pre>
<p>The compilation of the above 3 queries are identical.</p>
<p>Reverse simply reverses the positions of values:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; Reverse&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source)</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Reverse()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source = </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Range(0, 5);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; reversed = source.Reverse(); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">reversed.WriteLines(); </span><span style="color: green;">// Execute query. 4 3 2 1 0
</span><span style="color: black;">}</span></pre>
<h2>Conversion</h2>
<p>Cast converts each value in source sequence to the specified type:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; Cast&lt;</span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">source);</span></pre>
<p>Unlike other query methods, Cast is an extension method of non-generic sequence, so it can work with types implementing either IEnumerable or IEnumerable&lt;T&gt;. So it can enable LINQ query for legacy types. The following example calls Microsoft Team Foundation Service (TFS) client APIs to query work items, where Microsoft.TeamFoundation.WorkItemTracking.Client.WorkItemCollection is returned. WorkItemCollection is a collection of Microsoft.TeamFoundation.WorkItemTracking.Client.WorkItem, but it only implements IEnumerable, so it can be casted to a generic IEnumerable&lt;WorkItem&gt; safely, and further LINQ query can be applied. The following example execute a WIQL (Work Item Query Language of TFS) statement to query work items from TFS. Since WIQL does not support GROUP BY clause, the work items can be grouped locally with LINQ:</p>
<pre class="code"><span style="color: gray;">#if </span><span style="color: black;">NETFX
</span><span style="color: blue;">internal static void </span><span style="color: black;">CastNonGeneric(</span><span style="color: #2b91af;">VssCredentials </span><span style="color: black;">credentials)
{
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">TfsTeamProjectCollection </span><span style="color: black;">projectCollection = </span><span style="color: blue;">new </span><span style="color: #2b91af;">TfsTeamProjectCollection</span><span style="color: black;">(
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Uri</span><span style="color: black;">(</span><span style="color: #a31515;">"https://dixin.visualstudio.com/DefaultCollection"</span><span style="color: black;">), credentials))
    {
        </span><span style="color: green;">// WorkItemCollection implements IEnumerable.
        </span><span style="color: blue;">const string </span><span style="color: black;">Wiql = </span><span style="color: #a31515;">"SELECT * FROM WorkItems WHERE [Work Item Type] = 'Bug' AND State != 'Closed'"</span><span style="color: black;">; </span><span style="color: green;">// WIQL does not support GROUP BY.
        </span><span style="color: #2b91af;">WorkItemStore </span><span style="color: black;">workItemStore = (</span><span style="color: #2b91af;">WorkItemStore</span><span style="color: black;">)projectCollection.GetService(</span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: #2b91af;">WorkItemStore</span><span style="color: black;">));
        </span><span style="color: #2b91af;">WorkItemCollection </span><span style="color: black;">workItems = workItemStore.Query(Wiql);

        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">WorkItem</span><span style="color: black;">&gt; genericWorkItems = workItems.Cast&lt;</span><span style="color: #2b91af;">WorkItem</span><span style="color: black;">&gt;(); </span><span style="color: green;">// Define query.
        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">WorkItem</span><span style="color: black;">&gt;&gt; workItemGroups = genericWorkItems
            .GroupBy(workItem =&gt; workItem.CreatedBy); </span><span style="color: green;">// Group work items locally.
        // ...
    </span><span style="color: black;">}
}
</span><span style="color: gray;">#endif</span></pre>
<p>The other non-generic sequences, like System.Resources.ResourceSet, System.Resources.ResourceReader, can be casted in the same way:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CastMoreNonGeneric()
{
    </span><span style="color: green;">// ResourceSet implements IEnumerable.
    </span><span style="color: #2b91af;">ResourceSet </span><span style="color: black;">resourceSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">ResourceManager</span><span style="color: black;">(</span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: #2b91af;">Resources</span><span style="color: black;">))
        .GetResourceSet(</span><span style="color: #2b91af;">CultureInfo</span><span style="color: black;">.CurrentCulture, createIfNotExists: </span><span style="color: blue;">true</span><span style="color: black;">, tryParents: </span><span style="color: blue;">true</span><span style="color: black;">);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DictionaryEntry</span><span style="color: black;">&gt; entries1 = resourceSet.Cast&lt;</span><span style="color: #2b91af;">DictionaryEntry</span><span style="color: black;">&gt;();

    </span><span style="color: green;">// ResourceReader implements IEnumerable.
    </span><span style="color: #2b91af;">Assembly </span><span style="color: black;">assembly = </span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: #2b91af;">QueryMethods</span><span style="color: black;">).Assembly;
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">Stream </span><span style="color: black;">stream = assembly.GetManifestResourceStream(assembly.GetManifestResourceNames()[0]))
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">ResourceReader </span><span style="color: black;">resourceReader = </span><span style="color: blue;">new </span><span style="color: #2b91af;">ResourceReader</span><span style="color: black;">(stream))
    {
        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DictionaryEntry</span><span style="color: black;">&gt; entries2 = resourceReader.Cast&lt;</span><span style="color: #2b91af;">DictionaryEntry</span><span style="color: black;">&gt;();
    }
}
</span></pre>
<p>In query expression syntax, just specify the type in from clause before the value name:</p>
<pre class="code"><span style="color: gray;">#if </span><span style="color: black;">NETFX
</span><span style="color: blue;">internal static void </span><span style="color: black;">CastNonGeneric(</span><span style="color: #2b91af;">VssCredentials </span><span style="color: black;">credentials)
{
    </span><span style="color: green;">// WorkItemCollection implements IEnumerable.
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">TfsTeamProjectCollection </span><span style="color: black;">projectCollection = </span><span style="color: blue;">new </span><span style="color: #2b91af;">TfsTeamProjectCollection</span><span style="color: black;">(
        </span><span style="color: blue;">new </span><span style="color: #2b91af;">Uri</span><span style="color: black;">(</span><span style="color: #a31515;">"https://dixin.visualstudio.com/DefaultCollection"</span><span style="color: black;">), credentials))
    {
        </span><span style="color: blue;">const string </span><span style="color: black;">Wiql = </span><span style="color: #a31515;">"SELECT * FROM WorkItems WHERE [Work Item Type] = 'Bug' AND State != 'Closed'"</span><span style="color: black;">; </span><span style="color: green;">// WIQL does not support GROUP BY.
        </span><span style="color: #2b91af;">WorkItemStore </span><span style="color: black;">workItemStore = (</span><span style="color: #2b91af;">WorkItemStore</span><span style="color: black;">)projectCollection.GetService(</span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: #2b91af;">WorkItemStore</span><span style="color: black;">));
        </span><span style="color: #2b91af;">WorkItemCollection </span><span style="color: black;">workItems = workItemStore.Query(Wiql);

        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: #2b91af;">WorkItem</span><span style="color: black;">&gt;&gt; workItemGroups =
            </span><span style="color: blue;">from </span><span style="color: #2b91af;">WorkItem </span><span style="color: black;">workItem </span><span style="color: blue;">in </span><span style="color: black;">workItems </span><span style="color: green;">// Cast.
            </span><span style="color: blue;">group </span><span style="color: black;">workItem </span><span style="color: blue;">by </span><span style="color: black;">workItem.CreatedBy; </span><span style="color: green;">// Group work items in local memory.
        // ...
    </span><span style="color: black;">}
}<span style="color: black;">
</span><span style="color: gray;">#endif</span>
</span><span style="color: black;">
</span><span style="color: blue;">internal static void </span><span style="color: black;">CastMoreNonGenericI()
{
    </span><span style="color: green;">// ResourceSet implements IEnumerable.
    </span><span style="color: #2b91af;">ResourceSet </span><span style="color: black;">resourceSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">ResourceManager</span><span style="color: black;">(</span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: #2b91af;">Resources</span><span style="color: black;">))
        .GetResourceSet(</span><span style="color: #2b91af;">CultureInfo</span><span style="color: black;">.CurrentCulture, createIfNotExists: </span><span style="color: blue;">true</span><span style="color: black;">, tryParents: </span><span style="color: blue;">true</span><span style="color: black;">);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DictionaryEntry</span><span style="color: black;">&gt; entries1 =
        </span><span style="color: blue;">from </span><span style="color: #2b91af;">DictionaryEntry </span><span style="color: black;">entry </span><span style="color: blue;">in </span><span style="color: black;">resourceSet<span style="color: black;"> </span><span style="color: green;">// Cast.</span>
        </span><span style="color: blue;">select </span><span style="color: black;">entry;

    </span><span style="color: green;">// ResourceReader implements IEnumerable.
    </span><span style="color: #2b91af;">Assembly </span><span style="color: black;">assembly = </span><span style="color: blue;">typeof</span><span style="color: black;">(</span><span style="color: #2b91af;">QueryMethods</span><span style="color: black;">).Assembly;
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">Stream </span><span style="color: black;">stream = assembly.GetManifestResourceStream(assembly.GetManifestResourceNames()[0]))
    </span><span style="color: blue;">using </span><span style="color: black;">(</span><span style="color: #2b91af;">ResourceReader </span><span style="color: black;">resourceReader = </span><span style="color: blue;">new </span><span style="color: #2b91af;">ResourceReader</span><span style="color: black;">(stream))
    {
        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DictionaryEntry</span><span style="color: black;">&gt; entries2 =
            </span><span style="color: blue;">from </span><span style="color: #2b91af;">DictionaryEntry </span><span style="color: black;">entry </span><span style="color: blue;">in </span><span style="color: black;">resourceReader<span style="color: black;"> </span><span style="color: green;">// Cast.</span>
            </span><span style="color: blue;">select </span><span style="color: black;">entry;
    }
}
</span></pre>
<p>And of course Cast can be used to generic IEnumerable&lt;T&gt;:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CastGenericIEnumerable()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Base</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new </span><span style="color: #2b91af;">Base</span><span style="color: black;">[] { </span><span style="color: blue;">new </span><span style="color: #2b91af;">Derived</span><span style="color: black;">(), </span><span style="color: blue;">new </span><span style="color: #2b91af;">Derived</span><span style="color: black;">() };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Derived</span><span style="color: black;">&gt; casted = source.Cast&lt;</span><span style="color: #2b91af;">Derived</span><span style="color: black;">&gt;(); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">casted.WriteLines(result =&gt; result.GetType().Name); </span><span style="color: green;">// Execute query. Derived Derived
</span><span style="color: black;">}</span></pre>
<p>And the query expression syntax is the same:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CastGenericIEnumerable()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Base</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new </span><span style="color: #2b91af;">Base</span><span style="color: black;">[] { </span><span style="color: blue;">new </span><span style="color: #2b91af;">Derived</span><span style="color: black;">(), </span><span style="color: blue;">new </span><span style="color: #2b91af;">Derived</span><span style="color: black;">() };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Derived</span><span style="color: black;">&gt; casted = </span><span style="color: blue;">from </span><span style="color: #2b91af;">Derived </span><span style="color: black;">derived </span><span style="color: blue;">in </span><span style="color: black;">source
                                  </span><span style="color: blue;">select </span><span style="color: black;">derived;
</span><span style="color: black;">}</span></pre>
<p>Cast must be used with caution, because type conversion can fail at runtime, for example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CastGenericIEnumerableWithException()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Base</span><span style="color: black;">&gt; source = </span><span style="color: blue;">new </span><span style="color: #2b91af;">Base</span><span style="color: black;">[] { </span><span style="color: blue;">new </span><span style="color: #2b91af;">Derived</span><span style="color: black;">(), </span><span style="color: blue;">new </span><span style="color: #2b91af;">Base</span><span style="color: black;">() };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Derived</span><span style="color: black;">&gt; casted = source.Cast&lt;</span><span style="color: #2b91af;">Derived</span><span style="color: black;">&gt;(); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">casted.WriteLines(result =&gt; result.GetType().Name); </span><span style="color: green;">// Execute query. Derived InvalidCastException
</span><span style="color: black;">}</span></pre>
<p>An InvalidCastException is thrown because the second value is of Base type, and cannot be casted to Derived.</p>
<p>The same query expression cast syntax can also be used in join clause:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CastWithJoin()
{
    </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">outer = </span><span style="color: blue;">new int</span><span style="color: black;">[] { 1, 2, 3 };
    </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">inner = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: #a31515;">"a"</span><span style="color: black;">, </span><span style="color: #a31515;">"bb"</span><span style="color: black;">, </span><span style="color: #a31515;">"ccc" </span><span style="color: black;">};
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin = </span><span style="color: blue;">from int </span><span style="color: black;">int32 </span><span style="color: blue;">in </span><span style="color: black;">outer
                                    </span><span style="color: blue;">join string </span><span style="color: black;">@string </span><span style="color: blue;">in </span><span style="color: black;">inner </span><span style="color: blue;">on </span><span style="color: black;">int32 </span><span style="color: blue;">equals </span><span style="color: black;">@string.Length
                                    </span><span style="color: blue;">select </span><span style="color: #a31515;">$"</span><span style="color: black;">{int32}</span><span style="color: #a31515;">: </span><span style="color: black;">{@string}</span><span style="color: #a31515;">"</span><span style="color: black;">;
</span><span style="color: black;">}</span></pre>
<p>It is compiled to:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CastWithJoin()
{
    </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">outer = </span><span style="color: blue;">new int</span><span style="color: black;">[] { 1, 2, 3 };
    </span><span style="color: #2b91af;">IEnumerable </span><span style="color: black;">inner = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: blue;">string</span><span style="color: black;">.Empty, </span><span style="color: #a31515;">"a"</span><span style="color: black;">, </span><span style="color: #a31515;">"bb"</span><span style="color: black;">, </span><span style="color: #a31515;">"ccc"</span><span style="color: black;">, </span><span style="color: #a31515;">"dddd" </span><span style="color: black;">};
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; innerJoin = outer.Cast&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;().Join(
        inner: inner.Cast&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;(),
        outerKeySelector: int32 =&gt; int32,
        innerKeySelector: @string =&gt; @string.Length, </span><span style="color: green;">// on int32 equal @string.Length
        </span><span style="color: black;">resultSelector: (int32, @string) =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{int32}</span><span style="color: #a31515;">:</span><span style="color: black;">{@string}</span><span style="color: #a31515;">"</span><span style="color: black;">); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">innerJoin.WriteLines(); </span><span style="color: green;">// Execute query. 1:a 2:bb 3:ccc
</span><span style="color: black;">}</span></pre>
<p>Cast looks similar to the fore mentioned OfType method, which also can have the result type specified. However, they are very different, OfType filters the values of the specified type. If there are values not of the specified type, they are simply ignored. There no conversion so there is no chance of InvalidCastException.</p>
<p>AsEnumerable is a query method doing nothing. It accepts a source sequence, then return the source sequence itself:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; AsEnumerable&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>Its purpose is to make more derived type be visible only as IEnumerable&lt;T&gt;, and hide additional members of that more derived type:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AsEnumerable()
{
    </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; list = </span><span style="color: blue;">new </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;();
    list.Add(0);
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; sequence = list.AsEnumerable(); </span><span style="color: green;">// Add method is no longer available.
</span><span style="color: black;">}</span></pre>
<p>If the more derived source has method with the same signature as IEnumerable&lt;T&gt;’s extension method, after calling AsEnumerable, that IEnumerable&lt;T&gt; extension method is called:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AsEnumerableReverse()
{
    </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; list = </span><span style="color: blue;">new </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;();
    list.Reverse(); </span><span style="color: green;">// List&lt;T&gt;.Reverse.
    </span><span style="color: black;">list
        .AsEnumerable() </span><span style="color: green;">// IEnumerable&lt;T&gt;.
        </span><span style="color: black;">.Reverse(); </span><span style="color: green;">// Enumerable.Reverse.

    </span><span style="color: #2b91af;">SortedSet</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; sortedSet = </span><span style="color: blue;">new </span><span style="color: #2b91af;">SortedSet</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;();
    sortedSet.Reverse(); </span><span style="color: green;">// SortedSet&lt;T&gt;.Reverse.
    </span><span style="color: black;">sortedSet.AsEnumerable().Reverse(); </span><span style="color: green;">// Enumerable.Reverse.

    </span><span style="color: #2b91af;">ReadOnlyCollectionBuilder</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; readOnlyCollection = </span><span style="color: blue;">new </span><span style="color: #2b91af;">ReadOnlyCollectionBuilder</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;();
    readOnlyCollection.Reverse(); </span><span style="color: green;">// ReadOnlyCollectionBuilder&lt;T&gt;.Reverse.
    </span><span style="color: black;">readOnlyCollection.AsEnumerable().Reverse(); </span><span style="color: green;">// Enumerable.Reverse.

    </span><span style="color: #2b91af;">IQueryable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; queryable = </span><span style="color: blue;">new </span><span style="color: #2b91af;">EnumerableQuery</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;());
    queryable.Reverse(); </span><span style="color: green;">// Queryable.Reverse.
    </span><span style="color: black;">queryable.AsEnumerable().Reverse(); </span><span style="color: green;">// Enumerable.Reverse.

    </span><span style="color: #2b91af;">ImmutableList</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; immutableList = </span><span style="color: #2b91af;">ImmutableList</span><span style="color: black;">.Create(0);
    immutableList.Reverse(); </span><span style="color: green;">// ImmutableSortedSet&lt;T&gt;.Reverse.
    </span><span style="color: black;">immutableList.AsEnumerable().Reverse(); </span><span style="color: green;">// Enumerable.Reverse.

    </span><span style="color: #2b91af;">ImmutableSortedSet</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; immutableSortedSet = </span><span style="color: #2b91af;">ImmutableSortedSet</span><span style="color: black;">.Create(0);
    immutableSortedSet.Reverse(); </span><span style="color: green;">// ImmutableSortedSet&lt;T&gt;.Reverse.
    </span><span style="color: black;">immutableSortedSet.AsEnumerable().Reverse(); </span><span style="color: green;">// Enumerable.Reverse.
</span><span style="color: black;">}</span></pre>
<p>AsEnumerable will be revisited when introducing IQueryable&lt;T&gt; in the LINQ to Entities chapter.</p>
<p>As fore mentioned, local parallel LINQ queries are represented by ParallelQuery&lt;T&gt; and remote LINQ queries are represented by IQueryable&lt;T&gt;. They both implement IEnumerable&lt;T&gt;, so they both have AsEnumerable available. Since AsEnumerable returns IEnumerable&lt;T&gt;, it opt-out local parallel query and remote query back to local sequential query. These scenarios are discussed in Parallel LINQ chapter and LINQ to Entities chapter.</p>
<h1>Collection queries</h1>
<h2>Conversion</h2>
<p>The collection query methods convert source sequence to a collection by pulling all the values from the source sequence. ToArray and ToList are straightforward:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource</span><span style="color: black;">[] ToArray&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToList&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>They pull all values from the source sequence, and simply store them into a new array/list:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ToArrayToList()
{
    </span><span style="color: blue;">int</span><span style="color: black;">[] array = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Range(0, 5) </span><span style="color: green;">// Define query, return IEnumerable&lt;T&gt;.
        </span><span style="color: black;">.ToArray(); </span><span style="color: green;">// Execute query.

    </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; list = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Range(0, 5) </span><span style="color: green;">// Define query, return IEnumerable&lt;T&gt;.
        </span><span style="color: black;">.ToList(); </span><span style="color: green;">// Execute query.
</span><span style="color: black;">}</span></pre>
<p>Apparently, when collection query methods are called for an IEnumerable&lt;T&gt; sequence representing LINQ query, that LINQ query is executed immediately. Similarly, ToDictionary/ToLookup also pulls all values from source sequence, and store those values into a new dictionary/lookup:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToDictionary&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToLookup&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; ToDictionary&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; ToLookup&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector);</span></pre>
<p>Here are the definition of dictionary and lookup:</p>
<pre class="code"><span style="color: blue;">namespace </span><span style="color: black;">System.Collections.Generic
{
    </span><span style="color: blue;">public class </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TValue</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">KeyValuePair</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TValue</span><span style="color: black;">&gt;&gt;, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">,
        </span><span style="color: #2b91af;">IDictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TValue</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">IDictionary</span><span style="color: black;">, </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">KeyValuePair</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TValue</span><span style="color: black;">&gt;&gt;, </span><span style="color: #2b91af;">ICollection</span><span style="color: black;">,
        </span><span style="color: #2b91af;">IReadOnlyDictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TValue</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">IReadOnlyCollection</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">KeyValuePair</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TValue</span><span style="color: black;">&gt;&gt;,
        </span><span style="color: #2b91af;">ISerializable</span><span style="color: black;">, </span><span style="color: #2b91af;">IDeserializationCallback </span><span style="color: black;">{ }
}

</span><span style="color: blue;">namespace </span><span style="color: black;">System.Linq
{
    </span><span style="color: blue;">public interface </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; : </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;&gt;, </span><span style="color: #2b91af;">IEnumerable
    </span><span style="color: black;">{
        </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; </span><span style="color: blue;">this</span><span style="color: black;">[</span><span style="color: #2b91af;">TKey </span><span style="color: black;">key] { </span><span style="color: blue;">get</span><span style="color: black;">; }

        </span><span style="color: blue;">int </span><span style="color: black;">Count { </span><span style="color: blue;">get</span><span style="color: black;">; }

        </span><span style="color: blue;">bool </span><span style="color: black;">Contains(</span><span style="color: #2b91af;">TKey </span><span style="color: black;">key);
    }
}</span></pre>
<p>The difference between dictionary and lookup is, a dictionary is a flatten collection of key-value pairs, where each key is paired with one single value, and a lookup is a hierarchical collection of key-sequence pairs, where each key is a sequence of paired with one or more values.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ToDictionaryToLookup()
{
    </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt; dictionary = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Range(0, 5) </span><span style="color: green;">// Define query.
        </span><span style="color: black;">.ToDictionary(
            keySelector: int32 =&gt; int32,
            elementSelector: int32 =&gt; </span><span style="color: #2b91af;">Math</span><span style="color: black;">.Sqrt(int32).ToString(</span><span style="color: #a31515;">"F"</span><span style="color: black;">, </span><span style="color: #2b91af;">CultureInfo</span><span style="color: black;">.InvariantCulture)); </span><span style="color: green;">// Execute query.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">KeyValuePair</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt; squareRoot </span><span style="color: blue;">in </span><span style="color: black;">dictionary)
    {
        </span><span style="color: #a31515;">$"√</span><span style="color: black;">{squareRoot.Key}</span><span style="color: #a31515;">:</span><span style="color: black;">{squareRoot.Value}</span><span style="color: #a31515;">"</span><span style="color: black;">.WriteLine();
    }
    </span><span style="color: green;">// √0: 0.00
    // √1: 1.00
    // √2: 1.41
    // √3: 1.73
    // √4: 2.00

    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; lookup = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Range(-2, 5) </span><span style="color: green;">// Define query.
        </span><span style="color: black;">.ToLookup(int32 =&gt; int32 * int32); </span><span style="color: green;">// Execute query.
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; squareRoots </span><span style="color: blue;">in </span><span style="color: black;">lookup)
    {
        </span><span style="color: #a31515;">$"√</span><span style="color: black;">{squareRoots.Key}</span><span style="color: #a31515;">: "</span><span style="color: black;">.Write();
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">squareRoot </span><span style="color: blue;">in </span><span style="color: black;">squareRoots)
        {
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{squareRoot}</span><span style="color: #a31515;">, "</span><span style="color: black;">.Write();
        }
        </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
    }
    </span><span style="color: green;">// √4: -2, 2,
    // √1: -1, 1,
    // √0: 0,
</span><span style="color: black;">}</span></pre>
<p>Each value from source sequence is mapped to a key by calling the key selector function. If element selector is provided, each value from source sequence is mapped to a value in the result dictionary/lookup. In above example, if ToDictionary is called in the second query, an ArgumentException is thrown because dictionary cannot have multiple key and single value pairs with the same key:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ToDictionaryWithException()
{
    </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; lookup = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Range(-2, 5) </span><span style="color: green;">// Define query.
        </span><span style="color: black;">.ToDictionary(int32 =&gt; int32 * int32); </span><span style="color: green;">// Execute query.
    // ArgumentException: An item with the same key has already been added.
</span><span style="color: black;">}</span></pre>
<p>Another difference between dictionary and lookup is, at runtime, if querying a dictionary with a non-existing key, dictionary throws KeyNotFoundException, but if querying a lookup with a non-existing key, lookup returns a empty sequence peacefully.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LookupDictionary()
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; lookup = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Range(0, 5) </span><span style="color: green;">// Define query.
        </span><span style="color: black;">.ToLookup(int32 =&gt; int32); </span><span style="color: green;">// Execute query.
    </span><span style="color: blue;">int </span><span style="color: black;">count = 0;
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; group = lookup[10];
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">group)
    {
        count++;
    }
    </span><span style="color: black;">count.WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; dictionary = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Range(0, 5) </span><span style="color: green;">// Define query.
        </span><span style="color: black;">.ToDictionary(int32 =&gt; int32); </span><span style="color: green;">// Execute query.
    </span><span style="color: blue;">int </span><span style="color: black;">result = dictionary[10];
    </span><span style="color: green;">// KeyNotFoundException: The given key was not present in the dictionary.
</span><span style="color: black;">}</span></pre>
<p>The last difference is dictionary cannot have null key, while lookup can:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LookupDictionaryNullKey()
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt; lookup = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: #a31515;">"a"</span><span style="color: black;">, </span><span style="color: #a31515;">"b"</span><span style="color: black;">, </span><span style="color: blue;">null </span><span style="color: black;">}.ToLookup(@string =&gt; @string);
    </span><span style="color: blue;">int </span><span style="color: black;">count = 0;
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; group = lookup[</span><span style="color: blue;">null</span><span style="color: black;">];
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">string </span><span style="color: black;">value </span><span style="color: blue;">in </span><span style="color: black;">group)
    {
        count++;
    }
    </span><span style="color: black;">count.WriteLine(); </span><span style="color: green;">// 1

    </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt; dictionary = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: #a31515;">"a"</span><span style="color: black;">, </span><span style="color: #a31515;">"b"</span><span style="color: black;">, </span><span style="color: blue;">null </span><span style="color: black;">}<span style="color: black;">
        </span>.ToDictionary(@string =&gt; @string);
    </span><span style="color: green;">// ArgumentNullException: Value cannot be null. Parameter name: key.
</span><span style="color: black;">}</span></pre>
<p>ToDictionary/ToLookup has other overloads to accept a key comparer:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToDictionary&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; ToLookup&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">Dictionary</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; ToDictionary&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; ToLookup&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; keySelector,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TElement</span><span style="color: black;">&gt; elementSelector,
    </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TKey</span><span style="color: black;">&gt; comparer);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ToLookupWithComparer()
{
    </span><span style="color: #2b91af;">ILookup</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt; lookup = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: #a31515;">"aa"</span><span style="color: black;">, </span><span style="color: #a31515;">"AA"</span><span style="color: black;">, </span><span style="color: #a31515;">"Aa"</span><span style="color: black;">, </span><span style="color: #a31515;">"aA"</span><span style="color: black;">, </span><span style="color: #a31515;">"bb" </span><span style="color: black;">}
        .ToLookup(@string =&gt; @string, </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase);
    </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: #2b91af;">IGrouping</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">&gt; group </span><span style="color: blue;">in </span><span style="color: black;">lookup)
    {
        </span><span style="color: #a31515;">$"</span><span style="color: black;">{group.Key}</span><span style="color: #a31515;">: "</span><span style="color: black;">.Write();
        </span><span style="color: blue;">foreach </span><span style="color: black;">(</span><span style="color: blue;">string </span><span style="color: black;">@string </span><span style="color: blue;">in </span><span style="color: black;">group)
        {
            </span><span style="color: #a31515;">$"</span><span style="color: black;">{@string}</span><span style="color: #a31515;">, "</span><span style="color: black;">.Write();
        }
        </span><span style="color: #2b91af;">Environment</span><span style="color: black;">.NewLine.Write();
        </span><span style="color: green;">// aa: aa, AA, Aa, aA,
        // bb: bb,
    </span><span style="color: black;">}
}</span></pre>
<h1>Value queries</h1>
<h2>Element</h2>
<p>Element query methods returns a single value from the source sequence. When they are called, they immediately execute the query, trying to pull values until the expected value is pulled. First/Last immediately pulls the first/last value of the source sequence.</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">First&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Last&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>And InvalidOperationException is thrown if the source sequence is empty.</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; Int32Source() =&gt; </span><span style="color: blue;">new int</span><span style="color: black;">[] { -1, 1, 2, 3, -4 };

</span><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; SingleInt32Source() =&gt; </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Repeat(5, 1);

</span><span style="color: blue;">internal static </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; EmptyInt32Source() =&gt; </span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;();

</span><span style="color: blue;">internal static void </span><span style="color: black;">FirstLast()
{
    </span><span style="color: blue;">int </span><span style="color: black;">firstOfSource = Int32Source().First().WriteLine(); </span><span style="color: green;">// -1
    </span><span style="color: blue;">int </span><span style="color: black;">lastOfSource = Int32Source().Last().WriteLine(); </span><span style="color: green;">// -4

    </span><span style="color: blue;">int </span><span style="color: black;">firstOfSingleSOurce = SingleInt32Source().First().WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">int </span><span style="color: black;">lastOfSingleSOurce = SingleInt32Source().Last().WriteLine(); </span><span style="color: green;">// 5

    </span><span style="color: blue;">int </span><span style="color: black;">firstOfEmptySOurce = EmptyInt32Source().First(); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: blue;">int </span><span style="color: black;">lastOfEmptySOurce = EmptyInt32Source().Last(); </span><span style="color: green;">// InvalidOperationException.
</span><span style="color: black;">}</span></pre>
<p>The other First/Last overload accept a predicate function. They immediately call the predicate function immediately with the values, and return the first/last value where predicate function returns true:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">First&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Last&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>Logically, source.First(predicate) is equivalent to source.Where(predicate).First(), and source.Last(predicate) is equivalent to source.Where(predicate).Last():</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">FirstLastWithPredicate()
{
    </span><span style="color: blue;">int </span><span style="color: black;">firstPositiveOfSource = Int32Source().First(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// 1
    </span><span style="color: blue;">int </span><span style="color: black;">lastNegativeOfSource = Int32Source().Last(int32 =&gt; int32 &lt; 0).WriteLine(); </span><span style="color: green;">// -4

    </span><span style="color: blue;">int </span><span style="color: black;">firstPositiveOfSingleSOurce = SingleInt32Source().First(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// 1
    </span><span style="color: blue;">int </span><span style="color: black;">lastNegativeOfSingleSOurce = SingleInt32Source().Last(int32 =&gt; int32 &lt; 0); </span><span style="color: green;">// InvalidOperationException.

    </span><span style="color: blue;">int </span><span style="color: black;">firstPositiveOfEmptySOurce = EmptyInt32Source().First(int32 =&gt; int32 &gt; 0); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: blue;">int </span><span style="color: black;">lastNegativeOfEmptySOurce = EmptyInt32Source().Last(int32 =&gt; int32 &lt; 0); </span><span style="color: green;">// InvalidOperationException.
</span><span style="color: black;">}</span></pre>
<p>There are also FirstOrDefault/LastOrDefault methods:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">FirstOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">FirstOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">LastOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">LastOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>When there is no first/last value available, these methods return a default value instead of throwing exception:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">FirstOrDefaultLastOrDefault()
{
    </span><span style="color: blue;">int </span><span style="color: black;">firstOrDefaultOfEmptySOurce = EmptyInt32Source().FirstOrDefault().WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: blue;">int </span><span style="color: black;">lastOrDefaultOfEmptySOurce = EmptyInt32Source().LastOrDefault().WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: blue;">int </span><span style="color: black;">lastNegativeOrDefaultOfSingleSOurce = SingleInt32Source().LastOrDefault(int32 =&gt; int32 &lt; 0).WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: blue;">int </span><span style="color: black;">firstPositiveOrDefaultOfEmptySOurce = EmptyInt32Source().FirstOrDefault(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: blue;">int </span><span style="color: black;">lastNegativeOrDefaultOfEmptySOurce = EmptyInt32Source().LastOrDefault(int32 =&gt; int32 &lt; 0).WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: #2b91af;">Character </span><span style="color: black;">lokiOrDefault = Characters()
        .FirstOrDefault(character =&gt; </span><span style="color: #a31515;">"Loki"</span><span style="color: black;">.Equals(character.Name, </span><span style="color: #2b91af;">StringComparison</span><span style="color: black;">.Ordinal));
    (lokiOrDefault == </span><span style="color: blue;">null</span><span style="color: black;">).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<p>ElementAt returns the value at the specified index:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">ElementAt&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">index);</span></pre>
<p>When the specified index is out of range, ArgumentOutOfRangeException is thrown.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ElementAt()
{
    </span><span style="color: blue;">int </span><span style="color: black;">elementAt2OfSource = Int32Source().ElementAt(2).WriteLine(); </span><span style="color: green;">// 2
    </span><span style="color: blue;">int </span><span style="color: black;">elementAt9OfSource = Int32Source().ElementAt(9); </span><span style="color: green;">// ArgumentOutOfRangeException.
    </span><span style="color: blue;">int </span><span style="color: black;">elementAtNegativeIndex = Int32Source().ElementAt(-5); </span><span style="color: green;">// ArgumentOutOfRangeException.

    </span><span style="color: blue;">int </span><span style="color: black;">elementAt0OfSingleSource = SingleInt32Source().ElementAt(0).WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">int </span><span style="color: black;">elementAt1OfSingleSource = SingleInt32Source().ElementAt(1); </span><span style="color: green;">// ArgumentOutOfRangeException.

    </span><span style="color: blue;">int </span><span style="color: black;">elementAt0OfEmptySource = EmptyInt32Source().ElementAt(0); </span><span style="color: green;">// ArgumentOutOfRangeException.
</span><span style="color: black;">}</span></pre>
<p>Similarly, there is ElementAtOrDefault:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">ElementAtOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: blue;">int </span><span style="color: black;">index);</span></pre>
<p>When there is no value available at the specified index, a default value is returned:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ElementAtOrDefault()
{
    </span><span style="color: blue;">int </span><span style="color: black;">elementAt9OrDefaultOfSource = Int32Source().ElementAtOrDefault(9).WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: blue;">int </span><span style="color: black;">elementAtNegativeIndexOrDefault = Int32Source().ElementAtOrDefault(-5).WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: blue;">int </span><span style="color: black;">elementAt1OrDefaultOfSingleSource = SingleInt32Source().ElementAtOrDefault(1).WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: blue;">int </span><span style="color: black;">elementAt0OrDefaultOfEmptySource = EmptyInt32Source().ElementAtOrDefault(0).WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: #2b91af;">Character </span><span style="color: black;">characterAt5OrDefault = Characters().ElementAtOrDefault(5);
    (characterAt5OrDefault == </span><span style="color: blue;">null</span><span style="color: black;">).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<p>Single is more strict. It pulls the single value from a singleton sequence.</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Single&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Single&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>If source sequence has no value or has more than one values, InvalidOperationException is thrown:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Single()
{
    </span><span style="color: blue;">int </span><span style="color: black;">singleOfSource = Int32Source().Single(); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: blue;">int </span><span style="color: black;">singleGreaterThan2OfSource = Int32Source().Single(int32 =&gt; int32 &gt; 2).WriteLine(); </span><span style="color: green;">// 3
    </span><span style="color: blue;">int </span><span style="color: black;">singleNegativeOfSource = Int32Source().Single(int32 =&gt; int32 &lt; 0); </span><span style="color: green;">// InvalidOperationException.

    </span><span style="color: blue;">int </span><span style="color: black;">singleOfSingleSource = SingleInt32Source().Single().WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">int </span><span style="color: black;">singleNegativeOfSingleSource = SingleInt32Source().Single(int32 =&gt; int32 &lt; 0); </span><span style="color: green;">// InvalidOperationException.

    </span><span style="color: blue;">int </span><span style="color: black;">singleOfEmptySource = EmptyInt32Source().Single(); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: blue;">int </span><span style="color: black;">singlePositiveOfEmptySource = EmptyInt32Source().Single(int32 =&gt; int32 == 0);  </span><span style="color: green;">// InvalidOperationException.

    </span><span style="color: #2b91af;">Character </span><span style="color: black;">singleCharacter = Characters().Single(); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: #2b91af;">Character </span><span style="color: black;">fromAsgard = Characters()
        .Single(character =&gt; </span><span style="color: #a31515;">"Asgard"</span><span style="color: black;">.Equals(character.PlaceOfBirth, </span><span style="color: #2b91af;">StringComparison</span><span style="color: black;">.Ordinal))
        .WriteLine();  </span><span style="color: green;">// Thor

    </span><span style="color: #2b91af;">Character </span><span style="color: black;">loki = Characters().Single(
        character =&gt; </span><span style="color: #a31515;">"Loki"</span><span style="color: black;">.Equals(character.Name, </span><span style="color: #2b91af;">StringComparison</span><span style="color: black;">.Ordinal)); </span><span style="color: green;">// InvalidOperationException.
</span><span style="color: black;">}</span></pre>
<p>SingleOrDefault is just slightly less strict than Single:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">SingleOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">SingleOrDefault&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>When source sequence has no value, it returns a default value. When source sequence has more than one values, it still throws InvalidOperationException:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SingleOrDefault()
{
    </span><span style="color: blue;">int </span><span style="color: black;">singleOrDefaultOfSource = Int32Source().SingleOrDefault(); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: blue;">int </span><span style="color: black;">singleNegativeOrDefaultOfSource = Int32Source().SingleOrDefault(int32 =&gt; int32 &lt; 0); </span><span style="color: green;">// InvalidOperationException.

    </span><span style="color: blue;">int </span><span style="color: black;">singleNegativeOrDefaultOfSingleSource = SingleInt32Source().SingleOrDefault(int32 =&gt; int32 &lt; 0).WriteLine(); </span><span style="color: green;">// 0

    </span><span style="color: blue;">int </span><span style="color: black;">singleOrDefaultOfEmptySource = EmptyInt32Source().SingleOrDefault().WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: blue;">int </span><span style="color: black;">singlePositiveOrDefaultOfEmptySource = EmptyInt32Source().SingleOrDefault(int32 =&gt; int32 == 0); </span><span style="color: green;">// 0

    </span><span style="color: #2b91af;">Character </span><span style="color: black;">singleCharacterOrDefault = Characters().SingleOrDefault(); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: #2b91af;">Character </span><span style="color: black;">lokiOrDefault = Characters()
        .SingleOrDefault(character =&gt; </span><span style="color: #a31515;">"Loki"</span><span style="color: black;">.Equals(character.Name, </span><span style="color: #2b91af;">StringComparison</span><span style="color: black;">.Ordinal));
    (lokiOrDefault == </span><span style="color: blue;">null</span><span style="color: black;">).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<h2>Aggregation</h2>
<p>Aggregate query methods pull all values from source sequence, and repeatedly call a function to accumulate those value. The easiest overload accepts a accumulator function:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Aggregate&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; func);</span></pre>
<p>Aggregate requires the source sequence to be not empty. When the source sequence is empty, it throws InvalidOperationException. When there is only 1 single value in he source sequence, it returns that value. When there are more than 1 values, it calls the accumulator function to accumulate the first and second values to a result, and then call the accumulator function again to accumulate the previous result and the the third value to another result, and so on, until all values are accumulated, eventually it returns the result of the last accumulator function call.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Aggregate()
{
    </span><span style="color: blue;">int </span><span style="color: black;">productOfSource = Int32Source()
        .Aggregate((currentProduct, int32) =&gt; currentProduct * int32)
        .WriteLine(); </span><span style="color: green;">// ((((-1 * 1) * 2) * 3) * -4) = 24.
    </span><span style="color: blue;">int </span><span style="color: black;">productOfSingleSource = SingleInt32Source()
        .Aggregate((currentProduct, int32) =&gt; currentProduct * int32).WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">int </span><span style="color: black;">productOfEmptySource = EmptyInt32Source()
        .Aggregate((currentProduct, int32) =&gt; currentProduct * int32); </span><span style="color: green;">// InvalidOperationException.
</span><span style="color: black;">}</span></pre>
<p>There is another overload accepts a seed:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">Aggregate&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">seed, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">&gt; func);</span></pre>
<p>With the seed provided, Aggregate does not require the source sequence to be not empty. When the source sequence is empty, it returns the seed. When the source sequence is not empty, it calls the accumulator function to accumulate the seed value and the first values to a result, and then call the accumulator function again to accumulate the previous result and the second to another result, and so on, until all values are accumulated, eventually it also returns the result of the last accumulator function call.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AggregateWithSeed()
{
    </span><span style="color: blue;">int </span><span style="color: black;">sumOfSquaresOfSource = Int32Source()
        .Aggregate(
            seed: 0,
            func: (currentSumOfSquares, int32) =&gt; currentSumOfSquares + int32 * int32)
        .WriteLine(); </span><span style="color: green;">// 31
    </span><span style="color: blue;">int </span><span style="color: black;">sumOfSquaresOfSingleSource = SingleInt32Source()
        .Aggregate(
            seed: 0,
            func: (currentSumOfSquares, int32) =&gt; currentSumOfSquares + int32 * int32)
        .WriteLine(); </span><span style="color: green;">// 25
    </span><span style="color: blue;">int </span><span style="color: black;">sumOfSquaresOfEmptySource = EmptyInt32Source()
        .Aggregate(
            seed: 0,
            func: (currentSumOfSquares, int32) =&gt; currentSumOfSquares + int32 * int32)
        .WriteLine(); </span><span style="color: green;">// 0
</span><span style="color: black;">}</span></pre>
<p>The last overload accepts an additional result selector function, which is called with the last result of accumulate function:</p>
<pre class="code"><span style="color: blue;">internal static </span><span style="color: #2b91af;">TResult </span><span style="color: black;">Aggregate&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source,
    </span><span style="color: #2b91af;">TAccumulate </span><span style="color: black;">seed,
    </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">&gt; func, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TAccumulate</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; resultSelector);</span></pre>
<p>So source.Aggregate(seed, accumulation, resultSelector) is equivalent to resultSelector(source.Aggregate(seed, accumulation)):</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AggregateWithSeedAndResultSelector()
{
    </span><span style="color: blue;">string </span><span style="color: black;">sumOfSquaresMessage = Int32Source()
        .Aggregate(
            seed: 0,
            func: (currentSumOfSquares, int32) =&gt; currentSumOfSquares + int32 * int32,
            resultSelector: result =&gt; </span><span style="color: #a31515;">$"Sum of squares: </span><span style="color: black;">{result}</span><span style="color: #a31515;">"</span><span style="color: black;">)
        .WriteLine(); </span><span style="color: green;">// Sum of squares: 31
</span><span style="color: black;">}</span></pre>
<p>Count returns the number of values in source sequence:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Count&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>It is one of the most intuitive query methods:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Count()
{
    </span><span style="color: blue;">int </span><span style="color: black;">countOfSource = Int32Source().Count().WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">int </span><span style="color: black;">countOfSingleSource = SingleInt32Source().Count().WriteLine(); </span><span style="color: green;">// 1
    </span><span style="color: blue;">int </span><span style="color: black;">countOfEmptySource = EmptyInt32Source().Count().WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: blue;">int </span><span style="color: black;">countOfCharacters = Characters().Count().WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">int </span><span style="color: black;">countOfTypesInCoreLibrary = CoreLibrary.GetExportedTypes().Count().WriteLine(); </span><span style="color: green;">// 1523
</span><span style="color: black;">}</span></pre>
<p>The other overload accepts a predicate:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Count&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>Similar to First/Last, source.Count(predicate) is equivalent to ource.Where(predicate).Count():</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">CountWithPredicate()
{
    </span><span style="color: blue;">int </span><span style="color: black;">positiveCountOfSource = Int32Source().Count(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// 3
    </span><span style="color: blue;">int </span><span style="color: black;">positiveCountOfSingleSource = SingleInt32Source().Count(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// 1
    </span><span style="color: blue;">int </span><span style="color: black;">positiveCountOfEmptySource = EmptyInt32Source().Count(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: blue;">int </span><span style="color: black;">countOfConcat = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Repeat(0, </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue)
        .Concat(</span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Repeat(0, </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue))
        .Count(); </span><span style="color: green;">// OverflowException.
    </span><span style="color: blue;">int </span><span style="color: black;">countOfCharactersFromUS = Characters()
        .Count(character =&gt; </span><span style="color: #a31515;">"US"</span><span style="color: black;">.Equals(character.PlaceOfBirth))
        .WriteLine(); </span><span style="color: green;">// 3
</span><span style="color: black;">}</span></pre>
<p>LongCount is similar to Count. It can be used for large sequence, and returns a long (System.Int64) value instead of int (System.Int32):</p>
<pre class="code"><span style="color: blue;">public static long </span><span style="color: black;">LongCount&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static long </span><span style="color: black;">LongCount&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">LongCount()
{
    </span><span style="color: blue;">long </span><span style="color: black;">longCountOfSource = Int32Source().LongCount().WriteLine(); </span><span style="color: green;">// 5L
    </span><span style="color: blue;">long </span><span style="color: black;">countOfConcat = </span><span style="color: #2b91af;">Enumerable
        </span><span style="color: black;">.Repeat(0, </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue)
        .Concat(</span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Repeat(0, </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue))
        .LongCount()
        .WriteLine(); </span><span style="color: green;">// int.MaxValue + int.MaxValue = 4294967294L
</span><span style="color: black;">}</span></pre>
<p>Max/Min&nbsp; also pulls all values from the source sequence of int values, and returns the minimum/maximum value:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Max(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static int </span><span style="color: black;">Min(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source);</span></pre>
<p>Max/Min throw InvalidOperationException if the source sequence is empty:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">MinMax()
{
    </span><span style="color: blue;">int </span><span style="color: black;">minOfSource = Int32Source().Min().WriteLine(); </span><span style="color: green;">// -4
    </span><span style="color: blue;">int </span><span style="color: black;">maxOfSource = Int32Source().Max().WriteLine(); </span><span style="color: green;">// 3

    </span><span style="color: blue;">int </span><span style="color: black;">minOfSingleSource = SingleInt32Source().Min().WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">int </span><span style="color: black;">maxOfSingleSource = SingleInt32Source().Max().WriteLine(); </span><span style="color: green;">// 5

    </span><span style="color: blue;">int </span><span style="color: black;">minOfEmptySource = EmptyInt32Source().Min(); </span><span style="color: green;">// InvalidOperationException.
    </span><span style="color: blue;">int </span><span style="color: black;">maxOfEmptySource = EmptyInt32Source().Max(); </span><span style="color: green;">// InvalidOperationException.
</span><span style="color: black;">}</span></pre>
<p>The other overload accepts a sequence of arbitrary type, and a selector function which maps each value to a int value for comparison:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Max&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; selector);

</span><span style="color: blue;">public static int </span><span style="color: black;">Min&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; selector);</span></pre>
<p>The following example queries the maximum type (type with the largest number of public members declared) in the .NET core library:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">MaxWithSelector()
{
    </span><span style="color: blue;">int </span><span style="color: black;">mostDeclaredMembers = CoreLibrary.GetExportedTypes()
        .Max(type =&gt; type.GetDeclaredMembers().Length).WriteLine(); </span><span style="color: green;">// 311
</span><span style="color: black;">}</span></pre>
<p>Here each public type is mapped the count of its public members’ count number. The maximum type in .NET core library has 311 public members. Here Max returns the maximum count of members, but does not tell which type is that count from. To query the maximum type along with the the member count, Aggregate can be used to pull all types and accumulate by the maximum member count:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AggregateWithAnonymousTypeSeed()
{
    (</span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; Types, </span><span style="color: blue;">int </span><span style="color: black;">MaxMemberCount) maxTypes = CoreLibrary.GetExportedTypes().Aggregate(
        seed: (Types: </span><span style="color: blue;">new </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt;(), MaxMemberCount: 0),
        func: (currentMax, type) =&gt;
        {
            </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Type</span><span style="color: black;">&gt; currentMaxTypes = currentMax.Types;
            </span><span style="color: blue;">int </span><span style="color: black;">currentMaxMemberCount = currentMax.MaxMemberCount;
            </span><span style="color: blue;">int </span><span style="color: black;">memberCount = type.GetDeclaredMembers().Length;
            </span><span style="color: blue;">if </span><span style="color: black;">(memberCount &gt; currentMaxMemberCount)
            {
                currentMaxTypes.Clear();
                currentMaxTypes.Add(type);
                currentMaxMemberCount = memberCount;
            }
            </span><span style="color: blue;">else if </span><span style="color: black;">(memberCount == currentMaxMemberCount)
            {
                </span><span style="color: green;">// If multiple types have the same maximum member count, take all those types.
                </span><span style="color: black;">currentMaxTypes.Add(type);
            }
            </span><span style="color: blue;">return </span><span style="color: black;">(Types: currentMaxTypes, MaxMemberCount: currentMaxMemberCount);
        }); </span><span style="color: green;">// Define query.
    </span><span style="color: black;">maxTypes.Types.WriteLines(maxType =&gt; </span><span style="color: #a31515;">$"</span><span style="color: black;">{maxType.FullName}</span><span style="color: #a31515;">:</span><span style="color: black;">{maxTypes.MaxMemberCount}</span><span style="color: #a31515;">"</span><span style="color: black;">);
    </span><span style="color: green;">// Execute query. System.Convert:311
</span><span style="color: black;">}</span></pre>
<p>In the core library, System.Convert is the winner, with 311 public members declared.</p>
<p>Besides int, Max/Min has overloads for int?, long, long?, double, double?, float, float?, decimal, decimal?. There are also overloads for arbitrary comparable type:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Max&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TSource </span><span style="color: black;">Min&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>They use Comparer&lt;TSource&gt;.Default to compare values in source sequence to determine the minimum/maximum value. Comparer&lt;TSource&gt;.Default requires TSource to implement at least one of IComparable and IComparable&lt;TSource&gt;; otherwise ArgumentException is thrown at runtime. Still take Character type as example:</p>
<pre class="code"><span style="color: blue;">internal partial class </span><span style="color: #2b91af;">Character </span><span style="color: black;">: </span><span style="color: #2b91af;">IComparable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Character</span><span style="color: black;">&gt;
{
    </span><span style="color: blue;">public int </span><span style="color: black;">CompareTo(</span><span style="color: #2b91af;">Character </span><span style="color: black;">other) =&gt;
        </span><span style="color: blue;">string</span><span style="color: black;">.Compare(</span><span style="color: blue;">this</span><span style="color: black;">.Name, other.Name, </span><span style="color: #2b91af;">StringComparison</span><span style="color: black;">.Ordinal);
}</span></pre>
<p>Now Max/Min can be used with character sequence:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">MaxMinGeneric()
{
    </span><span style="color: #2b91af;">Character </span><span style="color: black;">maxCharacter = Characters().Max().WriteLine(); </span><span style="color: green;">// Vision
    </span><span style="color: #2b91af;">Character </span><span style="color: black;">minCharacter = Characters().Min().WriteLine(); </span><span style="color: green;">// JAVIS
</span><span style="color: black;">}</span></pre>
<p>Max/Min also have overload for arbitrary type, with a selector function to maps each value to a comparable result:</p>
<pre class="code"><span style="color: blue;">public static </span><span style="color: #2b91af;">TResult </span><span style="color: black;">Max&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector);

</span><span style="color: blue;">public static </span><span style="color: #2b91af;">TResult </span><span style="color: black;">Min&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: #2b91af;">TResult</span><span style="color: black;">&gt; selector);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">MaxMinGenericWithSelector()
{
    </span><span style="color: blue;">string </span><span style="color: black;">maxName = Characters().Max(character =&gt; character.Name).WriteLine(); </span><span style="color: green;">// Vision
    </span><span style="color: blue;">string </span><span style="color: black;">minName = Characters().Min(character =&gt; character.Name).WriteLine(); </span><span style="color: green;">// JAVIS
</span><span style="color: black;">}</span></pre>
<p>Apparently, source.Max(selector) is equivalent to source.Select(selector),Max, and source.Min(selector) is equivalent to source.Select(selector).Min().</p>
<p>Sum/Average pulls all int values from the source sequence, and calculate the sum/average of all the values. The signatures are similar to Max/Min:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Sum(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source);

</span><span style="color: blue;">public static double </span><span style="color: black;">Average(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; source);</span></pre>
<p>Here Average returns double instead of int. Also, when called with empty source sequence, Sum returns 0, while Average throws InvalidOperationException:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SumAverage()
{
    </span><span style="color: blue;">int </span><span style="color: black;">sumOfSource = Int32Source().Sum().WriteLine(); </span><span style="color: green;">// 1
    </span><span style="color: blue;">double </span><span style="color: black;">averageOfSource = Int32Source().Average().WriteLine(); </span><span style="color: green;">// 0.2

    </span><span style="color: blue;">int </span><span style="color: black;">sumOfSingleSource = SingleInt32Source().Sum().WriteLine(); </span><span style="color: green;">// 5
    </span><span style="color: blue;">double </span><span style="color: black;">averageOfSingleSource = SingleInt32Source().Average().WriteLine(); </span><span style="color: green;">// 5.0

    </span><span style="color: blue;">int </span><span style="color: black;">sumOfEmptySource = EmptyInt32Source().Sum().WriteLine(); </span><span style="color: green;">// 0
    </span><span style="color: blue;">double </span><span style="color: black;">averageOfEmptySource = EmptyInt32Source().Average().WriteLine(); </span><span style="color: green;">// InvalidOperationException.
</span><span style="color: black;">}</span></pre>
<p>Sum/Average has overload for arbitrary type, with a selector function to map each value to int value for calculation:</p>
<pre class="code"><span style="color: blue;">public static int </span><span style="color: black;">Sum&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; selector);

</span><span style="color: blue;">public static double </span><span style="color: black;">Average&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; selector);</span></pre>
<p>The following example calculate the average count of public members declared on types in the core library, and the average count of all&nbsp; public members.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AverageWithSelector()
{
    </span><span style="color: blue;">double </span><span style="color: black;">averageMemberCount = CoreLibrary.GetExportedTypes()
        .Average(type =&gt; type.GetMembers().Length)
        .WriteLine(); </span><span style="color: green;">// 22.0766378244747
    </span><span style="color: blue;">double </span><span style="color: black;">averageDeclaredMemberCount = CoreLibrary.GetExportedTypes()
        .Average(type =&gt; type.GetDeclaredMembers().Length)
        .WriteLine(); </span><span style="color: green;">// 11.7527812113721
</span><span style="color: black;">}</span></pre>
<p>Similarly, Sum/Average also has overloads for int?, long, long?, double, double?, float, float?, decimal, decimal?.</p>
<h2>Quantifier</h2>
<p>Any determines whether the source sequence is not empty, by immediately trying to pull the first value from source sequence:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">Any&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source);</span></pre>
<p>For example.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Any()
{
    </span><span style="color: blue;">bool </span><span style="color: black;">anyInSource = Int32Source().Any().WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: blue;">bool </span><span style="color: black;">anyInSingleSource = SingleInt32Source().Any().WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: blue;">bool </span><span style="color: black;">anyInEmptySource = EmptyInt32Source().Any().WriteLine(); </span><span style="color: green;">// False
</span><span style="color: black;">}</span></pre>
<p>The other overload accepts a predicate function.</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">Any&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>Logically, source.Any(predicate) is equivalent to source.Where(predicate).Any().</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">AnyWithPredicate()
{
    </span><span style="color: blue;">bool </span><span style="color: black;">anyNegative = Int32Source().Any(int32 =&gt; int32 &lt; 0).WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: blue;">bool </span><span style="color: black;">anyPositive = SingleInt32Source().Any(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: blue;">bool </span><span style="color: black;">any0 = EmptyInt32Source().Any(_ =&gt; </span><span style="color: blue;">true</span><span style="color: black;">).WriteLine(); </span><span style="color: green;">// False
</span><span style="color: black;">}</span></pre>
<p>All accepts a predicate. It also tries to pull values from&nbsp; the source sequence, and calls predicate function with each value. It returns true if predicate returns true for all values; otherwise, it returns false:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">All&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">Func</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">, </span><span style="color: blue;">bool</span><span style="color: black;">&gt; predicate);</span></pre>
<p>All always returns true for empty source.</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">All()
{
    </span><span style="color: blue;">bool </span><span style="color: black;">allNegative = Int32Source().All(int32 =&gt; int32 &lt; 0).WriteLine(); </span><span style="color: green;">// False
    </span><span style="color: blue;">bool </span><span style="color: black;">allPositive = SingleInt32Source().All(int32 =&gt; int32 &gt; 0).WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: blue;">bool </span><span style="color: black;">allGreaterThanMax = EmptyInt32Source().All(int32 =&gt; int32 &gt; </span><span style="color: blue;">int</span><span style="color: black;">.MaxValue).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<p>Contains determines whether source sequence contains the specified value:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">Contains&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">Contains()
{
    </span><span style="color: blue;">bool </span><span style="color: black;">contains5InSource = Int32Source().Contains(5).WriteLine(); </span><span style="color: green;">// False
    </span><span style="color: blue;">bool </span><span style="color: black;">contains5InSingleSource = SingleInt32Source().Contains(5).WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: blue;">bool </span><span style="color: black;">contains5InEmptySource = EmptyInt32Source().Contains(5).WriteLine(); </span><span style="color: green;">// False
</span><span style="color: black;">}</span></pre>
<p>The other overload of Contains accepts a comparer:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">Contains&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; source, </span><span style="color: #2b91af;">TSource </span><span style="color: black;">value, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">ContainsWithComparer()
{
    </span><span style="color: blue;">bool </span><span style="color: black;">containsTwo = Words().Contains(</span><span style="color: #a31515;">"two"</span><span style="color: black;">, </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.Ordinal).WriteLine(); </span><span style="color: green;">// False
    </span><span style="color: blue;">bool </span><span style="color: black;">containsTwoIgnoreCase = Words().Contains(</span><span style="color: #a31515;">"two"</span><span style="color: black;">, </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.OrdinalIgnoreCase).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<p>Similar to other query methods, the first overload without comparer uses EqualityComparer&lt;TSource&gt;.Default.</p>
<h2>Equality</h2>
<p>.NET has many ways to determine equality for objects:</p>
<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/dd183759.aspx" target="_blank">Reference equality</a>/identity: object.ReferenceEquals, == operator without override</li>
<li><a href="https://msdn.microsoft.com/en-us/library/dd183755.aspx" target="_blank">Value equality</a>/equivalence: static object.Equals, instance object.Equals, object.GetHashCode, overridden == operator, IEquatable&lt;T&gt;.Equals, IEqualityComparer.Equals, IEqualityComparer&lt;T&gt;.Equals, IComparable.Compare, IComparable&lt;T&gt;.Compare, IComparer.Compare, IComparer&lt;T&gt;.Compare</li>
<li>Sequential equality: Enumerable.SequentialEqual</li>
</ul>
<p>SequentialEqual query method is provided to compares the sequential equality of 2 IEnumerable&lt;T&gt; sequences:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">SequenceEqual&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(</span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second);</span></pre>
<p>2 sequences are sequentially equal if their length are equal, and for each index, 2 values from both sequences are equal (determined by EqualityComparer&lt;TSource&gt;.Default).</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SequentialEqual()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt; first = </span><span style="color: blue;">new object</span><span style="color: black;">[] { </span><span style="color: blue;">null</span><span style="color: black;">, 1, </span><span style="color: #a31515;">"2"</span><span style="color: black;">, CoreLibrary };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt; second = </span><span style="color: blue;">new </span><span style="color: #2b91af;">List</span><span style="color: black;">&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt;() { </span><span style="color: blue;">null</span><span style="color: black;">, 1, </span><span style="color: #a31515;">$"</span><span style="color: black;">{1 + 1}</span><span style="color: #a31515;">"</span><span style="color: black;">, CoreLibrary };
    </span><span style="color: blue;">bool </span><span style="color: black;">valueEqual = first.Equals(second).WriteLine(); </span><span style="color: green;">// False
    </span><span style="color: blue;">bool </span><span style="color: black;">referenceEqual = </span><span style="color: blue;">object</span><span style="color: black;">.ReferenceEquals(first, second).WriteLine(); </span><span style="color: green;">// False
    </span><span style="color: blue;">bool </span><span style="color: black;">sequentialEqual = first.SequenceEqual(second.Concat(</span><span style="color: #2b91af;">Enumerable</span><span style="color: black;">.Empty&lt;</span><span style="color: blue;">object</span><span style="color: black;">&gt;())).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<p>Empty sequences with the same TSource type are sequentially equal:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SequentialEqualOfEmpty()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Derived</span><span style="color: black;">&gt; emptyfirst = </span><span style="color: blue;">new </span><span style="color: #2b91af;">ConcurrentQueue</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Derived</span><span style="color: black;">&gt;();
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Base</span><span style="color: black;">&gt; emptysecond = </span><span style="color: #2b91af;">ImmutableHashSet</span><span style="color: black;">.Create&lt;</span><span style="color: #2b91af;">Base</span><span style="color: black;">&gt;();
    </span><span style="color: blue;">bool </span><span style="color: black;">sequentialEqual = emptyfirst.SequenceEqual(emptysecond).WriteLine(); </span><span style="color: green;">// True
</span><span style="color: black;">}</span></pre>
<p>The other overload accepts a comparer:</p>
<pre class="code"><span style="color: blue;">public static bool </span><span style="color: black;">SequenceEqual&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt;(
    </span><span style="color: blue;">this </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; first, </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; second, </span><span style="color: #2b91af;">IEqualityComparer</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">TSource</span><span style="color: black;">&gt; comparer);</span></pre>
<p>For example:</p>
<pre class="code"><span style="color: blue;">internal static void </span><span style="color: black;">SequentialEqualWithComparer()
{
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; first = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: blue;">null</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">.Empty, </span><span style="color: #a31515;">"ss"</span><span style="color: black;">, };
    </span><span style="color: #2b91af;">IEnumerable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; second = </span><span style="color: blue;">new string</span><span style="color: black;">[] { </span><span style="color: blue;">null</span><span style="color: black;">, </span><span style="color: blue;">string</span><span style="color: black;">.Empty, </span><span style="color: #a31515;">"ß"</span><span style="color: black;">, };
    </span><span style="color: #2b91af;">CultureInfo</span><span style="color: black;">.CurrentCulture = </span><span style="color: blue;">new </span><span style="color: #2b91af;">CultureInfo</span><span style="color: black;">(</span><span style="color: #a31515;">"en-US"</span><span style="color: black;">);
    </span><span style="color: blue;">bool </span><span style="color: black;">sequentialEqual1 = first.SequenceEqual(second, </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.CurrentCulture).WriteLine(); </span><span style="color: green;">// True
    </span><span style="color: blue;">bool </span><span style="color: black;">sequentialEqual2 = first.SequenceEqual(second, </span><span style="color: #2b91af;">StringComparer</span><span style="color: black;">.Ordinal).WriteLine(); </span><span style="color: green;">// False
</span><span style="color: black;">}</span></pre>
<p>Again, the first overload without comparer uses EqualityComparer&lt;TSource&gt;.Default.</p>
<h1>Queries in other languages</h1>
<p>The following table compares similar APIs/language features of</p>
<ul>
<li>LINQ to Objects query methods in <a href="https://msdn.microsoft.com/en-us/library/system.linq.enumerable.aspx" target="_blank">System.Linq.Enumerable</a></li>
<li>C# <a href="https://msdn.microsoft.com/en-us/library/bb310804.aspx" target="_blank">query keywords</a></li>
<li>F# <a href="https://msdn.microsoft.com/en-us/library/ee353635.aspx" target="_blank">Seq Module</a> and <a href="https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/Query.fsi" target="_blank">QueryBuilder</a></li>
<li>Haskell <a href="https://www.haskell.org/hugs/pages/libraries/base/Data-List.html" target="_blank">Data.List</a></li>
<li>JavaScript <a href="https://msdn.microsoft.com/en-us/LIBRary/k4h76zbx.aspx" target="_blank">Array.prototype</a></li>
</ul>
<p>Please notice JavaScript methods are not deferred.</p>
<table width="922" cellspacing="0" cellpadding="0" border="0">
<tbody>
<tr>
<td width="135" valign="top">Enumerable</td>
<td width="165" valign="top">C#</td>
<td width="150" valign="top">F# Seq</td>
<td width="183" valign="top">F# query builder</td>
<td width="179" valign="top">Haskell</td>
<td width="108" valign="top">JavaScript</td>
</tr>
<tr>
<td width="135" valign="top">Aggregate</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">fold, reduce</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">foldl</td>
<td width="108" valign="top">reduce</td>
</tr>
<tr>
<td width="135" valign="top">&nbsp;</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">foldr</td>
<td width="108" valign="top">reduceRight</td>
</tr>
<tr>
<td width="135" valign="top">All</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">forAll</td>
<td width="183" valign="top">all</td>
<td width="179" valign="top">all</td>
<td width="108" valign="top">every</td>
</tr>
<tr>
<td width="135" valign="top">Any</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">exists</td>
<td width="183" valign="top">exists</td>
<td width="179" valign="top">null, any</td>
<td width="108" valign="top">some</td>
</tr>
<tr>
<td width="135" valign="top">Average</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">average, averageBy</td>
<td width="183" valign="top">averageBy</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Cast</td>
<td width="165" valign="top">from/join T … in …</td>
<td width="150" valign="top">cast</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Concat</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">append</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">++</td>
<td width="108" valign="top">concat</td>
</tr>
<tr>
<td width="135" valign="top">Contains</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">contains</td>
<td width="179" valign="top">elem</td>
<td width="108" valign="top">includes</td>
</tr>
<tr>
<td width="135" valign="top">Count</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">length</td>
<td width="183" valign="top">count</td>
<td width="179" valign="top">length</td>
<td width="108" valign="top">length</td>
</tr>
<tr>
<td width="135" valign="top">Distinct</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">dictinct, dictinctBy</td>
<td width="183" valign="top">distinct</td>
<td width="179" valign="top">nub, nubBy</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">ElementAt</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">nth</td>
<td width="183" valign="top">nth</td>
<td width="179" valign="top">!!</td>
<td width="108" valign="top">[]</td>
</tr>
<tr>
<td width="135" valign="top">Empty</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">empty</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">[]</td>
<td width="108" valign="top">[]</td>
</tr>
<tr>
<td width="135" valign="top">Except</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">\\</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">First</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">find, head, pick</td>
<td width="183" valign="top">find, head</td>
<td width="179" valign="top">head</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">FirstOrDefault</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">tryFind, tryPick</td>
<td width="183" valign="top">headOrDefault</td>
<td width="179" valign="top">find</td>
<td width="108" valign="top">find</td>
</tr>
<tr>
<td width="135" valign="top">GroupBy</td>
<td width="165" valign="top">group … by</td>
<td width="150" valign="top">groupBy</td>
<td width="183" valign="top">groupBy, groupValBy</td>
<td width="179" valign="top">groupBy</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">GroupJoin</td>
<td width="165" valign="top">join … into</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">groupJoin, leftOuterJoin</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Intersect</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">intersect, intersectBy</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Join</td>
<td width="165" valign="top">join</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">join</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Last</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">last</td>
<td width="183" valign="top">last</td>
<td width="179" valign="top">last</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">LastOrDefault</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">lastOrDefault</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Max</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">max, maxBy</td>
<td width="183" valign="top">maxBy</td>
<td width="179" valign="top">maximum, maximumBy</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Min</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">min, minBy</td>
<td width="183" valign="top">minBy</td>
<td width="179" valign="top">minimum, minimumBy</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">OrderBy</td>
<td width="165" valign="top">orderby … (ascending)</td>
<td width="150" valign="top">sort, sortBy</td>
<td width="183" valign="top">sortBy</td>
<td width="179" valign="top">sort, sortOn, sortBy</td>
<td width="108" valign="top">sort</td>
</tr>
<tr>
<td width="135" valign="top">OrferByDescending</td>
<td width="165" valign="top">orderby … descending</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">sortByDescending</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Range</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">..</td>
<td width="179" valign="top">…</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Repeat</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">replicate</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Reverse</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">reverse</td>
<td width="108" valign="top">reverse</td>
</tr>
<tr>
<td width="135" valign="top">Select</td>
<td width="165" valign="top">from … select, let</td>
<td width="150" valign="top">map</td>
<td width="183" valign="top">select</td>
<td width="179" valign="top">map</td>
<td width="108" valign="top">map</td>
</tr>
<tr>
<td width="135" valign="top">SelectMany</td>
<td width="165" valign="top">from … from … select</td>
<td width="150" valign="top">collect</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">bind, &gt;&gt;=</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">SequenceEqual</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Single</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">exactlyOne</td>
<td width="183" valign="top">exactlyOne</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">SingleOrDefault</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">exactlyOneOrDefault</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Skip</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">skip</td>
<td width="183" valign="top">skip</td>
<td width="179" valign="top">drop</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">SkipWhile</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">skipWhile</td>
<td width="183" valign="top">skipWhile</td>
<td width="179" valign="top">dropWhile</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Sum</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">sum, sumBy</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">sum</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Take</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">take, truncate</td>
<td width="183" valign="top">take</td>
<td width="179" valign="top">take</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">TakeWhile</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">takeWhile</td>
<td width="183" valign="top">takeWhile</td>
<td width="179" valign="top">takeWhile</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">ThenBy</td>
<td width="165" valign="top">orderby … (ascending)</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">thenBy</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">ThenByDescending</td>
<td width="165" valign="top">orderby … descending</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">thenByDescending</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">ToArray</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">toArray</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">ToDictionary</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">entries</td>
</tr>
<tr>
<td width="135" valign="top">ToList</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">toList</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">&nbsp;</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Union</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">&nbsp;</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">union, unionBy</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
<tr>
<td width="135" valign="top">Where</td>
<td width="165" valign="top">where</td>
<td width="150" valign="top">filter, where</td>
<td width="183" valign="top">where</td>
<td width="179" valign="top">filter</td>
<td width="108" valign="top">filter</td>
</tr>
<tr>
<td width="135" valign="top">Zip</td>
<td width="165" valign="top">&nbsp;</td>
<td width="150" valign="top">zip</td>
<td width="183" valign="top">&nbsp;</td>
<td width="179" valign="top">zipWith</td>
<td width="108" valign="top">&nbsp;</td>
</tr>
</tbody>
</table>
<p>There are connections among LINQ, C#, F#, and Haskell. As <a href="http://ericlippert.com/" target="_blank">Eric Lippert</a>&nbsp;<a href="http://stackoverflow.com/questions/4683506/are-there-any-connections-between-haskell-and-linq" target="_blank">said</a>:</p>
<blockquote>
<p>Yes, the design of LINQ query comprehensions was heavily influenced by the design of Haskell.</p>
</blockquote>
<p>For F# and C#/Haskell, <a href="https://en.wikipedia.org/wiki/Don_Syme" target="_blank">Don Syme</a> (designer and architect of F#) <a href="https://www.simple-talk.com/opinion/geek-of-the-week/don-syme-geek-of-the-week/" target="_blank">said</a>:</p>
<blockquote>
<p>As it developed, F# borrowed more ideas from other languages: Haskell was influential in many ways, from basic syntax elements such as the ‘light’ syntax, to rich constructs such as sequence expressions and computation expressions, which are ways of generating and composing data structures.</p>
</blockquote>
<p>Microsoft also directly experimented Haskell on .NET. In <a href="http://www.infoq.com/interviews/F-Sharp-Don-Syme" target="_blank">an interview</a>, Don Syme mentioned:</p>
<blockquote>
<p>During this time we had a go doing Haskell for .NET, we actually got a long way in doing that, but in the end there is quite a lot of dissonance between Haskell and .NET.</p>


</div>
</body>
</html>
